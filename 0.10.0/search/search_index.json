{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Stash GraphQL Client","text":"<p>Async Python client for Stash GraphQL API</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p><code>stash-graphql-client</code> is a modern, type-safe Python library for interacting with Stash media server's GraphQL API. Built with async-first architecture and comprehensive Pydantic type definitions, it provides a robust foundation for automating and extending your Stash instance.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Async-first: Built on <code>gql</code> with <code>HTTPXAsyncTransport</code> and <code>WebsocketsTransport</code></li> <li>\ud83d\udcdd Fully Typed: All Stash GraphQL schema objects as Pydantic v2 models</li> <li>\ud83d\udd04 Complete CRUD: Operations for scenes, galleries, performers, studios, tags, and more</li> <li>\u2699\ufe0f Job Management: Metadata scanning, generation, and real-time job status tracking</li> <li>\ud83d\udce1 Subscriptions: GraphQL subscription support for live updates</li> <li>\ud83c\udfaf Identity Map: Built-in caching for efficient object reuse and relationship navigation</li> <li>\ud83d\udcc5 Fuzzy Dates: First-class support for Stash v0.30.0+ partial date formats</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from stash_graphql_client import StashClient, StashContext\nfrom stash_graphql_client.types import Tag\n\n# Using context manager (recommended)\nasync with StashContext(conn={\n    \"Host\": \"localhost\",\n    \"Port\": 9999,\n    \"ApiKey\": \"your-api-key\",  # Optional\n}) as client:\n    # Find all studios\n    result = await client.find_studios()\n    print(f\"Found {result.count} studios\")\n\n    # Create a new tag\n    tag = await client.create_tag(Tag(name=\"My Tag\"))\n    print(f\"Created tag: {tag.name}\")\n</code></pre>"},{"location":"#what-makes-this-different","title":"What Makes This Different?","text":""},{"location":"#identity-map-pattern","title":"Identity Map Pattern","text":"<p>Same entity IDs return the same object reference across all queries, ensuring data consistency:</p> <pre><code>scene1 = Scene.from_dict({\"id\": \"123\", \"title\": \"Test\"})\nscene2 = Scene.from_dict({\"id\": \"123\", \"title\": \"Test\"})\nassert scene1 is scene2  # Same cached object!\n</code></pre>"},{"location":"#unset-sentinel","title":"UNSET Sentinel","text":"<p>Distinguish between unqueried fields, null values, and actual data:</p> <pre><code>from stash_graphql_client.types import UNSET\n\nscene.title = \"Test\"   # Set to value\nscene.title = None     # Explicitly null\nscene.title = UNSET    # Never queried\n</code></pre>"},{"location":"#fuzzy-date-support","title":"Fuzzy Date Support","text":"<p>Work with partial dates just like Stash v0.30.0+:</p> <pre><code>from stash_graphql_client.types import FuzzyDate\n\ndate = FuzzyDate(\"2024-03\")  # Year-month precision\nprint(date.precision)  # DatePrecision.MONTH\n</code></pre>"},{"location":"#who-should-use-this","title":"Who Should Use This?","text":"<p>This library is perfect for:</p> <ul> <li>Automation: Build scripts to organize and manage your Stash library</li> <li>Integration: Connect Stash with other tools and services</li> <li>Extensions: Create custom workflows and plugins</li> <li>Analysis: Extract and analyze metadata from your collection</li> <li>Testing: Programmatically interact with Stash for testing purposes</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>:material-book-open-variant:{ .lg .middle } User Guide</li> </ul> <p>Learn core concepts and patterns</p> <p>:octicons-arrow-right-24: UNSET Pattern</p> <ul> <li>:material-code-tags:{ .lg .middle } API Reference</li> </ul> <p>Comprehensive API documentation</p> <p>:octicons-arrow-right-24: API Docs</p> <ul> <li>:material-calendar:{ .lg .middle } Fuzzy Dates</li> </ul> <p>Work with partial dates</p> <p>:octicons-arrow-right-24: Date Utilities</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU Affero General Public License v3.0 (AGPL-3.0-or-later).</p> <p>See LICENSE for the full license text.</p> <p>This license ensures:</p> <ul> <li>\u2705 Open source code sharing</li> <li>\u2705 Network use requires source disclosure</li> <li>\u2705 Compatible with Stash (also AGPL-3.0)</li> <li>\u2705 Derivative works must also be AGPL-3.0</li> </ul>"},{"location":"diagrams/","title":"Architecture Diagrams","text":"<p>This page contains the architecture diagrams for stash-graphql-client.</p>"},{"location":"diagrams/#three-layer-architecture","title":"Three-Layer Architecture","text":"<pre><code>graph TB\n    User[Developer Code] --&gt; Client[Layer 1: StashClient]\n    User --&gt; Types[Layer 2: Pydantic Types]\n    User --&gt; Store[Layer 3: StashEntityStore]\n\n    Client --&gt;|executes| GraphQL[GraphQL API]\n    Client --&gt;|returns| Types\n\n    Types --&gt;|validates| Pydantic[Pydantic v2]\n    Types --&gt;|wrap validator| IdentityMap[Identity Map]\n\n    Store --&gt;|uses| Client\n    Store --&gt;|manages| IdentityMap\n    Store --&gt;|caches| Types\n\n    GraphQL --&gt;|responses| Client\n\n    style Client fill:#2E86AB,color:#fff\n    style Types fill:#F77F00,color:#fff\n    style Store fill:#8338EC,color:#fff\n    style IdentityMap fill:#06A77D,color:#fff</code></pre>"},{"location":"diagrams/#identity-map-flow-wrap-validator","title":"Identity Map Flow (Wrap Validator)","text":"<pre><code>sequenceDiagram\n    participant Code as Developer Code\n    participant Constructor as Scene.from_dict()\n    participant Validator as @model_validator(mode='wrap')\n    participant Cache as Identity Map Cache\n    participant Pydantic as Pydantic Handler\n    participant Object as Scene Instance\n\n    Code-&gt;&gt;Constructor: Scene.from_dict({\"id\": \"123\", ...})\n    Constructor-&gt;&gt;Validator: Intercept construction\n\n    alt Cache Hit\n        Validator-&gt;&gt;Cache: Check cache[(type, id)]\n        Cache--&gt;&gt;Validator: Found cached instance\n        Validator-&gt;&gt;Object: Merge new fields\n        Validator--&gt;&gt;Code: Return cached instance\n    else Cache Miss\n        Validator-&gt;&gt;Cache: Not found\n        Validator-&gt;&gt;Validator: Process nested objects\n        Validator-&gt;&gt;Pydantic: handler(processed_data)\n        Pydantic-&gt;&gt;Object: Construct &amp; validate\n        Object--&gt;&gt;Validator: New instance\n        Validator-&gt;&gt;Cache: Store instance\n        Validator--&gt;&gt;Code: Return new instance\n    end\n\n    Note over Validator,Cache: Cache check happens&lt;br/&gt;BEFORE Pydantic validation</code></pre>"},{"location":"diagrams/#unset-pattern-three-states","title":"UNSET Pattern - Three States","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; UNSET: Default state\n    UNSET --&gt; Value: Assign value\n    UNSET --&gt; Null: Assign None\n    Value --&gt; Value: Update value\n    Value --&gt; Null: Assign None\n    Value --&gt; UNSET: Reset to UNSET\n    Null --&gt; Value: Assign value\n    Null --&gt; UNSET: Reset to UNSET\n    Null --&gt; Null: Stays None\n\n    note right of UNSET\n        Field never queried\n        or never set.\n        Excluded from\n        to_graphql()\n    end note\n\n    note right of Null\n        Explicitly set\n        to null.\n        Included in\n        to_graphql()\n    end note\n\n    note right of Value\n        Has actual value.\n        Included in\n        to_graphql()\n    end note</code></pre>"},{"location":"diagrams/#nested-cache-lookup-process","title":"Nested Cache Lookup Process","text":"<pre><code>flowchart TD\n    Start[from_dict called with data] --&gt; HasStore{Has store?}\n    HasStore --&gt;|No| DirectPydantic[Pass to Pydantic]\n    HasStore --&gt;|Yes| CheckID{Has 'id' field?}\n\n    CheckID --&gt;|No| DirectPydantic\n    CheckID --&gt;|Yes| CacheKey[Build cache key: type, id]\n\n    CacheKey --&gt; CacheCheck{In cache?}\n    CacheCheck --&gt;|Yes + Not Expired| ReturnCached[Return cached instance]\n    CacheCheck --&gt;|Yes + Expired| Evict[Evict from cache]\n    CacheCheck --&gt;|No| ProcessNested\n\n    Evict --&gt; ProcessNested[Process nested objects]\n    ProcessNested --&gt; IterateFields[Iterate model fields]\n\n    IterateFields --&gt; CheckField{Field is&lt;br/&gt;nested object?}\n    CheckField --&gt;|No| NextField[Next field]\n    CheckField --&gt;|Yes| NestedCache{Nested obj&lt;br/&gt;in cache?}\n\n    NestedCache --&gt;|Yes| ReplaceWithCached[Replace dict with&lt;br/&gt;cached instance]\n    NestedCache --&gt;|No| KeepDict[Keep as dict]\n\n    ReplaceWithCached --&gt; NextField\n    KeepDict --&gt; NextField\n    NextField --&gt; MoreFields{More fields?}\n\n    MoreFields --&gt;|Yes| CheckField\n    MoreFields --&gt;|No| CallHandler[Call Pydantic handler]\n\n    CallHandler --&gt; Validate[Pydantic validates]\n    Validate --&gt; NewInstance[New instance created]\n    NewInstance --&gt; CacheNew[Cache new instance]\n    CacheNew --&gt; ReturnNew[Return new instance]\n\n    ReturnCached --&gt; End[Instance]\n    ReturnNew --&gt; End\n    DirectPydantic --&gt; End\n\n    style CacheCheck fill:#06A77D,color:#fff\n    style ReturnCached fill:#06A77D,color:#fff\n    style ProcessNested fill:#F77F00,color:#fff\n    style Validate fill:#2E86AB,color:#fff</code></pre>"},{"location":"diagrams/#relationship-sync-flow","title":"Relationship Sync Flow","text":"<pre><code>sequenceDiagram\n    participant Code as Developer Code\n    participant Scene as Scene Instance\n    participant Studio as Studio Instance\n    participant Metadata as RelationshipMetadata\n    participant Sync as _sync_inverse_relationship()\n\n    Code-&gt;&gt;Scene: scene.studio = studio_obj\n    Scene-&gt;&gt;Scene: __setattr__(\"studio\", studio_obj)\n    Scene-&gt;&gt;Metadata: Get relationship metadata\n    Metadata--&gt;&gt;Scene: {inverse_query_field: \"scenes\", ...}\n\n    Scene-&gt;&gt;Sync: _sync_inverse_relationship(\"studio\", studio_obj)\n\n    alt Inverse field loaded\n        Sync-&gt;&gt;Studio: Check if studio.scenes is loaded\n        Studio--&gt;&gt;Sync: is_set(studio.scenes) = True\n        Sync-&gt;&gt;Studio: studio.scenes.append(scene)\n        Note over Scene,Studio: Bidirectional sync complete\n    else Inverse field not loaded\n        Sync-&gt;&gt;Studio: studio.scenes is UNSET\n        Note over Scene,Studio: Skip sync (would need to query)\n    end\n\n    Sync--&gt;&gt;Code: Relationship set</code></pre>"},{"location":"diagrams/#field-aware-population","title":"Field-Aware Population","text":"<pre><code>flowchart TD\n    Start[store.populate called] --&gt; CheckReceived{Check&lt;br/&gt;_received_fields}\n\n    CheckReceived --&gt; CalcMissing[Calculate missing:&lt;br/&gt;requested - received]\n    CalcMissing --&gt; HasMissing{Has missing&lt;br/&gt;fields?}\n\n    HasMissing --&gt;|No| Return[Return instance]\n    HasMissing --&gt;|Yes| BuildQuery[Build GraphQL query&lt;br/&gt;for missing fields only]\n\n    BuildQuery --&gt; Execute[Execute query]\n    Execute --&gt; Response[GraphQL response]\n\n    Response --&gt; MergeFields[Merge new fields into&lt;br/&gt;cached instance]\n    MergeFields --&gt; UpdateReceived[Update _received_fields]\n    UpdateReceived --&gt; Return\n\n    style CheckReceived fill:#F77F00,color:#fff\n    style MergeFields fill:#06A77D,color:#fff\n    style UpdateReceived fill:#2E86AB,color:#fff</code></pre>"},{"location":"diagrams/#django-style-filter-translation","title":"Django-Style Filter Translation","text":"<pre><code>flowchart LR\n    Input[\"rating100__gte=80\"] --&gt; Parse[Parse kwargs]\n    Parse --&gt; Split[Split on '__']\n    Split --&gt; Field[Field: 'rating100']\n    Split --&gt; Modifier[Modifier: 'gte']\n\n    Field --&gt; BuildFilter[Build filter object]\n    Modifier --&gt; MapModifier[Map to GraphQL modifier]\n\n    MapModifier --&gt; GraphQLMod[\"GREATER_THAN\"]\n\n    BuildFilter --&gt; Combine[Combine field + modifier]\n    GraphQLMod --&gt; Combine\n\n    Combine --&gt; Output[\"{\\n  rating100: {\\n    value: 80,\\n    modifier: 'GREATER_THAN'\\n  }\\n}\"]\n\n    style Input fill:#2E86AB,color:#fff\n    style Output fill:#06A77D,color:#fff</code></pre>"},{"location":"api/client/","title":"StashClient","text":"<p>The main client interface for interacting with Stash's GraphQL API.</p>"},{"location":"api/client/#stash_graphql_client.client.StashClient","title":"StashClient","text":"<pre><code>StashClient(\n    conn: dict[str, Any] | None = None,\n    verify_ssl: bool = True,\n)\n</code></pre> <p>               Bases: <code>StashClientBase</code>, <code>ConfigClientMixin</code>, <code>FileClientMixin</code>, <code>FilterClientMixin</code>, <code>GalleryClientMixin</code>, <code>GroupClientMixin</code>, <code>ImageClientMixin</code>, <code>JobsClientMixin</code>, <code>MarkerClientMixin</code>, <code>MetadataClientMixin</code>, <code>PackageClientMixin</code>, <code>PerformerClientMixin</code>, <code>PluginClientMixin</code>, <code>SceneClientMixin</code>, <code>ScraperClientMixin</code>, <code>StudioClientMixin</code>, <code>SubscriptionClientMixin</code>, <code>SystemQueryClientMixin</code>, <code>TagClientMixin</code>, <code>VersionClientMixin</code>, <code>NotImplementedClientMixin</code></p> <p>Full Stash client combining all functionality.</p> <p>Initialize client.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>dict[str, Any] | None</code> <p>Connection details dictionary with: - Scheme: Protocol (default: \"http\") - Host: Hostname (default: \"localhost\") - Port: Port number (default: 9999) - ApiKey: Optional API key - Logger: Optional logger instance</p> <code>None</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates</p> <code>True</code>"},{"location":"api/client/#stash_graphql_client.client.StashClient-attributes","title":"Attributes","text":""},{"location":"api/client/#stash_graphql_client.client.StashClient.log","title":"log  <code>instance-attribute</code>","text":"<pre><code>log = (\n    get(\"Logger\", client_logger) if conn else client_logger\n)\n</code></pre>"},{"location":"api/client/#stash_graphql_client.client.StashClient.fragments","title":"fragments  <code>instance-attribute</code>","text":"<pre><code>fragments: Any = fragments\n</code></pre>"},{"location":"api/client/#stash_graphql_client.client.StashClient.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = f'{scheme}://{host}:{port}/graphql'\n</code></pre>"},{"location":"api/context/","title":"StashContext","text":"<p>Context manager for managing the StashClient lifecycle.</p>"},{"location":"api/context/#stash_graphql_client.context.StashContext","title":"StashContext","text":"<pre><code>StashContext(\n    conn: dict[str, Any] | None = None,\n    verify_ssl: bool = True,\n)\n</code></pre> <p>Context manager for Stash client.</p> <p>This class provides a high-level interface for managing Stash client connections, including: - Connection configuration - Client lifecycle management - Interface access - Reference counting for safe concurrent usage</p> Example <pre><code># Create context with connection details\ncontext = StashContext(conn={\n    \"Scheme\": \"http\",\n    \"Host\": \"localhost\",\n    \"Port\": 9999,\n    \"ApiKey\": \"your_api_key\",\n})\n\n# Use context manager (safe for concurrent tasks with singleton)\nasync with context as client:\n    performer = await client.find_performer(\"123\")\n\n    # Access entity store for caching and advanced queries\n    store = context.store\n    scene = await store.get(Scene, \"456\")\n\n# Or use directly\nclient = context.client\nstore = context.store\nperformer = await client.find_performer(\"123\")\nawait context.close()\n\n# Safe for concurrent tasks when using singleton\nawait asyncio.gather(\n    task1(context),  # Each task uses async with\n    task2(context),  # Reference counting prevents premature closure\n)\n</code></pre> <p>Initialize context.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>dict[str, Any] | None</code> <p>Connection details dictionary</p> <code>None</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates</p> <code>True</code> Source code in <code>stash_graphql_client/context.py</code> <pre><code>def __init__(\n    self,\n    conn: dict[str, Any] | None = None,\n    verify_ssl: bool = True,\n) -&gt; None:\n    \"\"\"Initialize context.\n\n    Args:\n        conn: Connection details dictionary\n        verify_ssl: Whether to verify SSL certificates\n    \"\"\"\n    # Convert connection dict to case-insensitive\n    self.conn = CIMultiDict(conn or {})\n    self.verify_ssl = verify_ssl\n    self._client: StashClient | None = None\n    self._store: StashEntityStore | None = None\n    self._ref_count: int = 0\n    self._ref_lock: asyncio.Lock = asyncio.Lock()\n</code></pre>"},{"location":"api/context/#stash_graphql_client.context.StashContext-attributes","title":"Attributes","text":""},{"location":"api/context/#stash_graphql_client.context.StashContext.conn","title":"conn  <code>instance-attribute</code>","text":"<pre><code>conn = CIMultiDict(conn or {})\n</code></pre>"},{"location":"api/context/#stash_graphql_client.context.StashContext.verify_ssl","title":"verify_ssl  <code>instance-attribute</code>","text":"<pre><code>verify_ssl = verify_ssl\n</code></pre>"},{"location":"api/context/#stash_graphql_client.context.StashContext.interface","title":"interface  <code>property</code>","text":"<pre><code>interface: StashClient\n</code></pre> <p>Get Stash interface (alias for client).</p> <p>Returns:</p> Type Description <code>StashClient</code> <p>StashClient instance</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If client is not initialized</p>"},{"location":"api/context/#stash_graphql_client.context.StashContext.client","title":"client  <code>property</code>","text":"<pre><code>client: StashClient\n</code></pre> <p>Get client instance.</p> <p>Returns:</p> Type Description <code>StashClient</code> <p>StashClient instance</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If client is not initialized</p>"},{"location":"api/context/#stash_graphql_client.context.StashContext.store","title":"store  <code>property</code>","text":"<pre><code>store: StashEntityStore\n</code></pre> <p>Get entity store instance.</p> <p>Returns:</p> Type Description <code>StashEntityStore</code> <p>StashEntityStore instance wired to StashObject identity map</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If store is not initialized</p>"},{"location":"api/context/#stash_graphql_client.context.StashContext.ref_count","title":"ref_count  <code>property</code>","text":"<pre><code>ref_count: int\n</code></pre> <p>Get current reference count.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of active async context managers using this context</p>"},{"location":"api/context/#stash_graphql_client.context.StashContext-functions","title":"Functions","text":""},{"location":"api/context/#stash_graphql_client.context.StashContext.get_client","title":"get_client  <code>async</code>","text":"<pre><code>get_client() -&gt; StashClient\n</code></pre> <p>Get initialized Stash client.</p> <p>Returns:</p> Type Description <code>StashClient</code> <p>StashClient instance</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If client initialization fails</p> Source code in <code>stash_graphql_client/context.py</code> <pre><code>async def get_client(self) -&gt; StashClient:\n    \"\"\"Get initialized Stash client.\n\n    Returns:\n        StashClient instance\n\n    Raises:\n        RuntimeError: If client initialization fails\n    \"\"\"\n    logger.debug(\n        f\"get_client called on {id(self)}, current _client: {self._client}\"\n    )\n    if self._client is None:\n        # Pass CIMultiDict directly to preserve case-insensitive lookups\n        self._client = StashClient(\n            conn=self.conn if self.conn else None,\n            verify_ssl=self.verify_ssl,\n        )\n        try:\n            await self._client.initialize()\n            logger.debug(\n                f\"Client initialization complete, _client set to {self._client}\"\n            )\n\n            # Initialize entity store and wire it to StashObject\n            self._store = StashEntityStore(self._client)\n            StashObject._store = self._store\n            logger.debug(\"Entity store initialized and wired to StashObject\")\n\n        except Exception as e:\n            logger.error(f\"Client initialization failed: {e}\")\n            self._client = None\n            raise RuntimeError(f\"Failed to initialize Stash client: {e}\")\n    return self._client\n</code></pre>"},{"location":"api/context/#stash_graphql_client.context.StashContext.close","title":"close  <code>async</code>","text":"<pre><code>close(force: bool = False, _internal: bool = False) -&gt; None\n</code></pre> <p>Close client connection.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>If True, force close even if reference count &gt; 0.    Use with caution as this may break concurrent tasks.</p> <code>False</code> <code>_internal</code> <code>bool</code> <p>Internal flag indicating call from aexit (already has lock)</p> <code>False</code> Note <p>When using the singleton context with async context managers, manual close() is not needed - reference counting handles cleanup. Only call manually when you created the context directly and are done with it.</p> Source code in <code>stash_graphql_client/context.py</code> <pre><code>async def close(self, force: bool = False, _internal: bool = False) -&gt; None:\n    \"\"\"Close client connection.\n\n    Args:\n        force: If True, force close even if reference count &gt; 0.\n               Use with caution as this may break concurrent tasks.\n        _internal: Internal flag indicating call from __aexit__ (already has lock)\n\n    Note:\n        When using the singleton context with async context managers,\n        manual close() is not needed - reference counting handles cleanup.\n        Only call manually when you created the context directly and are\n        done with it.\n    \"\"\"\n    # If called internally from __aexit__, we already have the lock\n    if _internal:\n        if self._client is not None:\n            await self._client.close()\n            self._client = None\n            logger.debug(\"StashClient closed\")\n        if self._store is not None:\n            # Clear store cache and unwire from StashObject\n            self._store.invalidate_all()\n            StashObject._store = None\n            self._store = None\n            logger.debug(\"Entity store cleared and unwired\")\n        return\n\n    # Manual call - need to acquire lock\n    async with self._ref_lock:\n        if self._ref_count &gt; 0 and not force:\n            logger.warning(\n                f\"Attempted to close StashContext with {self._ref_count} active references. \"\n                \"Close will be deferred until all context managers exit. \"\n                \"Use force=True to override (not recommended).\"\n            )\n            return\n\n        if self._client is not None:\n            await self._client.close()\n            self._client = None\n            logger.debug(\"StashClient closed\")\n\n        if self._store is not None:\n            # Clear store cache and unwire from StashObject\n            self._store.invalidate_all()\n            StashObject._store = None\n            self._store = None\n            logger.debug(\"Entity store cleared and unwired\")\n</code></pre>"},{"location":"api/errors/","title":"Errors","text":"<p>Custom exception types for the Stash GraphQL client.</p> <p>Stash GraphQL Client exceptions.</p> <p>This module provides exception classes for Stash client operations: - StashError: Base exception for all Stash-related errors - StashGraphQLError: GraphQL query/validation errors - StashConnectionError: Network/connection errors - StashServerError: Server-side errors (500, 503, etc.) - StashIntegrationError: Data integration/transformation errors - StashSystemNotReadyError: System not ready (SETUP/NEEDS_MIGRATION)</p>"},{"location":"api/errors/#stash_graphql_client.errors-classes","title":"Classes","text":""},{"location":"api/errors/#stash_graphql_client.errors.StashError","title":"StashError","text":"<pre><code>StashError(*args: Any)\n</code></pre> <p>               Bases: <code>RuntimeError</code></p> <p>Base exception for Stash-related errors.</p> <p>This error is raised when communication with a Stash server fails or when Stash API operations encounter errors.</p>"},{"location":"api/errors/#stash_graphql_client.errors.StashGraphQLError","title":"StashGraphQLError","text":"<pre><code>StashGraphQLError(*args: Any)\n</code></pre> <p>               Bases: <code>StashError</code></p> <p>Raised when a GraphQL query fails validation or execution.</p> <p>This may be caused by: - Invalid GraphQL query syntax - Querying non-existent fields - GraphQL validation errors - Query execution errors</p>"},{"location":"api/errors/#stash_graphql_client.errors.StashConnectionError","title":"StashConnectionError","text":"<pre><code>StashConnectionError(*args: Any)\n</code></pre> <p>               Bases: <code>StashError</code></p> <p>Raised when connection to Stash server fails.</p> <p>This may be caused by: - Network connectivity issues - Invalid Stash URL - Stash server not running - Authentication failures</p>"},{"location":"api/errors/#stash_graphql_client.errors.StashServerError","title":"StashServerError","text":"<pre><code>StashServerError(*args: Any)\n</code></pre> <p>               Bases: <code>StashError</code></p> <p>Raised when Stash server returns an error response.</p> <p>This may be caused by: - Internal server errors (500) - Service unavailable (503) - Other server-side issues</p>"},{"location":"api/errors/#stash_graphql_client.errors.StashIntegrationError","title":"StashIntegrationError","text":"<pre><code>StashIntegrationError(*args: Any)\n</code></pre> <p>               Bases: <code>StashError</code></p> <p>Raised when data integration or transformation fails.</p> <p>This may be caused by: - Invalid data format from Stash API - Type conversion errors - Missing required fields - Schema version mismatches</p>"},{"location":"api/errors/#stash_graphql_client.errors.StashSystemNotReadyError","title":"StashSystemNotReadyError","text":"<pre><code>StashSystemNotReadyError(*args: Any)\n</code></pre> <p>               Bases: <code>StashError</code></p> <p>Raised when Stash system is not ready for operations.</p> <p>This occurs when the system status is: - SETUP: Initial setup required - NEEDS_MIGRATION: Database migration required</p>"},{"location":"api/errors/#stash_graphql_client.errors.StashCleanupWarning","title":"StashCleanupWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>Warning emitted when Stash cleanup tracker encounters errors during cleanup.</p>"},{"location":"api/fragments/","title":"GraphQL Fragments","text":"<p>Reusable GraphQL query fragments.</p> <p>GraphQL fragments for Stash queries.</p> <p>These fragments match the ones defined in schema/fragments.graphql.</p>"},{"location":"api/fragments/#stash_graphql_client.fragments-attributes","title":"Attributes","text":""},{"location":"api/fragments/#stash_graphql_client.fragments.SCAN_METADATA_OPTIONS","title":"SCAN_METADATA_OPTIONS  <code>module-attribute</code>","text":"<pre><code>SCAN_METADATA_OPTIONS = \"\\n    rescan\\n    scanGenerateCovers\\n    scanGeneratePreviews\\n    scanGenerateImagePreviews\\n    scanGenerateSprites\\n    scanGeneratePhashes\\n    scanGenerateThumbnails\\n    scanGenerateClipPreviews\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.AUTO_TAG_METADATA_OPTIONS","title":"AUTO_TAG_METADATA_OPTIONS  <code>module-attribute</code>","text":"<pre><code>AUTO_TAG_METADATA_OPTIONS = (\n    \"\\n    performers\\n    studios\\n    tags\\n\"\n)\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GENERATE_METADATA_OPTIONS","title":"GENERATE_METADATA_OPTIONS  <code>module-attribute</code>","text":"<pre><code>GENERATE_METADATA_OPTIONS = \"\\n    covers\\n    sprites\\n    previews\\n    imagePreviews\\n    markers\\n    markerImagePreviews\\n    markerScreenshots\\n    transcodes\\n    phashes\\n    interactiveHeatmapsSpeeds\\n    imageThumbnails\\n    clipPreviews\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIG_DEFAULTS_QUERY","title":"CONFIG_DEFAULTS_QUERY  <code>module-attribute</code>","text":"<pre><code>CONFIG_DEFAULTS_QUERY = f'\nquery ConfigurationDefaults {\n    configuration {\n        defaults {\n            scan {\n                {SCAN_METADATA_OPTIONS}\n            }\n            autoTag {\n                {AUTO_TAG_METADATA_OPTIONS}\n            }\n            generate {\n                {GENERATE_METADATA_OPTIONS}\n            }\n            deleteFile\n            deleteGenerated\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIG_GENERAL_FIELDS","title":"CONFIG_GENERAL_FIELDS  <code>module-attribute</code>","text":"<pre><code>CONFIG_GENERAL_FIELDS = \"\\n    databasePath\\n    generatedPath\\n    metadataPath\\n    scrapersPath\\n    cachePath\\n    blobsPath\\n    blobsStorage\\n    calculateMD5\\n    videoFileNamingAlgorithm\\n    parallelTasks\\n    previewAudio\\n    previewSegments\\n    previewSegmentDuration\\n    previewExcludeStart\\n    previewExcludeEnd\\n    previewPreset\\n    maxTranscodeSize\\n    maxStreamingTranscodeSize\\n    writeImageThumbnails\\n    apiKey\\n    username\\n    password\\n    maxSessionAge\\n    logFile\\n    logOut\\n    logLevel\\n    logAccess\\n    createGalleriesFromFolders\\n    galleryCoverRegex\\n    videoExtensions\\n    imageExtensions\\n    galleryExtensions\\n    excludes\\n    imageExcludes\\n    customPerformerImageLocation\\n    pythonPath\\n    transcodeInputArgs\\n    transcodeOutputArgs\\n    liveTranscodeInputArgs\\n    liveTranscodeOutputArgs\\n    drawFunscriptHeatmapRange\\n    stashes {\\n        path\\n        excludeVideo\\n        excludeImage\\n    }\\n    stashBoxes {\\n        name\\n        endpoint\\n        api_key\\n    }\\n    scraperPackageSources {\\n        name\\n        url\\n        local_path\\n    }\\n    pluginPackageSources {\\n        name\\n        url\\n        local_path\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIG_INTERFACE_FIELDS","title":"CONFIG_INTERFACE_FIELDS  <code>module-attribute</code>","text":"<pre><code>CONFIG_INTERFACE_FIELDS = \"\\n    menuItems\\n    soundOnPreview\\n    wallShowTitle\\n    wallPlayback\\n    showScrubber\\n    maximumLoopDuration\\n    noBrowser\\n    notificationsEnabled\\n    autostartVideo\\n    autostartVideoOnPlaySelected\\n    continuePlaylistDefault\\n    showStudioAsText\\n    css\\n    cssEnabled\\n    javascript\\n    javascriptEnabled\\n    customLocales\\n    customLocalesEnabled\\n    language\\n    imageLightbox {\\n        slideshowDelay\\n        displayMode\\n        scaleUp\\n        resetZoomOnNav\\n        scrollMode\\n        scrollAttemptsBeforeChange\\n    }\\n    disableDropdownCreate {\\n        performer\\n        tag\\n        studio\\n    }\\n    handyKey\\n    funscriptOffset\\n    useStashHostedFunscript\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIG_DLNA_FIELDS","title":"CONFIG_DLNA_FIELDS  <code>module-attribute</code>","text":"<pre><code>CONFIG_DLNA_FIELDS = \"\\n    serverName\\n    enabled\\n    port\\n    whitelistedIPs\\n    interfaces\\n    videoSortOrder\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIG_SCRAPING_FIELDS","title":"CONFIG_SCRAPING_FIELDS  <code>module-attribute</code>","text":"<pre><code>CONFIG_SCRAPING_FIELDS = \"\\n    scraperUserAgent\\n    scraperCertCheck\\n    scraperCDPPath\\n    excludeTagPatterns\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURATION_QUERY","title":"CONFIGURATION_QUERY  <code>module-attribute</code>","text":"<pre><code>CONFIGURATION_QUERY = f'\nquery Configuration {\n    configuration {\n        general {\n            {CONFIG_GENERAL_FIELDS}\n        }\n        interface {\n            {CONFIG_INTERFACE_FIELDS}\n        }\n        dlna {\n            {CONFIG_DLNA_FIELDS}\n        }\n        scraping {\n            {CONFIG_SCRAPING_FIELDS}\n        }\n        defaults {\n            scan {\n                {SCAN_METADATA_OPTIONS}\n            }\n            autoTag {\n                {AUTO_TAG_METADATA_OPTIONS}\n            }\n            generate {\n                {GENERATE_METADATA_OPTIONS}\n            }\n            deleteFile\n            deleteGenerated\n        }\n        ui\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.JOB_FIELDS","title":"JOB_FIELDS  <code>module-attribute</code>","text":"<pre><code>JOB_FIELDS = \"\\n    __typename\\n    id\\n    status\\n    subTasks\\n    description\\n    progress\\n    startTime\\n    endTime\\n    addTime\\n    error\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_JOB_QUERY","title":"FIND_JOB_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_JOB_QUERY = f'\nquery FindJob($input: FindJobInput!) {\n    findJob(input: $input) {\n        {JOB_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_SCAN_MUTATION","title":"METADATA_SCAN_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_SCAN_MUTATION = \"\\nmutation MetadataScan($input: ScanMetadataInput!) {\\n    metadataScan(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FILE_FIELDS","title":"FILE_FIELDS  <code>module-attribute</code>","text":"<pre><code>FILE_FIELDS = \"fragment FileFields on BaseFile {\\n    __typename\\n    id\\n    path\\n    basename\\n    parent_folder {\\n        __typename\\n        id\\n        path\\n    }\\n    zip_file {\\n        __typename\\n        id\\n        path\\n    }\\n    size\\n    mod_time\\n    created_at\\n    updated_at\\n    fingerprints {\\n        __typename\\n        type\\n        value\\n    }\\n}\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.VIDEO_FILE_FIELDS","title":"VIDEO_FILE_FIELDS  <code>module-attribute</code>","text":"<pre><code>VIDEO_FILE_FIELDS = \"fragment VideoFileFields on VideoFile {\\n    __typename\\n    ...FileFields\\n    format\\n    width\\n    height\\n    duration\\n    video_codec\\n    audio_codec\\n    frame_rate\\n    bit_rate\\n}\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGE_FILE_FIELDS","title":"IMAGE_FILE_FIELDS  <code>module-attribute</code>","text":"<pre><code>IMAGE_FILE_FIELDS = \"fragment ImageFileFields on ImageFile {\\n    __typename\\n    ...FileFields\\n    format\\n    width\\n    height\\n}\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_FILE_FIELDS","title":"GALLERY_FILE_FIELDS  <code>module-attribute</code>","text":"<pre><code>GALLERY_FILE_FIELDS = \"fragment GalleryFileFields on GalleryFile {\\n    __typename\\n    ...FileFields\\n}\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_FIELDS","title":"SCENE_FIELDS  <code>module-attribute</code>","text":"<pre><code>SCENE_FIELDS = \"\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    title\\n    code\\n    details\\n    urls\\n    date\\n    organized\\n    captions {\\n        __typename\\n        language_code\\n        caption_type\\n    }\\n    files {\\n        ...VideoFileFields\\n    }\\n    studio {\\n        __typename\\n        id\\n    }\\n    performers {\\n        __typename\\n        id\\n    }\\n    tags {\\n        __typename\\n        id\\n    }\\n    stash_ids {\\n        __typename\\n        endpoint\\n        stash_id\\n    }\\n    sceneStreams {\\n        __typename\\n        url\\n        mime_type\\n        label\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.PERFORMER_FIELDS","title":"PERFORMER_FIELDS  <code>module-attribute</code>","text":"<pre><code>PERFORMER_FIELDS = \"\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    name\\n    disambiguation\\n    urls\\n    gender\\n    birthdate\\n    ethnicity\\n    country\\n    eye_color\\n    measurements\\n    fake_tits\\n    penis_length\\n    circumcised\\n    tattoos\\n    piercings\\n    alias_list\\n    image_path\\n    details\\n    hair_color\\n    stash_ids {\\n        __typename\\n        endpoint\\n        stash_id\\n    }\\n    tags {\\n        __typename\\n        id\\n    }\\n    scenes {\\n        __typename\\n        id\\n    }\\n    groups {\\n        __typename\\n        id\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.STUDIO_FIELDS","title":"STUDIO_FIELDS  <code>module-attribute</code>","text":"<pre><code>STUDIO_FIELDS = \"\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    name\\n    urls\\n    image_path\\n    aliases\\n    details\\n    tags {\\n        __typename\\n        id\\n    }\\n    parent_studio {\\n        __typename\\n        id\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.TAG_FIELDS","title":"TAG_FIELDS  <code>module-attribute</code>","text":"<pre><code>TAG_FIELDS = \"\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    name\\n    description\\n    aliases\\n    image_path\\n    stash_ids {\\n        __typename\\n        endpoint\\n        stash_id\\n    }\\n    parents {\\n        __typename\\n        id\\n    }\\n    children {\\n        __typename\\n        id\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_QUERY_FRAGMENTS","title":"SCENE_QUERY_FRAGMENTS  <code>module-attribute</code>","text":"<pre><code>SCENE_QUERY_FRAGMENTS = f'\n{FILE_FIELDS}\n{VIDEO_FILE_FIELDS}\nfragment SceneFragment on Scene {\n    {SCENE_FIELDS}\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_SCENE_QUERY","title":"FIND_SCENE_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_SCENE_QUERY = f'\n{SCENE_QUERY_FRAGMENTS}\nquery FindScene($id: ID!) {\n    findScene(id: $id) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_SCENES_QUERY","title":"FIND_SCENES_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_SCENES_QUERY = f'\n{SCENE_QUERY_FRAGMENTS}\nquery FindScenes($filter: FindFilterType, $scene_filter: SceneFilterType) {\n    findScenes(filter: $filter, scene_filter: $scene_filter) {\n        count\n        duration\n        filesize\n        scenes {\n            ...SceneFragment\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_SCENE_MUTATION","title":"CREATE_SCENE_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_SCENE_MUTATION = f'\n{SCENE_QUERY_FRAGMENTS}\nmutation CreateScene($input: SceneCreateInput!) {\n    sceneCreate(input: $input) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_SCENE_MUTATION","title":"UPDATE_SCENE_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_SCENE_MUTATION = f'\n{SCENE_QUERY_FRAGMENTS}\nmutation UpdateScene($input: SceneUpdateInput!) {\n    sceneUpdate(input: $input) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_DUPLICATE_SCENES_QUERY","title":"FIND_DUPLICATE_SCENES_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_DUPLICATE_SCENES_QUERY = f'\n{SCENE_QUERY_FRAGMENTS}\nquery FindDuplicateScenes($distance: Int, $duration_diff: Float) {\n    findDuplicateScenes(distance: $distance, duration_diff: $duration_diff) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.PARSE_SCENE_FILENAMES_QUERY","title":"PARSE_SCENE_FILENAMES_QUERY  <code>module-attribute</code>","text":"<pre><code>PARSE_SCENE_FILENAMES_QUERY = \"\\nquery ParseSceneFilenames($filter: FindFilterType, $config: SceneParserInput!) {\\n    parseSceneFilenames(filter: $filter, config: $config)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_WALL_QUERY","title":"SCENE_WALL_QUERY  <code>module-attribute</code>","text":"<pre><code>SCENE_WALL_QUERY = f'\n{SCENE_QUERY_FRAGMENTS}\nquery SceneWall($q: String) {\n    sceneWall(q: $q) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_SCENE_UPDATE_MUTATION","title":"BULK_SCENE_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_SCENE_UPDATE_MUTATION = f'\n{SCENE_QUERY_FRAGMENTS}\nmutation BulkSceneUpdate($input: BulkSceneUpdateInput!) {\n    bulkSceneUpdate(input: $input) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENES_UPDATE_MUTATION","title":"SCENES_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENES_UPDATE_MUTATION = f'\n{SCENE_QUERY_FRAGMENTS}\nmutation ScenesUpdate($input: [SceneUpdateInput!]!) {\n    scenesUpdate(input: $input) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_GENERATE_SCREENSHOT_MUTATION","title":"SCENE_GENERATE_SCREENSHOT_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_GENERATE_SCREENSHOT_MUTATION = \"\\nmutation SceneGenerateScreenshot($id: ID!, $at: Float) {\\n    sceneGenerateScreenshot(id: $id, at: $at)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_MERGE_MUTATION","title":"SCENE_MERGE_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_MERGE_MUTATION = f'\n{SCENE_QUERY_FRAGMENTS}\nmutation SceneMerge($input: SceneMergeInput!) {\n    sceneMerge(input: $input) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_PERFORMER_QUERY","title":"FIND_PERFORMER_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_PERFORMER_QUERY = f'\nquery FindPerformer($id: ID!) {\n    findPerformer(id: $id) {\n        {PERFORMER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_PERFORMERS_QUERY","title":"FIND_PERFORMERS_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_PERFORMERS_QUERY = f'\nquery FindPerformers($filter: FindFilterType, $performer_filter: PerformerFilterType) {\n    findPerformers(filter: $filter, performer_filter: $performer_filter) {\n        count\n        performers {\n            {PERFORMER_FIELDS}\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_PERFORMER_MUTATION","title":"CREATE_PERFORMER_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_PERFORMER_MUTATION = f'\nmutation CreatePerformer($input: PerformerCreateInput!) {\n    performerCreate(input: $input) {\n        {PERFORMER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_PERFORMER_MUTATION","title":"UPDATE_PERFORMER_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_PERFORMER_MUTATION = f'\nmutation UpdatePerformer($input: PerformerUpdateInput!) {\n    performerUpdate(input: $input) {\n        {PERFORMER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_STUDIO_QUERY","title":"FIND_STUDIO_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_STUDIO_QUERY = f'\nquery FindStudio($id: ID!) {\n    findStudio(id: $id) {\n        {STUDIO_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_STUDIOS_QUERY","title":"FIND_STUDIOS_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_STUDIOS_QUERY = f'\nquery FindStudios($filter: FindFilterType, $studio_filter: StudioFilterType) {\n    findStudios(filter: $filter, studio_filter: $studio_filter) {\n        count\n        studios {\n            {STUDIO_FIELDS}\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_STUDIO_MUTATION","title":"CREATE_STUDIO_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_STUDIO_MUTATION = f'\nmutation CreateStudio($input: StudioCreateInput!) {\n    studioCreate(input: $input) {\n        {STUDIO_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_STUDIO_MUTATION","title":"UPDATE_STUDIO_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_STUDIO_MUTATION = f'\nmutation UpdateStudio($input: StudioUpdateInput!) {\n    studioUpdate(input: $input) {\n        {STUDIO_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_TAG_QUERY","title":"FIND_TAG_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_TAG_QUERY = f'\nquery FindTag($id: ID!) {\n    findTag(id: $id) {\n        {TAG_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_TAGS_QUERY","title":"FIND_TAGS_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_TAGS_QUERY = f'\nquery FindTags($filter: FindFilterType, $tag_filter: TagFilterType) {\n    findTags(filter: $filter, tag_filter: $tag_filter) {\n        count\n        tags {\n            {TAG_FIELDS}\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_TAG_MUTATION","title":"CREATE_TAG_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_TAG_MUTATION = f'\nmutation CreateTag($input: TagCreateInput!) {\n    tagCreate(input: $input) {\n        {TAG_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_TAG_MUTATION","title":"UPDATE_TAG_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_TAG_MUTATION = f'\nmutation UpdateTag($input: TagUpdateInput!) {\n    tagUpdate(input: $input) {\n        {TAG_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_FIELDS","title":"GALLERY_FIELDS  <code>module-attribute</code>","text":"<pre><code>GALLERY_FIELDS = \"\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    title\\n    code\\n    date\\n    urls\\n    details\\n    photographer\\n    organized\\n    studio {\\n        __typename\\n        id\\n    }\\n    scenes {\\n        __typename\\n        id\\n    }\\n    performers {\\n        __typename\\n        id\\n        name\\n    }\\n    tags {\\n        __typename\\n        id\\n        name\\n    }\\n    files {\\n        ...GalleryFileFields\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_QUERY_FRAGMENTS","title":"GALLERY_QUERY_FRAGMENTS  <code>module-attribute</code>","text":"<pre><code>GALLERY_QUERY_FRAGMENTS = f'\n{FILE_FIELDS}\n{GALLERY_FILE_FIELDS}\nfragment GalleryFragment on Gallery {\n    {GALLERY_FIELDS}\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_GALLERY_QUERY","title":"FIND_GALLERY_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_GALLERY_QUERY = f'\n{GALLERY_QUERY_FRAGMENTS}\nquery FindGallery($id: ID!) {\n    findGallery(id: $id) {\n        ...GalleryFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_GALLERIES_QUERY","title":"FIND_GALLERIES_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_GALLERIES_QUERY = f'\n{GALLERY_QUERY_FRAGMENTS}\nquery FindGalleries($filter: FindFilterType, $gallery_filter: GalleryFilterType) {\n    findGalleries(filter: $filter, gallery_filter: $gallery_filter) {\n        count\n        galleries {\n            ...GalleryFragment\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_GALLERY_MUTATION","title":"CREATE_GALLERY_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_GALLERY_MUTATION = f'\n{GALLERY_QUERY_FRAGMENTS}\nmutation CreateGallery($input: GalleryCreateInput!) {\n    galleryCreate(input: $input) {\n        ...GalleryFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_GALLERY_MUTATION","title":"UPDATE_GALLERY_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_GALLERY_MUTATION = f'\n{GALLERY_QUERY_FRAGMENTS}\nmutation UpdateGallery($input: GalleryUpdateInput!) {\n    galleryUpdate(input: $input) {\n        ...GalleryFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERIES_UPDATE_MUTATION","title":"GALLERIES_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>GALLERIES_UPDATE_MUTATION = f'\n{GALLERY_QUERY_FRAGMENTS}\nmutation GalleriesUpdate($input: [GalleryUpdateInput!]!) {\n    galleriesUpdate(input: $input) {\n        ...GalleryFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_DESTROY_MUTATION","title":"GALLERY_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>GALLERY_DESTROY_MUTATION = \"\\nmutation GalleryDestroy($input: GalleryDestroyInput!) {\\n    galleryDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.REMOVE_GALLERY_IMAGES_MUTATION","title":"REMOVE_GALLERY_IMAGES_MUTATION  <code>module-attribute</code>","text":"<pre><code>REMOVE_GALLERY_IMAGES_MUTATION = \"\\nmutation RemoveGalleryImages($input: GalleryRemoveInput!) {\\n    removeGalleryImages(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SET_GALLERY_COVER_MUTATION","title":"SET_GALLERY_COVER_MUTATION  <code>module-attribute</code>","text":"<pre><code>SET_GALLERY_COVER_MUTATION = \"\\nmutation SetGalleryCover($input: GallerySetCoverInput!) {\\n    setGalleryCover(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.RESET_GALLERY_COVER_MUTATION","title":"RESET_GALLERY_COVER_MUTATION  <code>module-attribute</code>","text":"<pre><code>RESET_GALLERY_COVER_MUTATION = \"\\nmutation ResetGalleryCover($input: GalleryResetCoverInput!) {\\n    resetGalleryCover(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_CHAPTER_CREATE_MUTATION","title":"GALLERY_CHAPTER_CREATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>GALLERY_CHAPTER_CREATE_MUTATION = f'\n{GALLERY_QUERY_FRAGMENTS}\nmutation GalleryChapterCreate($input: GalleryChapterCreateInput!) {\n    galleryChapterCreate(input: $input) {\n        id\n        title\n        image_index\n        gallery {\n            ...GalleryFragment\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_CHAPTER_UPDATE_MUTATION","title":"GALLERY_CHAPTER_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>GALLERY_CHAPTER_UPDATE_MUTATION = f'\n{GALLERY_QUERY_FRAGMENTS}\nmutation GalleryChapterUpdate($input: GalleryChapterUpdateInput!) {\n    galleryChapterUpdate(input: $input) {\n        id\n        title\n        image_index\n        gallery {\n            ...GalleryFragment\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_CHAPTER_DESTROY_MUTATION","title":"GALLERY_CHAPTER_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>GALLERY_CHAPTER_DESTROY_MUTATION = \"\\nmutation GalleryChapterDestroy($id: ID!) {\\n    galleryChapterDestroy(id: $id)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GALLERY_ADD_IMAGES_MUTATION","title":"GALLERY_ADD_IMAGES_MUTATION  <code>module-attribute</code>","text":"<pre><code>GALLERY_ADD_IMAGES_MUTATION = \"\\nmutation AddGalleryImages($input: GalleryAddInput!) {\\n    addGalleryImages(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGE_FIELDS","title":"IMAGE_FIELDS  <code>module-attribute</code>","text":"<pre><code>IMAGE_FIELDS = \"\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    title\\n    code\\n    organized\\n    date\\n    urls\\n    details\\n    photographer\\n    studio {\\n        __typename\\n        id\\n    }\\n    performers {\\n        __typename\\n        id\\n    }\\n    tags {\\n        __typename\\n        id\\n        name\\n    }\\n    galleries {\\n        __typename\\n        id\\n    }\\n    visual_files {\\n        __typename\\n        ... on ImageFile {\\n            ...ImageFileFields\\n        }\\n        ... on VideoFile {\\n            ...VideoFileFields\\n        }\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGE_QUERY_FRAGMENTS","title":"IMAGE_QUERY_FRAGMENTS  <code>module-attribute</code>","text":"<pre><code>IMAGE_QUERY_FRAGMENTS = f'\n{FILE_FIELDS}\n{IMAGE_FILE_FIELDS}\n{VIDEO_FILE_FIELDS}\nfragment ImageFragment on Image {\n    {IMAGE_FIELDS}\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_IMAGE_QUERY","title":"FIND_IMAGE_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_IMAGE_QUERY = f'\n{IMAGE_QUERY_FRAGMENTS}\nquery FindImage($id: ID!) {\n    findImage(id: $id) {\n        ...ImageFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_IMAGES_QUERY","title":"FIND_IMAGES_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_IMAGES_QUERY = f'\n{IMAGE_QUERY_FRAGMENTS}\nquery FindImages($filter: FindFilterType, $image_filter: ImageFilterType) {\n    findImages(filter: $filter, image_filter: $image_filter) {\n        count\n        megapixels\n        filesize\n        images {\n            ...ImageFragment\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_IMAGE_MUTATION","title":"CREATE_IMAGE_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_IMAGE_MUTATION = f'\n{IMAGE_QUERY_FRAGMENTS}\nmutation CreateImage($input: ImageCreateInput!) {\n    imageCreate(input: $input) {\n        ...ImageFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_IMAGE_MUTATION","title":"UPDATE_IMAGE_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_IMAGE_MUTATION = f'\n{IMAGE_QUERY_FRAGMENTS}\nmutation UpdateImage($input: ImageUpdateInput!) {\n    imageUpdate(input: $input) {\n        ...ImageFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGE_INCREMENT_O_MUTATION","title":"IMAGE_INCREMENT_O_MUTATION  <code>module-attribute</code>","text":"<pre><code>IMAGE_INCREMENT_O_MUTATION = \"\\nmutation ImageIncrementO($id: ID!) {\\n    imageIncrementO(id: $id)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGE_DECREMENT_O_MUTATION","title":"IMAGE_DECREMENT_O_MUTATION  <code>module-attribute</code>","text":"<pre><code>IMAGE_DECREMENT_O_MUTATION = \"\\nmutation ImageDecrementO($id: ID!) {\\n    imageDecrementO(id: $id)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGE_RESET_O_MUTATION","title":"IMAGE_RESET_O_MUTATION  <code>module-attribute</code>","text":"<pre><code>IMAGE_RESET_O_MUTATION = \"\\nmutation ImageResetO($id: ID!) {\\n    imageResetO(id: $id)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MARKER_FIELDS","title":"MARKER_FIELDS  <code>module-attribute</code>","text":"<pre><code>MARKER_FIELDS = \"\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    title\\n    seconds\\n    scene {\\n        __typename\\n        id\\n    }\\n    primary_tag {\\n        __typename\\n        id\\n    }\\n    tags {\\n        __typename\\n        id\\n    }\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_MARKER_QUERY","title":"FIND_MARKER_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_MARKER_QUERY = f'\nquery FindMarker($id: ID!) {\n    findSceneMarkers(ids: [$id]) {\n        scene_markers {\n            {MARKER_FIELDS}\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_MARKERS_QUERY","title":"FIND_MARKERS_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_MARKERS_QUERY = f'\nquery FindMarkers($filter: FindFilterType, $marker_filter: SceneMarkerFilterType) {\n    findSceneMarkers(filter: $filter, scene_marker_filter: $marker_filter) {\n        count\n        scene_markers {\n            {MARKER_FIELDS}\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_MARKER_MUTATION","title":"CREATE_MARKER_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_MARKER_MUTATION = f'\nmutation CreateMarker($input: SceneMarkerCreateInput!) {\n    sceneMarkerCreate(input: $input) {\n        {MARKER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_MARKER_MUTATION","title":"UPDATE_MARKER_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_MARKER_MUTATION = f'\nmutation UpdateMarker($input: SceneMarkerUpdateInput!) {\n    sceneMarkerUpdate(input: $input) {\n        {MARKER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_MARKER_TAG_QUERY","title":"SCENE_MARKER_TAG_QUERY  <code>module-attribute</code>","text":"<pre><code>SCENE_MARKER_TAG_QUERY = f'\nquery FindSceneMarkerTags($scene_id: ID!) {\n    sceneMarkerTags(scene_id: $scene_id) {\n        tag {\n            {TAG_FIELDS}\n        }\n        scene_markers {\n            {MARKER_FIELDS}\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.TAGS_MERGE_MUTATION","title":"TAGS_MERGE_MUTATION  <code>module-attribute</code>","text":"<pre><code>TAGS_MERGE_MUTATION = f'\nmutation TagsMerge($input: TagsMergeInput!) {\n    tagsMerge(input: $input) {\n        {TAG_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_TAG_UPDATE_MUTATION","title":"BULK_TAG_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_TAG_UPDATE_MUTATION = f'\nmutation BulkTagUpdate($input: BulkTagUpdateInput!) {\n    bulkTagUpdate(input: $input) {\n        {TAG_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_GENERATE_MUTATION","title":"METADATA_GENERATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_GENERATE_MUTATION = \"\\nmutation MetadataGenerate($input: GenerateMetadataInput!) {\\n    metadataGenerate(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_CLEAN_MUTATION","title":"METADATA_CLEAN_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_CLEAN_MUTATION = \"\\nmutation MetadataClean($input: CleanMetadataInput!) {\\n    metadataClean(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_CLEAN_GENERATED_MUTATION","title":"METADATA_CLEAN_GENERATED_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_CLEAN_GENERATED_MUTATION = \"\\nmutation MetadataCleanGenerated($input: CleanGeneratedInput!) {\\n    metadataCleanGenerated(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_AUTO_TAG_MUTATION","title":"METADATA_AUTO_TAG_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_AUTO_TAG_MUTATION = \"\\nmutation MetadataAutoTag($input: AutoTagMetadataInput!) {\\n    metadataAutoTag(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_IDENTIFY_MUTATION","title":"METADATA_IDENTIFY_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_IDENTIFY_MUTATION = \"\\nmutation MetadataIdentify($input: IdentifyMetadataInput!) {\\n    metadataIdentify(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_IMPORT_MUTATION","title":"METADATA_IMPORT_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_IMPORT_MUTATION = (\n    \"\\nmutation MetadataImport {\\n    metadataImport\\n}\\n\"\n)\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.METADATA_EXPORT_MUTATION","title":"METADATA_EXPORT_MUTATION  <code>module-attribute</code>","text":"<pre><code>METADATA_EXPORT_MUTATION = (\n    \"\\nmutation MetadataExport {\\n    metadataExport\\n}\\n\"\n)\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.EXPORT_OBJECTS_MUTATION","title":"EXPORT_OBJECTS_MUTATION  <code>module-attribute</code>","text":"<pre><code>EXPORT_OBJECTS_MUTATION = \"\\nmutation ExportObjects($input: ExportObjectsInput!) {\\n    exportObjects(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMPORT_OBJECTS_MUTATION","title":"IMPORT_OBJECTS_MUTATION  <code>module-attribute</code>","text":"<pre><code>IMPORT_OBJECTS_MUTATION = \"\\nmutation ImportObjects($input: ImportObjectsInput!) {\\n    importObjects(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BACKUP_DATABASE_MUTATION","title":"BACKUP_DATABASE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BACKUP_DATABASE_MUTATION = \"\\nmutation BackupDatabase($input: BackupDatabaseInput!) {\\n    backupDatabase(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.ANONYMISE_DATABASE_MUTATION","title":"ANONYMISE_DATABASE_MUTATION  <code>module-attribute</code>","text":"<pre><code>ANONYMISE_DATABASE_MUTATION = \"\\nmutation AnonymiseDatabase($input: AnonymiseDatabaseInput!) {\\n    anonymiseDatabase(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MIGRATE_MUTATION","title":"MIGRATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>MIGRATE_MUTATION = \"\\nmutation Migrate($input: MigrateInput!) {\\n    migrate(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MIGRATE_HASH_NAMING_MUTATION","title":"MIGRATE_HASH_NAMING_MUTATION  <code>module-attribute</code>","text":"<pre><code>MIGRATE_HASH_NAMING_MUTATION = \"\\nmutation MigrateHashNaming {\\n    migrateHashNaming\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MIGRATE_SCENE_SCREENSHOTS_MUTATION","title":"MIGRATE_SCENE_SCREENSHOTS_MUTATION  <code>module-attribute</code>","text":"<pre><code>MIGRATE_SCENE_SCREENSHOTS_MUTATION = \"\\nmutation MigrateSceneScreenshots($input: MigrateSceneScreenshotsInput!) {\\n    migrateSceneScreenshots(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MIGRATE_BLOBS_MUTATION","title":"MIGRATE_BLOBS_MUTATION  <code>module-attribute</code>","text":"<pre><code>MIGRATE_BLOBS_MUTATION = \"\\nmutation MigrateBlobs($input: MigrateBlobsInput!) {\\n    migrateBlobs(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURE_GENERAL_MUTATION","title":"CONFIGURE_GENERAL_MUTATION  <code>module-attribute</code>","text":"<pre><code>CONFIGURE_GENERAL_MUTATION = \"\\nmutation ConfigureGeneral($input: ConfigGeneralInput!) {\\n    configureGeneral(input: $input) {\\n        databasePath\\n        parallelTasks\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURE_INTERFACE_MUTATION","title":"CONFIGURE_INTERFACE_MUTATION  <code>module-attribute</code>","text":"<pre><code>CONFIGURE_INTERFACE_MUTATION = \"\\nmutation ConfigureInterface($input: ConfigInterfaceInput!) {\\n    configureInterface(input: $input) {\\n        menuItems\\n        soundOnPreview\\n        wallShowTitle\\n        wallPlayback\\n        maximumLoopDuration\\n        autostartVideo\\n        autostartVideoOnPlaySelected\\n        continuePlaylistDefault\\n        showStudioAsText\\n        noBrowser\\n        notificationsEnabled\\n        language\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURE_DLNA_MUTATION","title":"CONFIGURE_DLNA_MUTATION  <code>module-attribute</code>","text":"<pre><code>CONFIGURE_DLNA_MUTATION = \"\\nmutation ConfigureDLNA($input: ConfigDLNAInput!) {\\n    configureDLNA(input: $input) {\\n        serverName\\n        enabled\\n        port\\n        whitelistedIPs\\n        interfaces\\n        videoSortOrder\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURE_DEFAULTS_MUTATION","title":"CONFIGURE_DEFAULTS_MUTATION  <code>module-attribute</code>","text":"<pre><code>CONFIGURE_DEFAULTS_MUTATION = \"\\nmutation ConfigureDefaults($input: ConfigDefaultSettingsInput!) {\\n    configureDefaults(input: $input) {\\n        deleteFile\\n        deleteGenerated\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURE_UI_MUTATION","title":"CONFIGURE_UI_MUTATION  <code>module-attribute</code>","text":"<pre><code>CONFIGURE_UI_MUTATION = \"\\nmutation ConfigureUI($input: Map, $partial: Map) {\\n    configureUI(input: $input, partial: $partial)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURE_UI_SETTING_MUTATION","title":"CONFIGURE_UI_SETTING_MUTATION  <code>module-attribute</code>","text":"<pre><code>CONFIGURE_UI_SETTING_MUTATION = \"\\nmutation ConfigureUISetting($key: String!, $value: Any) {\\n    configureUISetting(key: $key, value: $value)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GENERATE_API_KEY_MUTATION","title":"GENERATE_API_KEY_MUTATION  <code>module-attribute</code>","text":"<pre><code>GENERATE_API_KEY_MUTATION = \"\\nmutation GenerateAPIKey($input: GenerateAPIKeyInput!) {\\n    generateAPIKey(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SYSTEM_STATUS_FIELDS","title":"SYSTEM_STATUS_FIELDS  <code>module-attribute</code>","text":"<pre><code>SYSTEM_STATUS_FIELDS = \"\\n    __typename\\n    databaseSchema\\n    databasePath\\n    configPath\\n    appSchema\\n    status\\n    os\\n    workingDir\\n    homeDir\\n    ffmpegPath\\n    ffprobePath\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SYSTEM_STATUS_QUERY","title":"SYSTEM_STATUS_QUERY  <code>module-attribute</code>","text":"<pre><code>SYSTEM_STATUS_QUERY = f'\nquery SystemStatus {\n    systemStatus {\n        {SYSTEM_STATUS_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_FILE_QUERY","title":"FIND_FILE_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_FILE_QUERY = f'\n{FILE_FIELDS}\n{VIDEO_FILE_FIELDS}\n{IMAGE_FILE_FIELDS}\n{GALLERY_FILE_FIELDS}\nquery FindFile($id: ID, $path: String) {\n    findFile(id: $id, path: $path) {\n        __typename\n        ...FileFields\n        ... on VideoFile {\n            ...VideoFileFields\n        }\n        ... on ImageFile {\n            ...ImageFileFields\n        }\n        ... on GalleryFile {\n            ...GalleryFileFields\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_FILES_QUERY","title":"FIND_FILES_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_FILES_QUERY = f'\n{FILE_FIELDS}\n{VIDEO_FILE_FIELDS}\n{IMAGE_FILE_FIELDS}\n{GALLERY_FILE_FIELDS}\nquery FindFiles($file_filter: FileFilterType, $filter: FindFilterType, $ids: [ID!]) {\n    findFiles(file_filter: $file_filter, filter: $filter, ids: $ids) {\n        count\n        megapixels\n        duration\n        size\n        files {\n            __typename\n            ...FileFields\n            ... on VideoFile {\n                ...VideoFileFields\n            }\n            ... on ImageFile {\n                ...ImageFileFields\n            }\n            ... on GalleryFile {\n                ...GalleryFileFields\n            }\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MOVE_FILES_MUTATION","title":"MOVE_FILES_MUTATION  <code>module-attribute</code>","text":"<pre><code>MOVE_FILES_MUTATION = \"\\nmutation MoveFiles($input: MoveFilesInput!) {\\n    moveFiles(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FILE_SET_FINGERPRINTS_MUTATION","title":"FILE_SET_FINGERPRINTS_MUTATION  <code>module-attribute</code>","text":"<pre><code>FILE_SET_FINGERPRINTS_MUTATION = \"\\nmutation FileSetFingerprints($input: FileSetFingerprintsInput!) {\\n    fileSetFingerprints(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_ASSIGN_FILE_MUTATION","title":"SCENE_ASSIGN_FILE_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_ASSIGN_FILE_MUTATION = \"\\nmutation SceneAssignFile($input: AssignSceneFileInput!) {\\n    sceneAssignFile(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_SCENE_BY_HASH_QUERY","title":"FIND_SCENE_BY_HASH_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_SCENE_BY_HASH_QUERY = f'\n{SCENE_QUERY_FRAGMENTS}\nquery FindSceneByHash($input: SceneHashInput!) {\n    findSceneByHash(input: $input) {\n        ...SceneFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.VERSION_QUERY","title":"VERSION_QUERY  <code>module-attribute</code>","text":"<pre><code>VERSION_QUERY = \"\\nquery Version {\\n    version {\\n        version\\n        hash\\n        build_time\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.LATEST_VERSION_QUERY","title":"LATEST_VERSION_QUERY  <code>module-attribute</code>","text":"<pre><code>LATEST_VERSION_QUERY = \"\\nquery LatestVersion {\\n    latestversion {\\n        version\\n        shorthash\\n        release_date\\n        url\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_DESTROY_MUTATION","title":"SCENE_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_DESTROY_MUTATION = \"\\nmutation SceneDestroy($input: SceneDestroyInput!) {\\n    sceneDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENES_DESTROY_MUTATION","title":"SCENES_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENES_DESTROY_MUTATION = \"\\nmutation ScenesDestroy($input: ScenesDestroyInput!) {\\n    scenesDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGE_DESTROY_MUTATION","title":"IMAGE_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>IMAGE_DESTROY_MUTATION = \"\\nmutation ImageDestroy($input: ImageDestroyInput!) {\\n    imageDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGES_DESTROY_MUTATION","title":"IMAGES_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>IMAGES_DESTROY_MUTATION = \"\\nmutation ImagesDestroy($input: ImagesDestroyInput!) {\\n    imagesDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.PERFORMER_DESTROY_MUTATION","title":"PERFORMER_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>PERFORMER_DESTROY_MUTATION = \"\\nmutation PerformerDestroy($input: PerformerDestroyInput!) {\\n    performerDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.PERFORMERS_DESTROY_MUTATION","title":"PERFORMERS_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>PERFORMERS_DESTROY_MUTATION = \"\\nmutation PerformersDestroy($ids: [ID!]!) {\\n    performersDestroy(ids: $ids)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.STUDIO_DESTROY_MUTATION","title":"STUDIO_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>STUDIO_DESTROY_MUTATION = \"\\nmutation StudioDestroy($input: StudioDestroyInput!) {\\n    studioDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.STUDIOS_DESTROY_MUTATION","title":"STUDIOS_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>STUDIOS_DESTROY_MUTATION = \"\\nmutation StudiosDestroy($ids: [ID!]!) {\\n    studiosDestroy(ids: $ids)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.TAG_DESTROY_MUTATION","title":"TAG_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>TAG_DESTROY_MUTATION = \"\\nmutation TagDestroy($input: TagDestroyInput!) {\\n    tagDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.TAGS_DESTROY_MUTATION","title":"TAGS_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>TAGS_DESTROY_MUTATION = \"\\nmutation TagsDestroy($ids: [ID!]!) {\\n    tagsDestroy(ids: $ids)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_MARKER_DESTROY_MUTATION","title":"SCENE_MARKER_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_MARKER_DESTROY_MUTATION = \"\\nmutation SceneMarkerDestroy($id: ID!) {\\n    sceneMarkerDestroy(id: $id)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_MARKERS_DESTROY_MUTATION","title":"SCENE_MARKERS_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_MARKERS_DESTROY_MUTATION = \"\\nmutation SceneMarkersDestroy($ids: [ID!]!) {\\n    sceneMarkersDestroy(ids: $ids)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.DELETE_FILES_MUTATION","title":"DELETE_FILES_MUTATION  <code>module-attribute</code>","text":"<pre><code>DELETE_FILES_MUTATION = \"\\nmutation DeleteFiles($ids: [ID!]!) {\\n    deleteFiles(ids: $ids)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_PERFORMER_UPDATE_MUTATION","title":"BULK_PERFORMER_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_PERFORMER_UPDATE_MUTATION = f'\nmutation BulkPerformerUpdate($input: BulkPerformerUpdateInput!) {\n    bulkPerformerUpdate(input: $input) {\n        {PERFORMER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.PERFORMER_MERGE_MUTATION","title":"PERFORMER_MERGE_MUTATION  <code>module-attribute</code>","text":"<pre><code>PERFORMER_MERGE_MUTATION = f'\nmutation PerformerMerge($input: PerformerMergeInput!) {\n    performerMerge(input: $input) {\n        {PERFORMER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_STUDIO_UPDATE_MUTATION","title":"BULK_STUDIO_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_STUDIO_UPDATE_MUTATION = f'\nmutation BulkStudioUpdate($input: BulkStudioUpdateInput!) {\n    bulkStudioUpdate(input: $input) {\n        {STUDIO_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_IMAGE_UPDATE_MUTATION","title":"BULK_IMAGE_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_IMAGE_UPDATE_MUTATION = f'\nmutation BulkImageUpdate($input: BulkImageUpdateInput!) {\n    bulkImageUpdate(input: $input) {\n        {IMAGE_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_SCENE_MARKER_UPDATE_MUTATION","title":"BULK_SCENE_MARKER_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_SCENE_MARKER_UPDATE_MUTATION = f'\nmutation BulkSceneMarkerUpdate($input: BulkSceneMarkerUpdateInput!) {\n    bulkSceneMarkerUpdate(input: $input) {\n        {MARKER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FOLDER_FIELDS","title":"FOLDER_FIELDS  <code>module-attribute</code>","text":"<pre><code>FOLDER_FIELDS = \"fragment FolderFields on Folder {\\n    __typename\\n    id\\n    path\\n    parent_folder_id\\n    zip_file_id\\n    mod_time\\n    created_at\\n    updated_at\\n}\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_FOLDER_QUERY","title":"FIND_FOLDER_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_FOLDER_QUERY = f'\n{FOLDER_FIELDS}\nquery FindFolder($id: ID, $path: String) {\n    findFolder(id: $id, path: $path) {\n        ...FolderFields\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_FOLDERS_QUERY","title":"FIND_FOLDERS_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_FOLDERS_QUERY = f'\n{FOLDER_FIELDS}\nquery FindFolders($folder_filter: FolderFilterType, $filter: FindFilterType, $ids: [ID!]) {\n    findFolders(folder_filter: $folder_filter, filter: $filter, ids: $ids) {\n        count\n        folders {\n            ...FolderFields\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GROUP_FIELDS","title":"GROUP_FIELDS  <code>module-attribute</code>","text":"<pre><code>GROUP_FIELDS = \"fragment GroupFields on Group {\\n    __typename\\n    id\\n    created_at\\n    updated_at\\n    name\\n    aliases\\n    duration\\n    date\\n    rating100\\n    director\\n    synopsis\\n    urls\\n    front_image_path\\n    back_image_path\\n    studio {\\n        __typename\\n        id\\n    }\\n    tags {\\n        __typename\\n        id\\n    }\\n    scenes {\\n        __typename\\n        id\\n    }\\n    containing_groups {\\n        __typename\\n        group {\\n            __typename\\n            id\\n        }\\n        description\\n    }\\n    sub_groups {\\n        __typename\\n        group {\\n            __typename\\n            id\\n        }\\n        description\\n    }\\n}\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_GROUP_QUERY","title":"FIND_GROUP_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_GROUP_QUERY = f'\n{GROUP_FIELDS}\nquery FindGroup($id: ID!) {\n    findGroup(id: $id) {\n        ...GroupFields\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_GROUPS_QUERY","title":"FIND_GROUPS_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_GROUPS_QUERY = f'\n{GROUP_FIELDS}\nquery FindGroups($filter: FindFilterType, $group_filter: GroupFilterType, $ids: [ID!]) {\n    findGroups(filter: $filter, group_filter: $group_filter, ids: $ids) {\n        count\n        groups {\n            ...GroupFields\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CREATE_GROUP_MUTATION","title":"CREATE_GROUP_MUTATION  <code>module-attribute</code>","text":"<pre><code>CREATE_GROUP_MUTATION = f'\n{GROUP_FIELDS}\nmutation CreateGroup($input: GroupCreateInput!) {\n    groupCreate(input: $input) {\n        ...GroupFields\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.UPDATE_GROUP_MUTATION","title":"UPDATE_GROUP_MUTATION  <code>module-attribute</code>","text":"<pre><code>UPDATE_GROUP_MUTATION = f'\n{GROUP_FIELDS}\nmutation UpdateGroup($input: GroupUpdateInput!) {\n    groupUpdate(input: $input) {\n        ...GroupFields\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GROUP_DESTROY_MUTATION","title":"GROUP_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>GROUP_DESTROY_MUTATION = \"\\nmutation GroupDestroy($input: GroupDestroyInput!) {\\n    groupDestroy(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.GROUPS_DESTROY_MUTATION","title":"GROUPS_DESTROY_MUTATION  <code>module-attribute</code>","text":"<pre><code>GROUPS_DESTROY_MUTATION = \"\\nmutation GroupsDestroy($ids: [ID!]!) {\\n    groupsDestroy(ids: $ids)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_GROUP_UPDATE_MUTATION","title":"BULK_GROUP_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_GROUP_UPDATE_MUTATION = f'\n{GROUP_FIELDS}\nmutation BulkGroupUpdate($input: BulkGroupUpdateInput!) {\n    bulkGroupUpdate(input: $input) {\n        ...GroupFields\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.ADD_GROUP_SUB_GROUPS_MUTATION","title":"ADD_GROUP_SUB_GROUPS_MUTATION  <code>module-attribute</code>","text":"<pre><code>ADD_GROUP_SUB_GROUPS_MUTATION = \"\\nmutation AddGroupSubGroups($input: GroupSubGroupAddInput!) {\\n    addGroupSubGroups(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.REMOVE_GROUP_SUB_GROUPS_MUTATION","title":"REMOVE_GROUP_SUB_GROUPS_MUTATION  <code>module-attribute</code>","text":"<pre><code>REMOVE_GROUP_SUB_GROUPS_MUTATION = \"\\nmutation RemoveGroupSubGroups($input: GroupSubGroupRemoveInput!) {\\n    removeGroupSubGroups(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.REORDER_SUB_GROUPS_MUTATION","title":"REORDER_SUB_GROUPS_MUTATION  <code>module-attribute</code>","text":"<pre><code>REORDER_SUB_GROUPS_MUTATION = \"\\nmutation ReorderSubGroups($input: ReorderSubGroupsInput!) {\\n    reorderSubGroups(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.STATS_QUERY","title":"STATS_QUERY  <code>module-attribute</code>","text":"<pre><code>STATS_QUERY = \"\\nquery Stats {\\n    stats {\\n        scene_count\\n        scenes_size\\n        scenes_duration\\n        image_count\\n        images_size\\n        gallery_count\\n        performer_count\\n        studio_count\\n        group_count\\n        tag_count\\n        total_o_count\\n        total_play_duration\\n        total_play_count\\n        scenes_played\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.LOGS_QUERY","title":"LOGS_QUERY  <code>module-attribute</code>","text":"<pre><code>LOGS_QUERY = \"\\nquery Logs {\\n    logs {\\n        time\\n        level\\n        message\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MARKER_WALL_QUERY","title":"MARKER_WALL_QUERY  <code>module-attribute</code>","text":"<pre><code>MARKER_WALL_QUERY = f'\nquery MarkerWall($q: String) {\n    markerWall(q: $q) {\n        {MARKER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.MARKER_STRINGS_QUERY","title":"MARKER_STRINGS_QUERY  <code>module-attribute</code>","text":"<pre><code>MARKER_STRINGS_QUERY = \"\\nquery MarkerStrings($q: String, $sort: String) {\\n    markerStrings(q: $q, sort: $sort) {\\n        count\\n        id\\n        title\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_STREAMS_QUERY","title":"SCENE_STREAMS_QUERY  <code>module-attribute</code>","text":"<pre><code>SCENE_STREAMS_QUERY = \"\\nquery SceneStreams($id: ID!) {\\n    sceneStreams(id: $id) {\\n        url\\n        mime_type\\n        label\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_ADD_O_MUTATION","title":"SCENE_ADD_O_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_ADD_O_MUTATION = \"\\nmutation SceneAddO($id: ID!, $times: [Timestamp!]) {\\n    sceneAddO(id: $id, times: $times) {\\n        count\\n        history\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_DELETE_O_MUTATION","title":"SCENE_DELETE_O_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_DELETE_O_MUTATION = \"\\nmutation SceneDeleteO($id: ID!, $times: [Timestamp!]) {\\n    sceneDeleteO(id: $id, times: $times) {\\n        count\\n        history\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_RESET_O_MUTATION","title":"SCENE_RESET_O_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_RESET_O_MUTATION = \"\\nmutation SceneResetO($id: ID!) {\\n    sceneResetO(id: $id)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_SAVE_ACTIVITY_MUTATION","title":"SCENE_SAVE_ACTIVITY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_SAVE_ACTIVITY_MUTATION = \"\\nmutation SceneSaveActivity($id: ID!, $resume_time: Float, $playDuration: Float) {\\n    sceneSaveActivity(id: $id, resume_time: $resume_time, playDuration: $playDuration)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_RESET_ACTIVITY_MUTATION","title":"SCENE_RESET_ACTIVITY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_RESET_ACTIVITY_MUTATION = \"\\nmutation SceneResetActivity($id: ID!, $reset_resume: Boolean!, $reset_duration: Boolean!) {\\n    sceneResetActivity(id: $id, reset_resume: $reset_resume, reset_duration: $reset_duration)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_ADD_PLAY_MUTATION","title":"SCENE_ADD_PLAY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_ADD_PLAY_MUTATION = \"\\nmutation SceneAddPlay($id: ID!, $times: [Timestamp!]) {\\n    sceneAddPlay(id: $id, times: $times) {\\n        count\\n        history\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_DELETE_PLAY_MUTATION","title":"SCENE_DELETE_PLAY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_DELETE_PLAY_MUTATION = \"\\nmutation SceneDeletePlay($id: ID!, $times: [Timestamp!]) {\\n    sceneDeletePlay(id: $id, times: $times) {\\n        count\\n        history\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SCENE_RESET_PLAY_COUNT_MUTATION","title":"SCENE_RESET_PLAY_COUNT_MUTATION  <code>module-attribute</code>","text":"<pre><code>SCENE_RESET_PLAY_COUNT_MUTATION = \"\\nmutation SceneResetPlayCount($id: ID!) {\\n    sceneResetPlayCount(id: $id)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.IMAGES_UPDATE_MUTATION","title":"IMAGES_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>IMAGES_UPDATE_MUTATION = f'\n{IMAGE_QUERY_FRAGMENTS}\nmutation ImagesUpdate($input: [ImageUpdateInput!]!) {\n    imagesUpdate(input: $input) {\n        ...ImageFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.BULK_GALLERY_UPDATE_MUTATION","title":"BULK_GALLERY_UPDATE_MUTATION  <code>module-attribute</code>","text":"<pre><code>BULK_GALLERY_UPDATE_MUTATION = f'\n{GALLERY_QUERY_FRAGMENTS}\nmutation BulkGalleryUpdate($input: BulkGalleryUpdateInput!) {\n    bulkGalleryUpdate(input: $input) {\n        ...GalleryFragment\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SAVED_FILTER_FIELDS","title":"SAVED_FILTER_FIELDS  <code>module-attribute</code>","text":"<pre><code>SAVED_FILTER_FIELDS = \"\\n    __typename\\n    id\\n    mode\\n    name\\n    find_filter {\\n        __typename\\n        q\\n        page\\n        per_page\\n        sort\\n        direction\\n    }\\n    object_filter\\n    ui_options\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_SAVED_FILTER_QUERY","title":"FIND_SAVED_FILTER_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_SAVED_FILTER_QUERY = f'\nquery FindSavedFilter($id: ID!) {\n    findSavedFilter(id: $id) {\n        {SAVED_FILTER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_SAVED_FILTERS_QUERY","title":"FIND_SAVED_FILTERS_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_SAVED_FILTERS_QUERY = f'\nquery FindSavedFilters($mode: FilterMode) {\n    findSavedFilters(mode: $mode) {\n        {SAVED_FILTER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SAVE_FILTER_MUTATION","title":"SAVE_FILTER_MUTATION  <code>module-attribute</code>","text":"<pre><code>SAVE_FILTER_MUTATION = f'\nmutation SaveFilter($input: SaveFilterInput!) {\n    saveFilter(input: $input) {\n        {SAVED_FILTER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.DESTROY_SAVED_FILTER_MUTATION","title":"DESTROY_SAVED_FILTER_MUTATION  <code>module-attribute</code>","text":"<pre><code>DESTROY_SAVED_FILTER_MUTATION = \"\\nmutation DestroySavedFilter($input: DestroyFilterInput!) {\\n    destroySavedFilter(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.OPTIMISE_DATABASE_MUTATION","title":"OPTIMISE_DATABASE_MUTATION  <code>module-attribute</code>","text":"<pre><code>OPTIMISE_DATABASE_MUTATION = \"\\nmutation OptimiseDatabase {\\n    optimiseDatabase\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.ALL_PERFORMERS_QUERY","title":"ALL_PERFORMERS_QUERY  <code>module-attribute</code>","text":"<pre><code>ALL_PERFORMERS_QUERY = f'\nquery AllPerformers {\n    allPerformers {\n        {PERFORMER_FIELDS}\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.FIND_SCENES_BY_PATH_REGEX_QUERY","title":"FIND_SCENES_BY_PATH_REGEX_QUERY  <code>module-attribute</code>","text":"<pre><code>FIND_SCENES_BY_PATH_REGEX_QUERY = f'\n{SCENE_QUERY_FRAGMENTS}\nquery FindScenesByPathRegex($filter: FindFilterType) {\n    findScenesByPathRegex(filter: $filter) {\n        count\n        duration\n        filesize\n        scenes {\n            ...SceneFragment\n        }\n    }\n}\n'\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.VALIDATE_STASHBOX_CREDENTIALS_QUERY","title":"VALIDATE_STASHBOX_CREDENTIALS_QUERY  <code>module-attribute</code>","text":"<pre><code>VALIDATE_STASHBOX_CREDENTIALS_QUERY = \"\\nquery ValidateStashBoxCredentials($input: StashBoxInput!) {\\n    validateStashBoxCredentials(input: $input) {\\n        valid\\n        status\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SUBMIT_STASHBOX_FINGERPRINTS_MUTATION","title":"SUBMIT_STASHBOX_FINGERPRINTS_MUTATION  <code>module-attribute</code>","text":"<pre><code>SUBMIT_STASHBOX_FINGERPRINTS_MUTATION = \"\\nmutation SubmitStashBoxFingerprints($input: StashBoxFingerprintSubmissionInput!) {\\n    submitStashBoxFingerprints(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SUBMIT_STASHBOX_SCENE_DRAFT_MUTATION","title":"SUBMIT_STASHBOX_SCENE_DRAFT_MUTATION  <code>module-attribute</code>","text":"<pre><code>SUBMIT_STASHBOX_SCENE_DRAFT_MUTATION = \"\\nmutation SubmitStashBoxSceneDraft($input: StashBoxDraftSubmissionInput!) {\\n    submitStashBoxSceneDraft(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SUBMIT_STASHBOX_PERFORMER_DRAFT_MUTATION","title":"SUBMIT_STASHBOX_PERFORMER_DRAFT_MUTATION  <code>module-attribute</code>","text":"<pre><code>SUBMIT_STASHBOX_PERFORMER_DRAFT_MUTATION = \"\\nmutation SubmitStashBoxPerformerDraft($input: StashBoxDraftSubmissionInput!) {\\n    submitStashBoxPerformerDraft(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.STASHBOX_BATCH_PERFORMER_TAG_MUTATION","title":"STASHBOX_BATCH_PERFORMER_TAG_MUTATION  <code>module-attribute</code>","text":"<pre><code>STASHBOX_BATCH_PERFORMER_TAG_MUTATION = \"\\nmutation StashBoxBatchPerformerTag($input: StashBoxBatchTagInput!) {\\n    stashBoxBatchPerformerTag(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.STASHBOX_BATCH_STUDIO_TAG_MUTATION","title":"STASHBOX_BATCH_STUDIO_TAG_MUTATION  <code>module-attribute</code>","text":"<pre><code>STASHBOX_BATCH_STUDIO_TAG_MUTATION = \"\\nmutation StashBoxBatchStudioTag($input: StashBoxBatchTagInput!) {\\n    stashBoxBatchStudioTag(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.DLNA_STATUS_QUERY","title":"DLNA_STATUS_QUERY  <code>module-attribute</code>","text":"<pre><code>DLNA_STATUS_QUERY = \"\\nquery DLNAStatus {\\n    dlnaStatus {\\n        running\\n        until\\n        recentIPAddresses\\n        allowedIPAddresses {\\n            __typename\\n            ipAddress\\n            until\\n        }\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.ENABLE_DLNA_MUTATION","title":"ENABLE_DLNA_MUTATION  <code>module-attribute</code>","text":"<pre><code>ENABLE_DLNA_MUTATION = \"\\nmutation EnableDLNA($input: EnableDLNAInput!) {\\n    enableDLNA(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.DISABLE_DLNA_MUTATION","title":"DISABLE_DLNA_MUTATION  <code>module-attribute</code>","text":"<pre><code>DISABLE_DLNA_MUTATION = \"\\nmutation DisableDLNA($input: DisableDLNAInput!) {\\n    disableDLNA(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.ADD_TEMP_DLNA_IP_MUTATION","title":"ADD_TEMP_DLNA_IP_MUTATION  <code>module-attribute</code>","text":"<pre><code>ADD_TEMP_DLNA_IP_MUTATION = \"\\nmutation AddTempDLNAIP($input: AddTempDLNAIPInput!) {\\n    addTempDLNAIP(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.REMOVE_TEMP_DLNA_IP_MUTATION","title":"REMOVE_TEMP_DLNA_IP_MUTATION  <code>module-attribute</code>","text":"<pre><code>REMOVE_TEMP_DLNA_IP_MUTATION = \"\\nmutation RemoveTempDLNAIP($input: RemoveTempDLNAIPInput!) {\\n    removeTempDLNAIP(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.DIRECTORY_QUERY","title":"DIRECTORY_QUERY  <code>module-attribute</code>","text":"<pre><code>DIRECTORY_QUERY = \"\\nquery Directory($path: String, $locale: String) {\\n    directory(path: $path, locale: $locale) {\\n        path\\n        parent\\n        directories\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SETUP_MUTATION","title":"SETUP_MUTATION  <code>module-attribute</code>","text":"<pre><code>SETUP_MUTATION = \"\\nmutation Setup($input: SetupInput!) {\\n    setup(input: $input)\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.DOWNLOAD_FFMPEG_MUTATION","title":"DOWNLOAD_FFMPEG_MUTATION  <code>module-attribute</code>","text":"<pre><code>DOWNLOAD_FFMPEG_MUTATION = (\n    \"\\nmutation DownloadFFMpeg {\\n    downloadFFMpeg\\n}\\n\"\n)\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.CONFIGURE_SCRAPING_MUTATION","title":"CONFIGURE_SCRAPING_MUTATION  <code>module-attribute</code>","text":"<pre><code>CONFIGURE_SCRAPING_MUTATION = \"\\nmutation ConfigureScraping($input: ConfigScrapingInput!) {\\n    configureScraping(input: $input) {\\n        scraperUserAgent\\n        scraperCDPPath\\n        scraperCertCheck\\n        excludeTagPatterns\\n        scraperPackageSources\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SQL_QUERY_MUTATION","title":"SQL_QUERY_MUTATION  <code>module-attribute</code>","text":"<pre><code>SQL_QUERY_MUTATION = \"\\nmutation QuerySQL($sql: String!, $args: [Any]) {\\n    querySQL(sql: $sql, args: $args) {\\n        columns\\n        rows\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/fragments/#stash_graphql_client.fragments.SQL_EXEC_MUTATION","title":"SQL_EXEC_MUTATION  <code>module-attribute</code>","text":"<pre><code>SQL_EXEC_MUTATION = \"\\nmutation ExecSQL($sql: String!, $args: [Any]) {\\n    execSQL(sql: $sql, args: $args) {\\n        rows_affected\\n        last_insert_id\\n    }\\n}\\n\"\n</code></pre>"},{"location":"api/schema/","title":"Schema","text":"<p>The <code>schema/</code> directory contains GraphQL schema files pulled directly from the upstream stashapp/stash repository for local reference.</p> <p>These files define the official Stash GraphQL API schema and are used as the source of truth for type generation.</p>"},{"location":"api/store/","title":"Entity Store","text":"<p>Identity map and caching for Stash entities.</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore","title":"StashEntityStore","text":"<pre><code>StashEntityStore(\n    client: StashClient,\n    default_ttl: timedelta | None = DEFAULT_TTL,\n)\n</code></pre> <p>In-memory identity map with read-through caching for Stash entities.</p> <p>Provides caching, selective field loading, and query capabilities for Stash GraphQL entities. All fetched entities are cached, and subsequent requests for the same entity return the cached version (if not expired).</p> <p>All entities can be treated as \"stubs\" that may have incomplete data. Use populate() to selectively load additional fields as needed, avoiding expensive queries for data you don't need.</p> Example <pre><code>async with StashContext(conn=...) as context:\n    client = context.client\n    store = context.store  # Use context's singleton store\n\n    # Get by ID (cache miss -&gt; fetch, then cached)\n    performer = await store.get(Performer, \"123\")\n\n    # Selectively load expensive fields only when needed\n    # Uses _received_fields to determine what's actually missing\n    performer = await store.populate(performer, fields=[\"scenes\", \"images\"])\n\n    # Search (always queries GraphQL, caches results)\n    scenes = await store.find(Scene, title__contains=\"interview\")\n\n    # Populate relationships on search results\n    for scene in scenes:\n        scene = await store.populate(scene, fields=[\"performers\", \"studio\", \"tags\"])\n\n    # Populate nested objects directly (identity map pattern)\n    scene.studio = await store.populate(scene.studio, fields=[\"urls\", \"details\"])\n\n    # Check what's missing before fetching\n    missing = store.missing_fields(scene.studio, \"urls\", \"details\")\n    if missing:\n        scene.studio = await store.populate(scene.studio, fields=list(missing))\n\n    # Force refresh from server (invalidates cache first)\n    scene = await store.populate(scene, fields=[\"studio\"], force_refetch=True)\n\n    # Large result sets: lazy pagination\n    async for scene in store.find_iter(Scene, path__contains=\"/media/\"):\n        process(scene)\n        if done:\n            break  # Won't fetch remaining batches\n\n    # Query cached objects only (no network)\n    favorites = store.filter(Performer, lambda p: p.favorite)\n</code></pre> <p>Initialize entity store.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>StashClient</code> <p>StashClient instance for GraphQL queries</p> required <code>default_ttl</code> <code>timedelta | None</code> <p>Default TTL for cached entities. Default is 30 minutes.          Pass None explicitly to disable expiration.</p> <code>DEFAULT_TTL</code>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore-attributes","title":"Attributes","text":""},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.DEFAULT_QUERY_BATCH","title":"DEFAULT_QUERY_BATCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_QUERY_BATCH = 40\n</code></pre>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.DEFAULT_TTL","title":"DEFAULT_TTL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_TTL = timedelta(minutes=30)\n</code></pre>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.FIND_LIMIT","title":"FIND_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIND_LIMIT = 1000\n</code></pre>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.cache_size","title":"cache_size  <code>property</code>","text":"<pre><code>cache_size: int\n</code></pre> <p>Get number of entities in cache (deprecated, use cache_stats) (thread-safe).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of cached entities</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore-functions","title":"Functions","text":""},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    entity_type: type[T],\n    entity_id: str,\n    fields: list[str] | None = None,\n) -&gt; T | None\n</code></pre> <p>Get entity by ID. Checks cache first, fetches if missing/expired (thread-safe).</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type (e.g., Performer, Scene)</p> required <code>entity_id</code> <code>str</code> <p>Entity ID</p> required <code>fields</code> <code>list[str] | None</code> <p>Optional list of additional fields to fetch beyond base fragment.    If provided, bypasses cache and fetches directly with specified fields.</p> <code>None</code> <p>Returns:</p> Type Description <code>T | None</code> <p>Entity if found, None otherwise</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.get_many","title":"get_many  <code>async</code>","text":"<pre><code>get_many(entity_type: type[T], ids: list[str]) -&gt; list[T]\n</code></pre> <p>Batch get entities. Returns cached + fetches missing in single query (thread-safe).</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>ids</code> <code>list[str]</code> <p>List of entity IDs</p> required <p>Returns:</p> Type Description <code>list[T]</code> <p>List of found entities (order not guaranteed)</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.find","title":"find  <code>async</code>","text":"<pre><code>find(entity_type: type[T], **filters: Any) -&gt; list[T]\n</code></pre> <p>Search using Stash filters. Results cached. Max 1000 results.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>**filters</code> <code>Any</code> <p>Search filters (Django-style kwargs or raw dict)</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[T]</code> <p>List of matching entities</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If result count exceeds FIND_LIMIT. Use find_iter() instead.</p> Filter syntax"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.find--django-style-kwargs","title":"Django-style kwargs","text":"<p>find(Scene, title=\"exact\")              # EQUALS find(Scene, title__contains=\"partial\")  # INCLUDES find(Scene, title__regex=r\"S\\d+\")      # MATCHES_REGEX find(Scene, rating100__gte=80)          # GREATER_THAN find(Scene, rating100__between=(60,90)) # BETWEEN find(Scene, studio__null=True)          # IS_NULL</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.find--raw-dict-for-complex-cases","title":"Raw dict for complex cases","text":"<p>find(Scene, title={\"value\": \"x\", \"modifier\": \"NOT_EQUALS\"})</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.find--nested-filters","title":"Nested filters","text":"<p>find(Scene, performers_filter={\"name\": {\"value\": \"Jane\", \"modifier\": \"EQUALS\"}})</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.find_one","title":"find_one  <code>async</code>","text":"<pre><code>find_one(\n    entity_type: type[T], **filters: Any\n) -&gt; T | None\n</code></pre> <p>Search returning first match. Result cached.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>**filters</code> <code>Any</code> <p>Search filters (same syntax as find())</p> <code>{}</code> <p>Returns:</p> Type Description <code>T | None</code> <p>First matching entity, or None if no matches</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.find_iter","title":"find_iter  <code>async</code>","text":"<pre><code>find_iter(\n    entity_type: type[T],\n    query_batch: int = DEFAULT_QUERY_BATCH,\n    **filters: Any,\n) -&gt; AsyncIterator[T]\n</code></pre> <p>Lazy search yielding individual items. Batches queries internally.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>Type to search for</p> required <code>query_batch</code> <code>int</code> <p>Records to fetch per GraphQL query (default: 40)</p> <code>DEFAULT_QUERY_BATCH</code> <code>**filters</code> <code>Any</code> <p>Search filters (same syntax as find())</p> <code>{}</code> <p>Yields:</p> Type Description <code>AsyncIterator[T]</code> <p>Individual entities as they are fetched</p> Example <p>async for scene in store.find_iter(Scene, path__contains=\"/media/\"):     process(scene)     if done:         break  # Won't fetch remaining batches</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter","title":"filter","text":"<pre><code>filter(\n    entity_type: type[T], predicate: Callable[[T], bool]\n) -&gt; list[T]\n</code></pre> <p>Filter cached objects with Python lambda. No network call (thread-safe).</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function that returns True for matching entities</p> required <p>Returns:</p> Type Description <code>list[T]</code> <p>List of matching cached entities</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.all_cached","title":"all_cached","text":"<pre><code>all_cached(entity_type: type[T]) -&gt; list[T]\n</code></pre> <p>Get all cached objects of a type.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <p>Returns:</p> Type Description <code>list[T]</code> <p>List of all cached entities of the specified type</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_strict","title":"filter_strict","text":"<pre><code>filter_strict(\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n) -&gt; list[T]\n</code></pre> <p>Filter cached objects, raising error if required fields are missing.</p> <p>This is a fail-fast version of filter() that ensures all cached objects have the required fields populated before applying the predicate. If any cached object is missing required fields, raises ValueError immediately.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>required_fields</code> <code>set[str] | list[str]</code> <p>Fields that must be populated on all cached objects</p> required <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function that returns True for matching entities</p> required <p>Returns:</p> Type Description <code>list[T]</code> <p>List of matching cached entities (all guaranteed to have required fields)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any cached object is missing required fields</p> Example"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_strict--this-will-raise-if-any-performer-has-rating100unset","title":"This will raise if any performer has rating100=UNSET","text":"<p>high_rated = store.filter_strict(     Performer,     required_fields=['rating100', 'favorite'],     predicate=lambda p: p.rating100 &gt;= 80 and p.favorite )</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_and_populate","title":"filter_and_populate  <code>async</code>","text":"<pre><code>filter_and_populate(\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n    batch_size: int = 50,\n) -&gt; list[T]\n</code></pre> <p>Filter cached objects, auto-populating missing fields as needed.</p> <p>This is a smart hybrid between find() and filter(): - Gets all cached objects of the type - Identifies which ones have UNSET values for required_fields - Fetches only the missing fields for incomplete objects (in batches) - Applies the predicate to all objects (now with complete data)</p> <p>This is much faster than find() when most data is already cached, since it only fetches the specific missing fields rather than re-fetching entire entities.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>required_fields</code> <code>set[str] | list[str]</code> <p>Fields needed by the predicate</p> required <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function that returns True for matching entities</p> required <code>batch_size</code> <code>int</code> <p>Number of entities to populate concurrently (default: 50)</p> <code>50</code> <p>Returns:</p> Type Description <code>list[T]</code> <p>List of matching entities (all with required fields populated)</p> Example"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_and_populate--cache-has-1000-performers-but-only-500-have-rating100-loaded","title":"Cache has 1000 performers, but only 500 have rating100 loaded","text":"<p>high_rated = await store.filter_and_populate(     Performer,     required_fields=['rating100', 'favorite'],     predicate=lambda p: p.rating100 &gt;= 80 and p.favorite )</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_and_populate--fetches-rating100favorite-for-the-500-that-dont-have-it","title":"\u2193 Fetches rating100+favorite for the 500 that don't have it","text":""},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_and_populate--then-filters-all-1000-with-complete-data","title":"\u2193 Then filters all 1000 with complete data","text":""},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_and_populate--network-calls-only-for-missing-data-much-faster-than-find","title":"\u2193 Network calls: Only for missing data (much faster than find())","text":""},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.filter_and_populate_with_stats","title":"filter_and_populate_with_stats  <code>async</code>","text":"<pre><code>filter_and_populate_with_stats(\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n    batch_size: int = 50,\n) -&gt; tuple[list[T], dict[str, Any]]\n</code></pre> <p>Filter and populate with debug statistics.</p> <p>Same as filter_and_populate() but returns detailed statistics about what was fetched and filtered. Useful for debugging and optimization.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>required_fields</code> <code>set[str] | list[str]</code> <p>Fields needed by the predicate</p> required <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function that returns True for matching entities</p> required <code>batch_size</code> <code>int</code> <p>Number of entities to populate concurrently</p> <code>50</code> <p>Returns:</p> Type Description <code>list[T]</code> <p>Tuple of (matching_entities, stats_dict) where stats contains:</p> <code>dict[str, Any]</code> <ul> <li>total_cached: Total objects in cache</li> </ul> <code>tuple[list[T], dict[str, Any]]</code> <ul> <li>needed_population: How many needed fields fetched</li> </ul> <code>tuple[list[T], dict[str, Any]]</code> <ul> <li>populated_fields: Which fields were fetched</li> </ul> <code>tuple[list[T], dict[str, Any]]</code> <ul> <li>matches: How many matched the predicate</li> </ul> <code>tuple[list[T], dict[str, Any]]</code> <ul> <li>cache_hit_rate: Percentage with complete data</li> </ul> Example <p>results, stats = await store.filter_and_populate_with_stats(     Performer,     required_fields=['rating100'],     predicate=lambda p: p.rating100 &gt;= 80 ) print(f\"Populated {stats['needed_population']} of {stats['total_cached']}\") print(f\"Cache hit rate: {stats['cache_hit_rate']:.1%}\") print(f\"Found {stats['matches']} matches\")</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populated_filter_iter","title":"populated_filter_iter  <code>async</code>","text":"<pre><code>populated_filter_iter(\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n    populate_batch: int = 50,\n    yield_batch: int = 10,\n) -&gt; AsyncIterator[T]\n</code></pre> <p>Lazy filter with auto-population, yielding results incrementally.</p> <p>Like filter_and_populate() but yields results as they become available instead of waiting for all entities to be processed. Useful for large datasets where you want to start processing matches immediately.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>required_fields</code> <code>set[str] | list[str]</code> <p>Fields needed by the predicate</p> required <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function that returns True for matching entities</p> required <code>populate_batch</code> <code>int</code> <p>How many entities to populate concurrently</p> <code>50</code> <code>yield_batch</code> <code>int</code> <p>Process this many entities before yielding matches</p> <code>10</code> <p>Yields:</p> Type Description <code>AsyncIterator[T]</code> <p>Individual matching entities (with required fields populated)</p> Example"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populated_filter_iter--process-large-dataset-incrementally","title":"Process large dataset incrementally","text":"<p>async for performer in store.populated_filter_iter(     Performer,     required_fields=['rating100', 'scenes'],     predicate=lambda p: p.rating100 &gt;= 90 and len(p.scenes) &gt; 100 ):     # Start processing immediately as matches are found     await expensive_operation(performer)     if should_stop:         break  # Can stop early without processing all</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populate","title":"populate  <code>async</code>","text":"<pre><code>populate(\n    obj: T,\n    fields: list[str] | set[str] | None = None,\n    force_refetch: bool = False,\n) -&gt; T\n</code></pre> <p>Populate specific fields on an entity using field-aware fetching.</p> <p>This method uses <code>_received_fields</code> tracking to determine which fields are genuinely missing and need to be fetched. All entities are treated as potentially incomplete.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>T</code> <p>Entity to populate. Can be any StashObject, including nested objects  like scene.studio or scene.performers[0].</p> required <code>fields</code> <code>list[str] | set[str] | None</code> <p>Fields to populate. If None and force_refetch=False, uses heuristics    to determine if object needs more data.</p> <code>None</code> <code>force_refetch</code> <code>bool</code> <p>If True, invalidates cache and re-fetches the specified fields           from the server, regardless of whether they're in _received_fields.</p> <code>False</code> <p>Returns:</p> Type Description <code>T</code> <p>The populated entity (may be a different instance if refetched from cache).</p> <p>Examples:</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populate--populate-specific-fields-on-a-scene","title":"Populate specific fields on a scene","text":"<p>scene = await store.populate(scene, fields=[\"studio\", \"performers\"])</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populate--populate-nested-object-directly-identity-map-pattern","title":"Populate nested object directly (identity map pattern)","text":"<p>scene.studio = await store.populate(scene.studio, fields=[\"urls\", \"details\"])</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populate--force-refresh-from-server-invalidates-cache-first","title":"Force refresh from server (invalidates cache first)","text":"<p>scene = await store.populate(scene, fields=[\"studio\"], force_refetch=True)</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populate--populate-performer-from-a-list","title":"Populate performer from a list","text":"<p>performer = await store.populate(     scene.performers[0], fields=[\"scenes\", \"images\"] )</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.populate--check-whats-missing-before-populating","title":"Check what's missing before populating","text":"<p>missing = store.missing_fields(scene.studio, \"urls\", \"details\", \"aliases\") if missing:     scene.studio = await store.populate(scene.studio, fields=list(missing))</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.has_fields","title":"has_fields","text":"<pre><code>has_fields(obj: StashObject, *fields: str) -&gt; bool\n</code></pre> <p>Check if an object has specific fields populated.</p> <p>Uses <code>_received_fields</code> tracking when available.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>StashObject</code> <p>Entity to check</p> required <code>*fields</code> <code>str</code> <p>Field names to check for</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if ALL specified fields are in _received_fields</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.missing_fields","title":"missing_fields","text":"<pre><code>missing_fields(obj: StashObject, *fields: str) -&gt; set[str]\n</code></pre> <p>Get which of the specified fields are missing from an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>StashObject</code> <p>Entity to check</p> required <code>*fields</code> <code>str</code> <p>Field names to check</p> <code>()</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of field names that are NOT in _received_fields</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.invalidate","title":"invalidate","text":"<pre><code>invalidate(entity_type: type[T], entity_id: str) -&gt; None\n</code></pre> <p>Remove specific object from cache (thread-safe).</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>entity_id</code> <code>str</code> <p>Entity ID to invalidate</p> required"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.invalidate_type","title":"invalidate_type","text":"<pre><code>invalidate_type(entity_type: type[T]) -&gt; None\n</code></pre> <p>Remove all objects of a type from cache (thread-safe).</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type to clear</p> required"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.invalidate_all","title":"invalidate_all","text":"<pre><code>invalidate_all() -&gt; None\n</code></pre> <p>Clear entire cache (thread-safe).</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.set_ttl","title":"set_ttl","text":"<pre><code>set_ttl(\n    entity_type: type[T], ttl: timedelta | None\n) -&gt; None\n</code></pre> <p>Set TTL for a type. None = use default (or never expire if no default).</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>ttl</code> <code>timedelta | None</code> <p>TTL for this type, or None to use default</p> required"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.add","title":"add","text":"<pre><code>add(obj: StashObject) -&gt; None\n</code></pre> <p>Add object to cache (for new objects with temp UUIDs).</p> <p>This is typically used with objects created via ClassName.new() that have temporary UUID IDs. After calling obj.save() or store.save(), the cache entry will be updated with the real ID from Stash.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>StashObject</code> <p>Object to cache (usually created with .new())</p> required Example <pre><code># Create new tag with temp UUID\ntag = Tag.new(name=\"Action\")\n\n# Cache it\nstore.add(tag)\n\n# Save to Stash (updates ID and cache)\nawait store.save(tag)\n# OR: await tag.save(client) + manual cache update\n</code></pre>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.save","title":"save  <code>async</code>","text":"<pre><code>save(obj: StashObject, _cascade_depth: int = 0) -&gt; None\n</code></pre> <p>Save object to Stash and update cache.</p> <p>Handles both new objects (create) and existing objects (update). For new objects, updates cache key from temp UUID to real Stash ID.</p> <p>Automatically cascades saves for unsaved related objects (with warning). Preferred pattern: explicitly save related objects before parent.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>StashObject</code> <p>Object to save</p> required <code>_cascade_depth</code> <code>int</code> <p>Internal tracking for cascade recursion depth</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save fails or object has unsaved UUIDs after cascade</p> Example <pre><code># Create and save new tag\ntag = Tag.new(name=\"Action\")\nstore.add(tag)  # Cache with temp UUID\nawait store.save(tag)  # Save to Stash, update cache with real ID\n\n# Modify existing tag\ntag.description = \"Action movies\"\nawait store.save(tag)  # Update in Stash\n\n# With related objects (auto-cascade with warning)\nscene.performers.append(new_performer)  # new_performer has UUID\nawait store.save(scene)  # Warns, cascades save(new_performer), then saves scene\n\n# Preferred pattern: explicit saves\nawait store.save(new_performer)  # Gets real ID\nscene.performers.append(new_performer)  # Has real ID\nawait store.save(scene)  # No cascade needed\n</code></pre>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.get_or_create","title":"get_or_create  <code>async</code>","text":"<pre><code>get_or_create(\n    entity_type: type[T],\n    create_if_missing: bool = True,\n    **search_params: Any,\n) -&gt; T\n</code></pre> <p>Get entity by search criteria, optionally create if not found.</p> <p>Searches for an entity matching the provided criteria. If found, returns the existing entity (from cache or fetched). If not found and create_if_missing is True, creates a new entity with the search params as initial data.</p> <p>Note: New entities are created with UUID IDs and are NOT automatically saved. Call store.save() or entity.save() to persist to Stash.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>create_if_missing</code> <code>bool</code> <p>If True, creates new entity if not found. Default: True.</p> <code>True</code> <code>**search_params</code> <code>Any</code> <p>Search criteria (also used as creation data if not found)</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Existing or newly created entity</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If not found and create_if_missing=False</p> Example <pre><code># Get existing or create new performer\nperformer = await store.get_or_create(Performer, name=\"Alice\")\nif performer._is_new:\n    # New performer - save it\n    await store.save(performer)\n\n# Link to scene\nscene.performers.append(performer)\nawait store.save(scene)\n\n# Get existing, error if not found\ntag = await store.get_or_create(Tag, create_if_missing=False, name=\"Action\")\n</code></pre>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.is_cached","title":"is_cached","text":"<pre><code>is_cached(entity_type: type[T], entity_id: str) -&gt; bool\n</code></pre> <p>Check if object is in cache and not expired (thread-safe).</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>type[T]</code> <p>The Stash entity type</p> required <code>entity_id</code> <code>str</code> <p>Entity ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if cached and not expired</p>"},{"location":"api/store/#stash_graphql_client.store.StashEntityStore.cache_stats","title":"cache_stats","text":"<pre><code>cache_stats() -&gt; CacheStats\n</code></pre> <p>Get cache statistics (thread-safe).</p> <p>Returns:</p> Type Description <code>CacheStats</code> <p>CacheStats with total entries, by-type counts, and expired count</p>"},{"location":"api/types/","title":"Types","text":"<p>Type definitions and utilities for Stash entities.</p>"},{"location":"api/types/#base-types","title":"Base Types","text":""},{"location":"api/types/#stash_graphql_client.types.base.StashObject","title":"StashObject","text":"<pre><code>StashObject(**data: Any)\n</code></pre> <p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Base interface for our Stash model implementations.</p> <p>While this is not a schema interface, it represents a common pattern in the schema where many types have id, created_at, and updated_at fields. We use this interface to provide common functionality for these types.</p> <p>Common fields (matching schema pattern): - id: Unique identifier (ID!) Note: created_at and updated_at are handled by Stash internally</p> <p>Common functionality provided: - find_by_id: Find object by ID - save: Save object to Stash - to_input: Convert to GraphQL input type - is_dirty: Check if object has unsaved changes - mark_clean: Mark object as having no unsaved changes - mark_dirty: Mark object as having unsaved changes</p> <p>Identity Map Integration: - Uses mode='wrap' validator to check cache before construction - Returns cached instance if entity already exists in store - Automatically caches new instances after construction</p> <p>Initialize StashObject with UUID4 auto-generation for new objects.</p> <p>If no 'id' is provided, automatically generates a UUID4 hex string (32 chars) and sets the _is_new flag to True. This temporary ID is replaced with the server-assigned ID after save operations.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>Field values for the object</p> <code>{}</code>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.base.StashObject.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    arbitrary_types_allowed=True,\n    extra=\"allow\",\n    validate_assignment=True,\n    populate_by_name=True,\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = ''\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: Time | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.updated_at","title":"updated_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated_at: Time | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.base.StashObject.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(**data: Any) -&gt; T\n</code></pre> <p>Create a new object that hasn't been saved to the server yet.</p> <p>This is a convenience method that creates a new instance without providing an 'id', which triggers UUID4 auto-generation and sets _is_new=True.</p> <p>This is equivalent to calling the constructor without an 'id' field, but makes the intent more explicit in the code.</p> <p>Parameters:</p> Name Type Description Default <code>**data</code> <code>Any</code> <p>Field values for the new object (excluding 'id')</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>New instance with auto-generated UUID4 and _is_new=True</p> Example <p>tag = Tag.new(name=\"New Tag\", description=\"A new tag\") tag.is_new()  # True tag.id  # '3fa85f6457174562b3fc2c963f66afa6' (UUID4 hex)</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.is_new","title":"is_new","text":"<pre><code>is_new() -&gt; bool\n</code></pre> <p>Check if this is a new object not yet saved to the server.</p> <p>Uses the _is_new flag which is set during initialization for new objects or when explicitly creating new objects with UUID4 identifiers.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this object has not been saved to the server</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.update_id","title":"update_id","text":"<pre><code>update_id(server_id: str) -&gt; None\n</code></pre> <p>Update the temporary UUID with the server-assigned ID.</p> <p>This should be called after a successful create operation to replace the auto-generated UUID with the permanent ID from the server. Also marks the object as no longer new.</p> <p>Parameters:</p> Name Type Description Default <code>server_id</code> <code>str</code> <p>The permanent ID assigned by the Stash server</p> required Example <p>scene = Scene(title=\"Example\")  # Auto-generates UUID scene.id  # \"a1b2c3d4e5f6...\" scene._is_new  # True await scene.save(client)  # Server assigns ID \"123\" scene.id  # \"123\" scene._is_new  # False</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(_context: Any) -&gt; None\n</code></pre> <p>Initialize object and store snapshot after Pydantic init.</p> <p>This is called by Pydantic after all fields are initialized, so it's the right place to capture the initial state for dirty tracking.</p> <p>Parameters:</p> Name Type Description Default <code>_context</code> <code>Any</code> <p>Pydantic context (unused but required by signature)</p> required"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.is_dirty","title":"is_dirty","text":"<pre><code>is_dirty() -&gt; bool\n</code></pre> <p>Check if tracked fields have unsaved changes.</p> <p>Compares current field values with snapshot using object identity for StashObjects to avoid circular reference errors during comparison.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any tracked field has changed since last snapshot</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.get_changed_fields","title":"get_changed_fields","text":"<pre><code>get_changed_fields() -&gt; dict[str, Any]\n</code></pre> <p>Get fields that have changed since last snapshot.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of field names to current values for changed fields</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.mark_clean","title":"mark_clean","text":"<pre><code>mark_clean() -&gt; None\n</code></pre> <p>Mark object as having no unsaved changes.</p> <p>Updates the snapshot to match the current state.</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.mark_dirty","title":"mark_dirty","text":"<pre><code>mark_dirty() -&gt; None\n</code></pre> <p>Mark object as having unsaved changes.</p> <p>Clears the snapshot to force all tracked fields to be considered dirty.</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.find_by_id","title":"find_by_id  <code>async</code> <code>classmethod</code>","text":"<pre><code>find_by_id(client: StashClient, id: str) -&gt; T | None\n</code></pre> <p>Find object by ID.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>StashClient</code> <p>StashClient instance</p> required <code>id</code> <code>str</code> <p>Object ID</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Object instance if found, None otherwise</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.save","title":"save  <code>async</code>","text":"<pre><code>save(client: StashClient) -&gt; None\n</code></pre> <p>Save object to Stash.</p> <p>For new objects (created without a server ID), this performs a create operation and updates the temporary UUID with the server-assigned ID.</p> <p>For existing objects, this performs an update operation, but only if there are dirty (changed) fields.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>StashClient</code> <p>StashClient instance</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If save fails</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashObject.to_input","title":"to_input  <code>async</code>","text":"<pre><code>to_input() -&gt; dict[str, Any]\n</code></pre> <p>Convert to GraphQL input type.</p> <p>For new objects (with temporary UUID), includes all fields. For existing objects, includes only dirty (changed) fields plus ID.</p> <p>Fields with value UNSET are excluded from the input to avoid overwriting server values that were never touched locally.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of input fields. For new objects, all non-UNSET fields</p> <code>dict[str, Any]</code> <p>are included. For existing objects, only changed fields plus ID.</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashInput","title":"StashInput","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all Stash GraphQL input types.</p> <p>Configures Pydantic to accept both Python snake_case field names and GraphQL camelCase aliases during construction, while serializing to camelCase for GraphQL using Field aliases and by_alias=True.</p> <p>This allows tests and Python code to use Pythonic naming conventions while ensuring GraphQL compatibility.</p> Example <pre><code>class MyInput(StashInput):\n    my_field: str = Field(alias=\"myField\")\n\n# Both work during construction:\nMyInput(my_field=\"value\")    # Python style\nMyInput(myField=\"value\")     # GraphQL style\n\n# Serialization always uses GraphQL style:\nobj.to_graphql()  # {\"myField\": \"value\"}\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.base.StashInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.base.StashInput.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    populate_by_name=True, ser_json_inf_nan=\"constants\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.base.StashInput-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.base.StashInput.to_graphql","title":"to_graphql","text":"<pre><code>to_graphql() -&gt; dict[str, Any]\n</code></pre> <p>Convert to GraphQL-compatible dictionary.</p> <p>Excludes UNSET sentinel values but keeps None (null) values. This allows: - UNSET fields to be omitted from the request (not sent to GraphQL) - None fields to explicitly clear/null values in GraphQL - Regular values to be sent normally</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary ready to send to GraphQL API with camelCase field names</p> Example <pre><code>from .unset import UNSET\n\ninput_obj = SceneUpdateInput(\n    title=\"New Title\",  # Send this value\n    rating=None,         # Send null (clear rating)\n    url=UNSET            # Don't send at all\n)\nresult = input_obj.to_graphql()\n# {'title': 'New Title', 'rating': None}  # url excluded\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.base.StashResult","title":"StashResult","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Base class for all Stash GraphQL result/output types.</p> <p>Result types wrap collections of entities returned from list queries like findScenes, findPerformers, etc.</p> <p>Example result types: - FindScenesResultType - FindPerformersResultType - StatsResultType</p>"},{"location":"api/types/#stash_graphql_client.types.base.StashResult-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.base.StashResult.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(populate_by_name=True)\n</code></pre>"},{"location":"api/types/#core-entity-types","title":"Core Entity Types","text":""},{"location":"api/types/#stash_graphql_client.types.scene.Scene","title":"Scene","text":"<pre><code>Scene(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Scene type from schema/types/scene.graphql.</p> <p>Note: Inherits from StashObject for implementation convenience, not because Scene implements any interface in the schema. StashObject provides common functionality like find_by_id, save, and to_input methods.</p>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.scene.Scene.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.studio","title":"studio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio: Studio | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.interactive","title":"interactive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interactive: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.interactive_speed","title":"interactive_speed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interactive_speed: int | None | UnsetType = Field(\n    default=UNSET, alias=\"interactiveSpeed\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.last_played_at","title":"last_played_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_played_at: Time | None | UnsetType = Field(\n    default=UNSET, alias=\"lastPlayedAt\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.resume_time","title":"resume_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resume_time: float | None | UnsetType = Field(\n    default=UNSET, alias=\"resumeTime\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.play_duration","title":"play_duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>play_duration: float | None | UnsetType = Field(\n    default=UNSET, alias=\"playDuration\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.play_count","title":"play_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>play_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0, alias=\"playCount\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.play_history","title":"play_history  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>play_history: list[Time] | None | UnsetType = Field(\n    default=UNSET, alias=\"playHistory\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.o_history","title":"o_history  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_history: list[Time] | None | UnsetType = Field(\n    default=UNSET, alias=\"oHistory\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: list[VideoFile] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.paths","title":"paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>paths: ScenePathsType | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.scene_markers","title":"scene_markers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_markers: list[SceneMarker] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.galleries","title":"galleries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>galleries: list[Gallery] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: list[SceneGroup] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: list[Performer] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashID] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.scene_streams","title":"scene_streams  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_streams: list[SceneStreamEndpoint] | UnsetType = (\n    Field(default=UNSET, alias=\"sceneStreams\")\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.captions","title":"captions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>captions: list[VideoCaption] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.scene.Scene.add_to_gallery","title":"add_to_gallery  <code>async</code>","text":"<pre><code>add_to_gallery(gallery: Gallery) -&gt; None\n</code></pre> <p>Add scene to gallery (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.remove_from_gallery","title":"remove_from_gallery  <code>async</code>","text":"<pre><code>remove_from_gallery(gallery: Gallery) -&gt; None\n</code></pre> <p>Remove scene from gallery (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.add_performer","title":"add_performer  <code>async</code>","text":"<pre><code>add_performer(performer: Performer) -&gt; None\n</code></pre> <p>Add performer to scene (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.remove_performer","title":"remove_performer  <code>async</code>","text":"<pre><code>remove_performer(performer: Performer) -&gt; None\n</code></pre> <p>Remove performer from scene (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.add_tag","title":"add_tag  <code>async</code>","text":"<pre><code>add_tag(tag: Tag) -&gt; None\n</code></pre> <p>Add tag to scene (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.remove_tag","title":"remove_tag  <code>async</code>","text":"<pre><code>remove_tag(tag: Tag) -&gt; None\n</code></pre> <p>Remove tag from scene (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.scene.Scene.set_studio","title":"set_studio","text":"<pre><code>set_studio(studio: Studio | None) -&gt; None\n</code></pre> <p>Set scene studio (call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer","title":"Performer","text":"<pre><code>Performer(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Performer type from schema/types/performer.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.performer.Performer.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.alias_list","title":"alias_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias_list: list[str] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashID] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.scenes","title":"scenes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scenes: list[Scene] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: list[Group] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.scene_count","title":"scene_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_count: int | UnsetType = Field(default=UNSET, ge=0)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.image_count","title":"image_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_count: int | UnsetType = Field(default=UNSET, ge=0)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.gallery_count","title":"gallery_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gallery_count: int | UnsetType = Field(default=UNSET, ge=0)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.group_count","title":"group_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_count: int | UnsetType = Field(default=UNSET, ge=0)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.performer_count","title":"performer_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_count: int | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.custom_fields","title":"custom_fields  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_fields: Map | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.disambiguation","title":"disambiguation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disambiguation: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.gender","title":"gender  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gender: GenderEnum | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.birthdate","title":"birthdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>birthdate: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.ethnicity","title":"ethnicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ethnicity: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.eye_color","title":"eye_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eye_color: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.height_cm","title":"height_cm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height_cm: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.measurements","title":"measurements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>measurements: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.fake_tits","title":"fake_tits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fake_tits: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.penis_length","title":"penis_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>penis_length: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.circumcised","title":"circumcised  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>circumcised: CircumisedEnum | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.career_length","title":"career_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>career_length: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.tattoos","title":"tattoos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tattoos: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.piercings","title":"piercings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>piercings: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.image_path","title":"image_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_path: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.death_date","title":"death_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>death_date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.hair_color","title":"hair_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hair_color: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.weight","title":"weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.performer.Performer.update_avatar","title":"update_avatar  <code>async</code>","text":"<pre><code>update_avatar(\n    client: StashClient, image_path: str | Path\n) -&gt; Performer\n</code></pre> <p>Update performer's avatar image.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>StashClient</code> <p>\"StashClient\" instance to use for update</p> required <code>image_path</code> <code>str | Path</code> <p>Path to image file to use as avatar</p> required <p>Returns:</p> Type Description <code>Performer</code> <p>Updated Performer object with the new image</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If image file doesn't exist</p> <code>ValueError</code> <p>If image file can't be read or update fails</p>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.add_tag","title":"add_tag  <code>async</code>","text":"<pre><code>add_tag(tag: Tag) -&gt; None\n</code></pre> <p>Add tag to performer (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.remove_tag","title":"remove_tag  <code>async</code>","text":"<pre><code>remove_tag(tag: Tag) -&gt; None\n</code></pre> <p>Remove tag from performer (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.performer.Performer.find_by_name","title":"find_by_name  <code>async</code> <code>classmethod</code>","text":"<pre><code>find_by_name(client: StashClient, name: str) -&gt; T | None\n</code></pre> <p>Find performer by name.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>StashClient</code> <p>\"StashClient\" instance</p> required <code>name</code> <code>str</code> <p>Performer name to search for</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Performer instance if found, None otherwise</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery","title":"Gallery","text":"<pre><code>Gallery(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Gallery type from schema/types/gallery.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.photographer","title":"photographer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>photographer: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.folder","title":"folder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>folder: Folder | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.studio","title":"studio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio: Studio | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.cover","title":"cover  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cover: Image | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: list[GalleryFile] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.chapters","title":"chapters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chapters: list[GalleryChapter] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.scenes","title":"scenes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scenes: list[Scene] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.image_count","title":"image_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_count: int | UnsetType = Field(default=UNSET, ge=0)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: list[Performer] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.paths","title":"paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>paths: GalleryPathsType | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.image","title":"image  <code>async</code>","text":"<pre><code>image(index: int) -&gt; Image\n</code></pre> <p>Get image at index from this gallery.</p> <p>Uses the GraphQL <code>gallery.image(index)</code> resolver to fetch a specific image by its position in the gallery.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the image in the gallery</p> required <p>Returns:</p> Type Description <code>Image</code> <p>Image object at the specified index</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gallery ID is not set or index is out of bounds</p> <code>RuntimeError</code> <p>If no StashEntityStore is configured</p> <p>Examples:</p> <pre><code>gallery = await client.find_gallery(\"123\")\n\n# Get first image\nfirst_image = await gallery.image(0)\n\n# Get last image (if you know the count)\nif is_set(gallery.image_count):\n    last_image = await gallery.image(gallery.image_count - 1)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.add_performer","title":"add_performer  <code>async</code>","text":"<pre><code>add_performer(performer: Performer) -&gt; None\n</code></pre> <p>Add performer (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.remove_performer","title":"remove_performer  <code>async</code>","text":"<pre><code>remove_performer(performer: Performer) -&gt; None\n</code></pre> <p>Remove performer (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.add_scene","title":"add_scene  <code>async</code>","text":"<pre><code>add_scene(scene: Scene) -&gt; None\n</code></pre> <p>Add scene (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.remove_scene","title":"remove_scene  <code>async</code>","text":"<pre><code>remove_scene(scene: Scene) -&gt; None\n</code></pre> <p>Remove scene (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.add_tag","title":"add_tag  <code>async</code>","text":"<pre><code>add_tag(tag: Tag) -&gt; None\n</code></pre> <p>Add tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.Gallery.remove_tag","title":"remove_tag  <code>async</code>","text":"<pre><code>remove_tag(tag: Tag) -&gt; None\n</code></pre> <p>Remove tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.image.Image","title":"Image","text":"<pre><code>Image(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Image type from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.image.Image-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.image.Image.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.photographer","title":"photographer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>photographer: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.studio","title":"studio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio: Studio | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.visual_files","title":"visual_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visual_files: list[VisualFile] | UnsetType = Field(\n    default=UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.paths","title":"paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>paths: ImagePathsType | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.galleries","title":"galleries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>galleries: list[Gallery] | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: list[Performer] | UnsetType = Field(\n    default=UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.Image-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.image.Image.add_performer","title":"add_performer  <code>async</code>","text":"<pre><code>add_performer(performer: Performer) -&gt; None\n</code></pre> <p>Add performer (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.image.Image.remove_performer","title":"remove_performer  <code>async</code>","text":"<pre><code>remove_performer(performer: Performer) -&gt; None\n</code></pre> <p>Remove performer (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.image.Image.add_to_gallery","title":"add_to_gallery  <code>async</code>","text":"<pre><code>add_to_gallery(gallery: Gallery) -&gt; None\n</code></pre> <p>Add gallery (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.image.Image.remove_from_gallery","title":"remove_from_gallery  <code>async</code>","text":"<pre><code>remove_from_gallery(gallery: Gallery) -&gt; None\n</code></pre> <p>Remove gallery (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.image.Image.add_tag","title":"add_tag  <code>async</code>","text":"<pre><code>add_tag(tag: Tag) -&gt; None\n</code></pre> <p>Add tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.image.Image.remove_tag","title":"remove_tag  <code>async</code>","text":"<pre><code>remove_tag(tag: Tag) -&gt; None\n</code></pre> <p>Remove tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.group.Group","title":"Group","text":"<pre><code>Group(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Group type from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.group.Group-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.group.Group.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.containing_groups","title":"containing_groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>containing_groups: list[GroupDescription] | UnsetType = (\n    Field(default=UNSET)\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.sub_groups","title":"sub_groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sub_groups: list[GroupDescription] | UnsetType = Field(\n    default=UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.scenes","title":"scenes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scenes: list[Scene] | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.duration","title":"duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.studio","title":"studio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio: Studio | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.synopsis","title":"synopsis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>synopsis: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.front_image_path","title":"front_image_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>front_image_path: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.back_image_path","title":"back_image_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>back_image_path: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.scene_count","title":"scene_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.performer_count","title":"performer_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.sub_group_count","title":"sub_group_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sub_group_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.Group-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.group.Group.add_sub_group","title":"add_sub_group  <code>async</code>","text":"<pre><code>add_sub_group(\n    sub_group: Group | GroupDescription,\n    description: str | None = None,\n) -&gt; None\n</code></pre> <p>Add sub-group (syncs inverse automatically, call save() to persist).</p> <p>Parameters:</p> Name Type Description Default <code>sub_group</code> <code>Group | GroupDescription</code> <p>Either a Group object or a GroupDescription object</p> required <code>description</code> <code>str | None</code> <p>Optional description for the relationship (only used if sub_group is a Group)</p> <code>None</code>"},{"location":"api/types/#stash_graphql_client.types.group.Group.remove_sub_group","title":"remove_sub_group  <code>async</code>","text":"<pre><code>remove_sub_group(\n    sub_group: Group | GroupDescription,\n) -&gt; None\n</code></pre> <p>Remove sub-group (syncs inverse automatically, call save() to persist).</p> <p>Parameters:</p> Name Type Description Default <code>sub_group</code> <code>Group | GroupDescription</code> <p>Either a Group object or GroupDescription object to remove</p> required"},{"location":"api/types/#stash_graphql_client.types.group.Group.add_containing_group","title":"add_containing_group  <code>async</code>","text":"<pre><code>add_containing_group(\n    containing_group: Group | GroupDescription,\n) -&gt; None\n</code></pre> <p>Add containing group (syncs inverse automatically, call save() to persist).</p> <p>Parameters:</p> Name Type Description Default <code>containing_group</code> <code>Group | GroupDescription</code> <p>Either a Group object (will be wrapped with None description)              or a GroupDescription object (used as-is)</p> required"},{"location":"api/types/#stash_graphql_client.types.group.Group.remove_containing_group","title":"remove_containing_group  <code>async</code>","text":"<pre><code>remove_containing_group(\n    containing_group: Group | GroupDescription,\n) -&gt; None\n</code></pre> <p>Remove containing group (syncs inverse automatically, call save() to persist).</p> <p>Parameters:</p> Name Type Description Default <code>containing_group</code> <code>Group | GroupDescription</code> <p>Either a Group object or GroupDescription object to remove</p> required"},{"location":"api/types/#stash_graphql_client.types.studio.Studio","title":"Studio","text":"<pre><code>Studio(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Studio type from schema/types/studio.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.studio.Studio.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.parent_studio","title":"parent_studio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_studio: Studio | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.child_studios","title":"child_studios  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child_studios: list[Studio] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.image_path","title":"image_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_path: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.scene_count","title":"scene_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.image_count","title":"image_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.gallery_count","title":"gallery_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gallery_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.performer_count","title":"performer_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.group_count","title":"group_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashID] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: list[Any] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.studio.Studio.handle_deprecated_url","title":"handle_deprecated_url  <code>classmethod</code>","text":"<pre><code>handle_deprecated_url(data: Any) -&gt; Any\n</code></pre> <p>Convert deprecated 'url' field to 'urls' list for backward compatibility.</p>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.set_parent_studio","title":"set_parent_studio  <code>async</code>","text":"<pre><code>set_parent_studio(parent: Studio | None) -&gt; None\n</code></pre> <p>Set parent studio (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.add_child_studio","title":"add_child_studio  <code>async</code>","text":"<pre><code>add_child_studio(child: Studio) -&gt; None\n</code></pre> <p>Add child studio (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.studio.Studio.remove_child_studio","title":"remove_child_studio  <code>async</code>","text":"<pre><code>remove_child_studio(child: Studio) -&gt; None\n</code></pre> <p>Remove child studio (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag","title":"Tag","text":"<pre><code>Tag(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Tag type from schema/types/tag.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.tag.Tag.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.sort_name","title":"sort_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashID] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.image_path","title":"image_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_path: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.scene_count","title":"scene_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.scene_marker_count","title":"scene_marker_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_marker_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.image_count","title":"image_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.gallery_count","title":"gallery_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gallery_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.performer_count","title":"performer_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.studio_count","title":"studio_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.group_count","title":"group_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.parents","title":"parents  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parents: list[Tag] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.children","title":"children  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>children: list[Tag] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.parent_count","title":"parent_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.child_count","title":"child_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child_count: int | None | UnsetType = Field(\n    default=UNSET, ge=0\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.tag.Tag.add_parent","title":"add_parent  <code>async</code>","text":"<pre><code>add_parent(parent_tag: Tag) -&gt; None\n</code></pre> <p>Add parent tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.remove_parent","title":"remove_parent  <code>async</code>","text":"<pre><code>remove_parent(parent_tag: Tag) -&gt; None\n</code></pre> <p>Remove parent tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.add_child","title":"add_child  <code>async</code>","text":"<pre><code>add_child(child_tag: Tag) -&gt; None\n</code></pre> <p>Add child tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.remove_child","title":"remove_child  <code>async</code>","text":"<pre><code>remove_child(child_tag: Tag) -&gt; None\n</code></pre> <p>Remove child tag (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.get_all_descendants","title":"get_all_descendants  <code>async</code>","text":"<pre><code>get_all_descendants() -&gt; list[Tag]\n</code></pre> <p>Get all descendant tags recursively (children, grandchildren, etc.).</p> <p>Returns:</p> Type Description <code>list[Tag]</code> <p>List of all descendant tags in the hierarchy</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.get_all_ancestors","title":"get_all_ancestors  <code>async</code>","text":"<pre><code>get_all_ancestors() -&gt; list[Tag]\n</code></pre> <p>Get all ancestor tags recursively (parents, grandparents, etc.).</p> <p>Returns:</p> Type Description <code>list[Tag]</code> <p>List of all ancestor tags in the hierarchy</p>"},{"location":"api/types/#stash_graphql_client.types.tag.Tag.find_by_name","title":"find_by_name  <code>async</code> <code>classmethod</code>","text":"<pre><code>find_by_name(client: StashClient, name: str) -&gt; T | None\n</code></pre> <p>Find tag by name (case-insensitive search).</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>StashClient</code> <p>\"StashClient\" instance</p> required <code>name</code> <code>str</code> <p>Tag name to search for</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Tag instance if found, None otherwise</p>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker","title":"SceneMarker","text":"<pre><code>SceneMarker(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Scene marker type from schema/types/scene-marker.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.scene","title":"scene  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene: Scene | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.seconds","title":"seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seconds: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.primary_tag","title":"primary_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>primary_tag: Tag | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.stream","title":"stream  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stream: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.preview","title":"preview  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>preview: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.screenshot","title":"screenshot  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>screenshot: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.end_seconds","title":"end_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_seconds: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.add_tag","title":"add_tag  <code>async</code>","text":"<pre><code>add_tag(tag: Tag) -&gt; None\n</code></pre> <p>Add tag to scene marker (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#stash_graphql_client.types.markers.SceneMarker.remove_tag","title":"remove_tag  <code>async</code>","text":"<pre><code>remove_tag(tag: Tag) -&gt; None\n</code></pre> <p>Remove tag from scene marker (syncs inverse automatically, call save() to persist).</p>"},{"location":"api/types/#unset-pattern","title":"UNSET Pattern","text":""},{"location":"api/types/#stash_graphql_client.types.unset.UnsetType","title":"UnsetType","text":"<p>Sentinel value representing an unset field.</p> <p>Used throughout the type system to indicate a field has never been set, as distinct from being explicitly set to None.</p> <p>This is a singleton - all instances are the same object.</p>"},{"location":"api/types/#stash_graphql_client.types.unset.UNSET","title":"UNSET  <code>module-attribute</code>","text":"<pre><code>UNSET = UnsetType()\n</code></pre>"},{"location":"api/types/#date-utilities","title":"Date Utilities","text":""},{"location":"api/types/#stash_graphql_client.types.date_utils.FuzzyDate","title":"FuzzyDate","text":"<pre><code>FuzzyDate(value: str)\n</code></pre> <p>Represents a date with variable precision.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; date = FuzzyDate(\"2024\")\n&gt;&gt;&gt; date.precision\n&lt;DatePrecision.YEAR: 'year'&gt;\n&gt;&gt;&gt; date.value\n'2024'\n</code></pre> <pre><code>&gt;&gt;&gt; date = FuzzyDate(\"2024-03\")\n&gt;&gt;&gt; date.precision\n&lt;DatePrecision.MONTH: 'month'&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; date = FuzzyDate(\"2024-03-15\")\n&gt;&gt;&gt; date.precision\n&lt;DatePrecision.DAY: 'day'&gt;\n</code></pre> <p>Initialize a fuzzy date from a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Date string in format YYYY, YYYY-MM, or YYYY-MM-DD</p> required <p>Raises:</p> Type Description <code>StashIntegrationError</code> <p>If the date format is invalid</p>"},{"location":"api/types/#stash_graphql_client.types.date_utils.FuzzyDate-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.date_utils.FuzzyDate.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value = value\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.FuzzyDate.precision","title":"precision  <code>instance-attribute</code>","text":"<pre><code>precision = parse_date_precision(value)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.FuzzyDate-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.date_utils.FuzzyDate.to_datetime","title":"to_datetime","text":"<pre><code>to_datetime() -&gt; datetime\n</code></pre> <p>Convert to a datetime object (using first day of period).</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>A datetime object representing the start of the period. - Year precision: January 1<sup>st</sup> of that year - Month precision: 1<sup>st</sup> day of that month - Day precision: That specific day (time stripped if present)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; FuzzyDate(\"2024\").to_datetime()\ndatetime.datetime(2024, 1, 1, 0, 0)\n&gt;&gt;&gt; FuzzyDate(\"2024-03\").to_datetime()\ndatetime.datetime(2024, 3, 1, 0, 0)\n&gt;&gt;&gt; FuzzyDate(\"2024-03-15\").to_datetime()\ndatetime.datetime(2024, 3, 15, 0, 0)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.DatePrecision","title":"DatePrecision","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Date precision levels supported by Stash. These correspond to the database precision values: - DAY = 0 (YYYY-MM-DD) - MONTH = 1 (YYYY-MM) - YEAR = 2 (YYYY) - OTHER = 3 (YYYY-MM-DD HH:MM:SS - more precise than day)</p>"},{"location":"api/types/#stash_graphql_client.types.date_utils.DatePrecision-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.date_utils.DatePrecision.DAY","title":"DAY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DAY = 'day'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.DatePrecision.MONTH","title":"MONTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MONTH = 'month'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.DatePrecision.YEAR","title":"YEAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>YEAR = 'year'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.DatePrecision.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'other'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.validate_fuzzy_date","title":"validate_fuzzy_date","text":"<pre><code>validate_fuzzy_date(date_str: str) -&gt; bool\n</code></pre> <p>Validate that a date string is in a supported fuzzy format.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string to validate</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the date is valid, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; validate_fuzzy_date(\"2024\")\nTrue\n&gt;&gt;&gt; validate_fuzzy_date(\"2024-03\")\nTrue\n&gt;&gt;&gt; validate_fuzzy_date(\"2024-03-15\")\nTrue\n&gt;&gt;&gt; validate_fuzzy_date(\"2024-3-15\")\nFalse\n&gt;&gt;&gt; validate_fuzzy_date(\"invalid\")\nFalse\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.date_utils.normalize_date","title":"normalize_date","text":"<pre><code>normalize_date(\n    date_str: str,\n    target_precision: Literal[\"day\", \"month\", \"year\"]\n    | None = None,\n) -&gt; str\n</code></pre> <p>Normalize a date string to a specific precision.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string to normalize</p> required <code>target_precision</code> <code>Literal['day', 'month', 'year'] | None</code> <p>Target precision level. If None, returns the date as-is after validation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Normalized date string</p> <p>Raises:</p> Type Description <code>StashIntegrationError</code> <p>If the date format is invalid or conversion fails</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; normalize_date(\"2024-03-15\", \"month\")\n'2024-03'\n&gt;&gt;&gt; normalize_date(\"2024-03-15\", \"year\")\n'2024'\n&gt;&gt;&gt; normalize_date(\"2024\", \"day\")\n'2024-01-01'\n</code></pre>"},{"location":"api/types/#enums","title":"Enums","text":"<p>Enum types from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums-classes","title":"Classes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum","title":"GenderEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Gender enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum.MALE","title":"MALE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MALE = 'MALE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum.FEMALE","title":"FEMALE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FEMALE = 'FEMALE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum.TRANSGENDER_MALE","title":"TRANSGENDER_MALE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRANSGENDER_MALE = 'TRANSGENDER_MALE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum.TRANSGENDER_FEMALE","title":"TRANSGENDER_FEMALE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRANSGENDER_FEMALE = 'TRANSGENDER_FEMALE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum.INTERSEX","title":"INTERSEX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERSEX = 'INTERSEX'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.GenderEnum.NON_BINARY","title":"NON_BINARY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NON_BINARY = 'NON_BINARY'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CircumisedEnum","title":"CircumisedEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Circumcision enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.CircumisedEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.CircumisedEnum.CUT","title":"CUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUT = 'CUT'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CircumisedEnum.UNCUT","title":"UNCUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNCUT = 'UNCUT'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.BulkUpdateIdMode","title":"BulkUpdateIdMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Bulk update mode enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.BulkUpdateIdMode-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.BulkUpdateIdMode.SET","title":"SET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SET = 'SET'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.BulkUpdateIdMode.ADD","title":"ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADD = 'ADD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.BulkUpdateIdMode.REMOVE","title":"REMOVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REMOVE = 'REMOVE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.SortDirectionEnum","title":"SortDirectionEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Sort direction enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.SortDirectionEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.SortDirectionEnum.ASC","title":"ASC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASC = 'ASC'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.SortDirectionEnum.DESC","title":"DESC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESC = 'DESC'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum","title":"ResolutionEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Resolution enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.VERY_LOW","title":"VERY_LOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERY_LOW = 'VERY_LOW'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.LOW","title":"LOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW = 'LOW'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.R360P","title":"R360P  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>R360P = 'R360P'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.STANDARD","title":"STANDARD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STANDARD = 'STANDARD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.WEB_HD","title":"WEB_HD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEB_HD = 'WEB_HD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.STANDARD_HD","title":"STANDARD_HD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STANDARD_HD = 'STANDARD_HD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.FULL_HD","title":"FULL_HD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULL_HD = 'FULL_HD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.QUAD_HD","title":"QUAD_HD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUAD_HD = 'QUAD_HD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.FOUR_K","title":"FOUR_K  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOUR_K = 'FOUR_K'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.FIVE_K","title":"FIVE_K  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIVE_K = 'FIVE_K'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.SIX_K","title":"SIX_K  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SIX_K = 'SIX_K'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.SEVEN_K","title":"SEVEN_K  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEVEN_K = 'SEVEN_K'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.EIGHT_K","title":"EIGHT_K  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EIGHT_K = 'EIGHT_K'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ResolutionEnum.HUGE","title":"HUGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HUGE = 'HUGE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.OrientationEnum","title":"OrientationEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Orientation enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.OrientationEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.OrientationEnum.LANDSCAPE","title":"LANDSCAPE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LANDSCAPE = 'LANDSCAPE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.OrientationEnum.PORTRAIT","title":"PORTRAIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PORTRAIT = 'PORTRAIT'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.OrientationEnum.SQUARE","title":"SQUARE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SQUARE = 'SQUARE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier","title":"CriterionModifier","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Criterion modifier enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.EQUALS","title":"EQUALS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EQUALS = 'EQUALS'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.NOT_EQUALS","title":"NOT_EQUALS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_EQUALS = 'NOT_EQUALS'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.GREATER_THAN","title":"GREATER_THAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GREATER_THAN = 'GREATER_THAN'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.LESS_THAN","title":"LESS_THAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LESS_THAN = 'LESS_THAN'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.IS_NULL","title":"IS_NULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IS_NULL = 'IS_NULL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.NOT_NULL","title":"NOT_NULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_NULL = 'NOT_NULL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.INCLUDES_ALL","title":"INCLUDES_ALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INCLUDES_ALL = 'INCLUDES_ALL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.INCLUDES","title":"INCLUDES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INCLUDES = 'INCLUDES'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.EXCLUDES","title":"EXCLUDES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXCLUDES = 'EXCLUDES'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.MATCHES_REGEX","title":"MATCHES_REGEX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MATCHES_REGEX = 'MATCHES_REGEX'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.NOT_MATCHES_REGEX","title":"NOT_MATCHES_REGEX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_MATCHES_REGEX = 'NOT_MATCHES_REGEX'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.BETWEEN","title":"BETWEEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BETWEEN = 'BETWEEN'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.CriterionModifier.NOT_BETWEEN","title":"NOT_BETWEEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_BETWEEN = 'NOT_BETWEEN'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode","title":"FilterMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Filter mode enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.SCENES","title":"SCENES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCENES = 'SCENES'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.PERFORMERS","title":"PERFORMERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PERFORMERS = 'PERFORMERS'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.STUDIOS","title":"STUDIOS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STUDIOS = 'STUDIOS'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.GALLERIES","title":"GALLERIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GALLERIES = 'GALLERIES'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.SCENE_MARKERS","title":"SCENE_MARKERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCENE_MARKERS = 'SCENE_MARKERS'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.MOVIES","title":"MOVIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOVIES = 'MOVIES'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.GROUPS","title":"GROUPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GROUPS = 'GROUPS'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.TAGS","title":"TAGS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAGS = 'TAGS'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.FilterMode.IMAGES","title":"IMAGES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IMAGES = 'IMAGES'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum","title":"StreamingResolutionEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Streaming resolution enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum.LOW","title":"LOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOW = 'LOW'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum.STANDARD","title":"STANDARD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STANDARD = 'STANDARD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum.STANDARD_HD","title":"STANDARD_HD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STANDARD_HD = 'STANDARD_HD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum.FULL_HD","title":"FULL_HD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULL_HD = 'FULL_HD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum.FOUR_K","title":"FOUR_K  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOUR_K = 'FOUR_K'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.StreamingResolutionEnum.ORIGINAL","title":"ORIGINAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORIGINAL = 'ORIGINAL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset","title":"PreviewPreset","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Preview preset enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset.ULTRAFAST","title":"ULTRAFAST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ULTRAFAST = 'ultrafast'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset.VERYFAST","title":"VERYFAST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERYFAST = 'veryfast'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset.FAST","title":"FAST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAST = 'fast'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset.MEDIUM","title":"MEDIUM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MEDIUM = 'medium'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset.SLOW","title":"SLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SLOW = 'slow'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset.SLOWER","title":"SLOWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SLOWER = 'slower'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PreviewPreset.VERYSLOW","title":"VERYSLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VERYSLOW = 'veryslow'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.HashAlgorithm","title":"HashAlgorithm","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Hash algorithm enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.HashAlgorithm-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.HashAlgorithm.MD5","title":"MD5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MD5 = 'MD5'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.HashAlgorithm.OSHASH","title":"OSHASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OSHASH = 'OSHASH'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.BlobsStorageType","title":"BlobsStorageType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Blobs storage type enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.BlobsStorageType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.BlobsStorageType.DATABASE","title":"DATABASE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATABASE = 'DATABASE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.BlobsStorageType.FILESYSTEM","title":"FILESYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILESYSTEM = 'FILESYSTEM'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxDisplayMode","title":"ImageLightboxDisplayMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Image lightbox display mode enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxDisplayMode-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxDisplayMode.ORIGINAL","title":"ORIGINAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORIGINAL = 'ORIGINAL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxDisplayMode.FIT_XY","title":"FIT_XY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIT_XY = 'FIT_XY'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxDisplayMode.FIT_X","title":"FIT_X  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIT_X = 'FIT_X'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxScrollMode","title":"ImageLightboxScrollMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Image lightbox scroll mode enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxScrollMode-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxScrollMode.ZOOM","title":"ZOOM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ZOOM = 'ZOOM'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImageLightboxScrollMode.PAN_Y","title":"PAN_Y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PAN_Y = 'PAN_Y'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.IdentifyFieldStrategy","title":"IdentifyFieldStrategy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Strategy for identifying fields from schema/types/metadata.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.IdentifyFieldStrategy-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.IdentifyFieldStrategy.IGNORE","title":"IGNORE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IGNORE = 'IGNORE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.IdentifyFieldStrategy.MERGE","title":"MERGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MERGE = 'MERGE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.IdentifyFieldStrategy.OVERWRITE","title":"OVERWRITE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OVERWRITE = 'OVERWRITE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportDuplicateEnum","title":"ImportDuplicateEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Import duplicate behavior from schema/types/metadata.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportDuplicateEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.ImportDuplicateEnum.IGNORE","title":"IGNORE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IGNORE = 'IGNORE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportDuplicateEnum.OVERWRITE","title":"OVERWRITE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OVERWRITE = 'OVERWRITE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportDuplicateEnum.FAIL","title":"FAIL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAIL = 'FAIL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportMissingRefEnum","title":"ImportMissingRefEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Import missing reference behavior from schema/types/metadata.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportMissingRefEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.ImportMissingRefEnum.IGNORE","title":"IGNORE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IGNORE = 'IGNORE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportMissingRefEnum.FAIL","title":"FAIL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAIL = 'FAIL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ImportMissingRefEnum.CREATE","title":"CREATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CREATE = 'CREATE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.SystemStatusEnum","title":"SystemStatusEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>System status enum from schema/types/metadata.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.SystemStatusEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.SystemStatusEnum.SETUP","title":"SETUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SETUP = 'SETUP'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.SystemStatusEnum.NEEDS_MIGRATION","title":"NEEDS_MIGRATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEEDS_MIGRATION = 'NEEDS_MIGRATION'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.SystemStatusEnum.OK","title":"OK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OK = 'OK'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus","title":"JobStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Job status enum from schema/types/job.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus.READY","title":"READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>READY = 'READY'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = 'RUNNING'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus.FINISHED","title":"FINISHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FINISHED = 'FINISHED'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus.STOPPING","title":"STOPPING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOPPING = 'STOPPING'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus.CANCELLED","title":"CANCELLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELLED = 'CANCELLED'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatus.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = 'FAILED'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatusUpdateType","title":"JobStatusUpdateType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Job status update type enum from schema/types/job.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatusUpdateType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.JobStatusUpdateType.ADD","title":"ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADD = 'ADD'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatusUpdateType.REMOVE","title":"REMOVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REMOVE = 'REMOVE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.JobStatusUpdateType.UPDATE","title":"UPDATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UPDATE = 'UPDATE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel","title":"LogLevel","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Log level enum from schema/types/logging.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel.TRACE","title":"TRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRACE = 'Trace'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel.DEBUG","title":"DEBUG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEBUG = 'Debug'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel.INFO","title":"INFO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFO = 'Info'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel.PROGRESS","title":"PROGRESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROGRESS = 'Progress'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel.WARNING","title":"WARNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WARNING = 'Warning'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.LogLevel.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'Error'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PluginSettingTypeEnum","title":"PluginSettingTypeEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Plugin setting type enum from schema/types/plugin.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.PluginSettingTypeEnum-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.PluginSettingTypeEnum.STRING","title":"STRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRING = 'STRING'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PluginSettingTypeEnum.NUMBER","title":"NUMBER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMBER = 'NUMBER'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PluginSettingTypeEnum.BOOLEAN","title":"BOOLEAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOOLEAN = 'BOOLEAN'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType","title":"ScrapeContentType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Scrape content type enum from schema/types/scraper.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType.GALLERY","title":"GALLERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GALLERY = 'GALLERY'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType.IMAGE","title":"IMAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IMAGE = 'IMAGE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType.MOVIE","title":"MOVIE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOVIE = 'MOVIE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType.GROUP","title":"GROUP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GROUP = 'GROUP'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType.PERFORMER","title":"PERFORMER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PERFORMER = 'PERFORMER'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeContentType.SCENE","title":"SCENE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCENE = 'SCENE'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeType","title":"ScrapeType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Scrape type enum from schema/types/scraper.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeType.NAME","title":"NAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAME = 'NAME'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeType.FRAGMENT","title":"FRAGMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FRAGMENT = 'FRAGMENT'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.ScrapeType.URL","title":"URL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>URL = 'URL'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PackageType","title":"PackageType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Package type enum from schema.</p>"},{"location":"api/types/#stash_graphql_client.types.enums.PackageType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.PackageType.SCRAPER","title":"SCRAPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCRAPER = 'Scraper'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.PackageType.PLUGIN","title":"PLUGIN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PLUGIN = 'Plugin'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.OnMultipleMatch","title":"OnMultipleMatch","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/types/#stash_graphql_client.types.enums.OnMultipleMatch-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.enums.OnMultipleMatch.RETURN_NONE","title":"RETURN_NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETURN_NONE = 0\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.OnMultipleMatch.RETURN_LIST","title":"RETURN_LIST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETURN_LIST = 1\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.enums.OnMultipleMatch.RETURN_FIRST","title":"RETURN_FIRST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RETURN_FIRST = 2\n</code></pre>"},{"location":"api/types/#file-types","title":"File Types","text":""},{"location":"api/types/#stash_graphql_client.types.files.VideoFile","title":"VideoFile","text":"<pre><code>VideoFile(**data: Any)\n</code></pre> <p>               Bases: <code>BaseFile</code></p> <p>Video file type from schema/types/file.graphql.</p> <p>Implements BaseFile and inherits StashObject through it.</p>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.height","title":"height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.duration","title":"duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration: float | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.video_codec","title":"video_codec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>video_codec: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.audio_codec","title":"audio_codec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>audio_codec: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.frame_rate","title":"frame_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frame_rate: float | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.VideoFile.bit_rate","title":"bit_rate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bit_rate: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.ImageFile","title":"ImageFile","text":"<pre><code>ImageFile(**data: Any)\n</code></pre> <p>               Bases: <code>BaseFile</code></p> <p>Image file type from schema/types/file.graphql.</p> <p>Implements BaseFile and inherits StashObject through it.</p>"},{"location":"api/types/#stash_graphql_client.types.files.ImageFile-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.files.ImageFile.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.ImageFile.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.ImageFile.height","title":"height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.GalleryFile","title":"GalleryFile","text":"<pre><code>GalleryFile(**data: Any)\n</code></pre> <p>               Bases: <code>BaseFile</code></p> <p>Gallery file type from schema/types/file.graphql.</p> <p>Implements BaseFile with no additional fields and inherits StashObject through it.</p>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile","title":"BaseFile","text":"<pre><code>BaseFile(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Base interface for all file types from schema/types/file.graphql.</p> <p>Note: Inherits from StashObject since it has id, created_at, and updated_at fields in the schema, matching the common pattern.</p>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.basename","title":"basename  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>basename: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.parent_folder","title":"parent_folder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_folder: Folder | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.mod_time","title":"mod_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mod_time: datetime | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.fingerprints","title":"fingerprints  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fingerprints: list[Fingerprint] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.zip_file","title":"zip_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zip_file: BasicFile | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.BaseFile-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.files.BaseFile.to_input","title":"to_input  <code>async</code>","text":"<pre><code>to_input() -&gt; dict[str, Any]\n</code></pre> <p>Convert to GraphQL input.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of input fields for move or set fingerprints operations.</p>"},{"location":"api/types/#stash_graphql_client.types.files.Folder","title":"Folder","text":"<pre><code>Folder(**data: Any)\n</code></pre> <p>               Bases: <code>StashObject</code></p> <p>Folder type from schema/types/file.graphql.</p> <p>Note: Inherits from StashObject since it has id, created_at, and updated_at fields in the schema, matching the common pattern.</p>"},{"location":"api/types/#stash_graphql_client.types.files.Folder-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.files.Folder.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.Folder.mod_time","title":"mod_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mod_time: datetime | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.Folder.parent_folder","title":"parent_folder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_folder: Folder | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.Folder.zip_file","title":"zip_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zip_file: BasicFile | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.files.Folder-functions","title":"Functions","text":""},{"location":"api/types/#stash_graphql_client.types.files.Folder.to_input","title":"to_input  <code>async</code>","text":"<pre><code>to_input() -&gt; dict[str, Any]\n</code></pre> <p>Convert to GraphQL input.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of input fields for move operation.</p>"},{"location":"api/types/#input-types","title":"Input Types","text":"<p>Input types for mutations (create, update, destroy operations).</p>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput","title":"SceneCreateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for creating scenes.</p>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.studio_id","title":"studio_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.gallery_ids","title":"gallery_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gallery_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.performer_ids","title":"performer_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: list[SceneGroupInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.cover_image","title":"cover_image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cover_image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneCreateInput.file_ids","title":"file_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput","title":"SceneUpdateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for updating scenes.</p>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.client_mutation_id","title":"client_mutation_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_mutation_id: str | None | UnsetType = Field(\n    default=UNSET, alias=\"clientMutationId\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.studio_id","title":"studio_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.gallery_ids","title":"gallery_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gallery_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.performer_ids","title":"performer_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: list[SceneGroupInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.cover_image","title":"cover_image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cover_image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.resume_time","title":"resume_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resume_time: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.play_duration","title":"play_duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>play_duration: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.SceneUpdateInput.primary_file_id","title":"primary_file_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>primary_file_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput","title":"PerformerCreateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for creating performers.</p>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.disambiguation","title":"disambiguation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disambiguation: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.gender","title":"gender  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gender: GenderEnum | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.birthdate","title":"birthdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>birthdate: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.ethnicity","title":"ethnicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ethnicity: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.eye_color","title":"eye_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eye_color: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.height_cm","title":"height_cm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height_cm: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.measurements","title":"measurements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>measurements: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.fake_tits","title":"fake_tits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fake_tits: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.penis_length","title":"penis_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>penis_length: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.circumcised","title":"circumcised  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>circumcised: CircumisedEnum | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.career_length","title":"career_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>career_length: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.tattoos","title":"tattoos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tattoos: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.piercings","title":"piercings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>piercings: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.alias_list","title":"alias_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias_list: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.death_date","title":"death_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>death_date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.hair_color","title":"hair_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hair_color: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.weight","title":"weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerCreateInput.custom_fields","title":"custom_fields  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_fields: dict[str, Any] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput","title":"PerformerUpdateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for updating performers.</p>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.disambiguation","title":"disambiguation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disambiguation: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.gender","title":"gender  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gender: GenderEnum | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.birthdate","title":"birthdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>birthdate: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.ethnicity","title":"ethnicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ethnicity: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.eye_color","title":"eye_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eye_color: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.height_cm","title":"height_cm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height_cm: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.measurements","title":"measurements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>measurements: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.fake_tits","title":"fake_tits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fake_tits: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.penis_length","title":"penis_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>penis_length: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.circumcised","title":"circumcised  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>circumcised: CircumisedEnum | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.career_length","title":"career_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>career_length: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.tattoos","title":"tattoos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tattoos: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.piercings","title":"piercings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>piercings: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.alias_list","title":"alias_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias_list: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.death_date","title":"death_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>death_date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.hair_color","title":"hair_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hair_color: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.weight","title":"weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.PerformerUpdateInput.custom_fields","title":"custom_fields  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_fields: CustomFieldsInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput","title":"GalleryCreateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for creating galleries.</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.photographer","title":"photographer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>photographer: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.scene_ids","title":"scene_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.studio_id","title":"studio_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryCreateInput.performer_ids","title":"performer_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput","title":"GalleryUpdateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for updating galleries.</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.client_mutation_id","title":"client_mutation_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_mutation_id: str | None | UnsetType = Field(\n    default=UNSET, alias=\"clientMutationId\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.photographer","title":"photographer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>photographer: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.scene_ids","title":"scene_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.studio_id","title":"studio_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.performer_ids","title":"performer_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.GalleryUpdateInput.primary_file_id","title":"primary_file_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>primary_file_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput","title":"GroupCreateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for creating groups from schema/types/group.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.duration","title":"duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.studio_id","title":"studio_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.synopsis","title":"synopsis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>synopsis: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.containing_groups","title":"containing_groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>containing_groups: (\n    list[GroupDescriptionInput] | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.sub_groups","title":"sub_groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sub_groups: (\n    list[GroupDescriptionInput] | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.front_image","title":"front_image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>front_image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupCreateInput.back_image","title":"back_image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>back_image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput","title":"GroupUpdateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for updating groups from schema/types/group.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.duration","title":"duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.studio_id","title":"studio_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.synopsis","title":"synopsis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>synopsis: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.containing_groups","title":"containing_groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>containing_groups: (\n    list[GroupDescriptionInput] | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.sub_groups","title":"sub_groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sub_groups: (\n    list[GroupDescriptionInput] | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.front_image","title":"front_image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>front_image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.group.GroupUpdateInput.back_image","title":"back_image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>back_image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput","title":"StudioCreateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for creating studios.</p>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioCreateInput.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput","title":"StudioUpdateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for updating studios.</p>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: int | None | UnsetType = Field(\n    default=UNSET, ge=0, le=100\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.tag_ids","title":"tag_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.studio.StudioUpdateInput.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput","title":"TagCreateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for creating tags.</p>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.sort_name","title":"sort_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.parent_ids","title":"parent_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagCreateInput.child_ids","title":"child_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput","title":"TagUpdateInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for updating tags.</p>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.sort_name","title":"sort_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.favorite","title":"favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.stash_ids","title":"stash_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_ids: list[StashIDInput] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.parent_ids","title":"parent_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.tag.TagUpdateInput.child_ids","title":"child_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child_ids: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#filter-types","title":"Filter Types","text":""},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType","title":"SceneFilterType","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for scene filter.</p>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.AND","title":"AND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AND: SceneFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.OR","title":"OR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OR: SceneFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.NOT","title":"NOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT: SceneFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.oshash","title":"oshash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>oshash: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.checksum","title":"checksum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checksum: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.phash_distance","title":"phash_distance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phash_distance: (\n    PhashDistanceCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.file_count","title":"file_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.duplicated","title":"duplicated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duplicated: (\n    PHashDuplicationCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resolution: ResolutionCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>orientation: (\n    OrientationCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.framerate","title":"framerate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>framerate: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.bitrate","title":"bitrate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bitrate: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.video_codec","title":"video_codec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>video_codec: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.audio_codec","title":"audio_codec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>audio_codec: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.duration","title":"duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.has_markers","title":"has_markers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>has_markers: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.is_missing","title":"is_missing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_missing: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.studios","title":"studios  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.galleries","title":"galleries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>galleries: MultiCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: HierarchicalMultiCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.tag_count","title":"tag_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.performer_tags","title":"performer_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_tags: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.performer_favorite","title":"performer_favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.performer_age","title":"performer_age  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_age: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: MultiCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.performer_count","title":"performer_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_count: IntCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.stash_id_endpoint","title":"stash_id_endpoint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_id_endpoint: (\n    StashIDCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.interactive","title":"interactive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interactive: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.interactive_speed","title":"interactive_speed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interactive_speed: IntCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.captions","title":"captions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>captions: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.resume_time","title":"resume_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resume_time: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.play_count","title":"play_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>play_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.play_duration","title":"play_duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>play_duration: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.last_played_at","title":"last_played_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_played_at: (\n    TimestampCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: DateCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.updated_at","title":"updated_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.galleries_filter","title":"galleries_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>galleries_filter: GalleryFilterType | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.performers_filter","title":"performers_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers_filter: (\n    PerformerFilterType | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.studios_filter","title":"studios_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios_filter: StudioFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.tags_filter","title":"tags_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags_filter: TagFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.groups_filter","title":"groups_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups_filter: GroupFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.markers_filter","title":"markers_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>markers_filter: SceneMarkerFilterType | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.SceneFilterType.files_filter","title":"files_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files_filter: FileFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType","title":"PerformerFilterType","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for performer filter.</p>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.AND","title":"AND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AND: PerformerFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.OR","title":"OR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OR: PerformerFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.NOT","title":"NOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT: PerformerFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.disambiguation","title":"disambiguation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disambiguation: StringCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.filter_favorites","title":"filter_favorites  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter_favorites: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.birth_year","title":"birth_year  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>birth_year: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.age","title":"age  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>age: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.ethnicity","title":"ethnicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ethnicity: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.eye_color","title":"eye_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eye_color: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.height_cm","title":"height_cm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height_cm: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.measurements","title":"measurements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>measurements: StringCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.fake_tits","title":"fake_tits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fake_tits: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.penis_length","title":"penis_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>penis_length: FloatCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.circumcised","title":"circumcised  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>circumcised: (\n    CircumcisionCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.career_length","title":"career_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>career_length: StringCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.tattoos","title":"tattoos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tattoos: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.piercings","title":"piercings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>piercings: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.gender","title":"gender  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gender: GenderCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.is_missing","title":"is_missing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_missing: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: HierarchicalMultiCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.tag_count","title":"tag_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.scene_count","title":"scene_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.image_count","title":"image_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.gallery_count","title":"gallery_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gallery_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.play_count","title":"play_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>play_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.stash_id_endpoint","title":"stash_id_endpoint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stash_id_endpoint: (\n    StashIDCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.hair_color","title":"hair_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hair_color: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.weight","title":"weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.death_year","title":"death_year  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>death_year: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.studios","title":"studios  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: MultiCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.ignore_auto_tag","title":"ignore_auto_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_auto_tag: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.birthdate","title":"birthdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>birthdate: DateCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.death_date","title":"death_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>death_date: DateCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.scenes_filter","title":"scenes_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scenes_filter: SceneFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.images_filter","title":"images_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>images_filter: ImageFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.galleries_filter","title":"galleries_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>galleries_filter: GalleryFilterType | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.tags_filter","title":"tags_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags_filter: TagFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.updated_at","title":"updated_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.PerformerFilterType.custom_fields","title":"custom_fields  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_fields: (\n    list[CustomFieldCriterionInput] | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType","title":"GalleryFilterType","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for gallery filter.</p>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.AND","title":"AND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AND: GalleryFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.OR","title":"OR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OR: GalleryFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.NOT","title":"NOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT: GalleryFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.checksum","title":"checksum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checksum: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.file_count","title":"file_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.is_missing","title":"is_missing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_missing: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.is_zip","title":"is_zip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_zip: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.average_resolution","title":"average_resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>average_resolution: (\n    ResolutionCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.has_chapters","title":"has_chapters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>has_chapters: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.scenes","title":"scenes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scenes: MultiCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.studios","title":"studios  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: HierarchicalMultiCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.tag_count","title":"tag_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.performer_tags","title":"performer_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_tags: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: MultiCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.performer_count","title":"performer_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_count: IntCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.performer_favorite","title":"performer_favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.performer_age","title":"performer_age  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_age: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.image_count","title":"image_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: DateCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.updated_at","title":"updated_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.photographer","title":"photographer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>photographer: StringCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.scenes_filter","title":"scenes_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scenes_filter: SceneFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.images_filter","title":"images_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>images_filter: ImageFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.performers_filter","title":"performers_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers_filter: (\n    PerformerFilterType | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.studios_filter","title":"studios_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios_filter: StudioFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.tags_filter","title":"tags_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags_filter: TagFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.files_filter","title":"files_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files_filter: FileFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.GalleryFilterType.folders_filter","title":"folders_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>folders_filter: FolderFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType","title":"ImageFilterType","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for image filter.</p>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.AND","title":"AND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AND: ImageFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.OR","title":"OR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OR: ImageFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.NOT","title":"NOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT: ImageFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.checksum","title":"checksum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checksum: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.file_count","title":"file_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.rating100","title":"rating100  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rating100: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: DateCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.organized","title":"organized  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>organized: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.o_counter","title":"o_counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o_counter: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resolution: ResolutionCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.orientation","title":"orientation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>orientation: (\n    OrientationCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.is_missing","title":"is_missing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_missing: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.studios","title":"studios  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: HierarchicalMultiCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.tag_count","title":"tag_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_count: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.performer_tags","title":"performer_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_tags: (\n    HierarchicalMultiCriterionInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: MultiCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.performer_count","title":"performer_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_count: IntCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.performer_favorite","title":"performer_favorite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_favorite: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.performer_age","title":"performer_age  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer_age: IntCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.galleries","title":"galleries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>galleries: MultiCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.updated_at","title":"updated_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated_at: TimestampCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: StringCriterionInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.photographer","title":"photographer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>photographer: StringCriterionInput | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.galleries_filter","title":"galleries_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>galleries_filter: GalleryFilterType | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.performers_filter","title":"performers_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers_filter: (\n    PerformerFilterType | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.studios_filter","title":"studios_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios_filter: StudioFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.tags_filter","title":"tags_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags_filter: TagFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.filters.ImageFilterType.files_filter","title":"files_filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files_filter: FileFilterType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#result-types","title":"Result Types","text":""},{"location":"api/types/#stash_graphql_client.types.scene.FindScenesResultType","title":"FindScenesResultType","text":"<p>               Bases: <code>StashResult</code></p> <p>Result type for finding scenes from schema/types/scene.graphql.</p> <p>Fields: count: Total number of scenes duration: Total duration in seconds filesize: Total file size in bytes scenes: List of scenes</p>"},{"location":"api/types/#stash_graphql_client.types.scene.FindScenesResultType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.scene.FindScenesResultType.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>count: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.FindScenesResultType.duration","title":"duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration: float | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.FindScenesResultType.filesize","title":"filesize  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filesize: float | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scene.FindScenesResultType.scenes","title":"scenes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scenes: list[Scene] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.FindPerformersResultType","title":"FindPerformersResultType","text":"<p>               Bases: <code>StashResult</code></p> <p>Result type for finding performers from schema/types/performer.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.performer.FindPerformersResultType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.performer.FindPerformersResultType.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>count: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.performer.FindPerformersResultType.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: list[Performer] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.FindGalleriesResultType","title":"FindGalleriesResultType","text":"<p>               Bases: <code>StashResult</code></p> <p>Result type for finding galleries.</p>"},{"location":"api/types/#stash_graphql_client.types.gallery.FindGalleriesResultType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.gallery.FindGalleriesResultType.count","title":"count  <code>instance-attribute</code>","text":"<pre><code>count: int\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.gallery.FindGalleriesResultType.galleries","title":"galleries  <code>instance-attribute</code>","text":"<pre><code>galleries: list[Gallery]\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.FindImagesResultType","title":"FindImagesResultType","text":"<p>               Bases: <code>StashResult</code></p> <p>Result type for finding images from schema/types/image.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.image.FindImagesResultType-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.image.FindImagesResultType.count","title":"count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>count: int | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.FindImagesResultType.megapixels","title":"megapixels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>megapixels: float | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.FindImagesResultType.filesize","title":"filesize  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filesize: float | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.image.FindImagesResultType.images","title":"images  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>images: list[Image] | UnsetType = Field(default=UNSET)\n</code></pre>"},{"location":"api/types/#job-types","title":"Job Types","text":""},{"location":"api/types/#stash_graphql_client.types.job.Job","title":"Job","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Job type from schema/types/job.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.job.Job-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.job.Job.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: JobStatus | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.sub_tasks","title":"sub_tasks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sub_tasks: list[str] | None | UnsetType = Field(\n    default=UNSET, alias=\"subTasks\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.progress","title":"progress  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>progress: float | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.start_time","title":"start_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_time: Time | None | UnsetType = Field(\n    default=UNSET, alias=\"startTime\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.end_time","title":"end_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_time: Time | None | UnsetType = Field(\n    default=UNSET, alias=\"endTime\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.add_time","title":"add_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>add_time: Time | None | UnsetType = Field(\n    default=UNSET, alias=\"addTime\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.Job.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.JobStatus","title":"JobStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Job status enum from schema/types/job.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.job.JobStatus-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.job.JobStatus.READY","title":"READY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>READY = 'READY'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.JobStatus.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = 'RUNNING'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.JobStatus.FINISHED","title":"FINISHED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FINISHED = 'FINISHED'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.JobStatus.STOPPING","title":"STOPPING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOPPING = 'STOPPING'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.JobStatus.CANCELLED","title":"CANCELLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELLED = 'CANCELLED'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.job.JobStatus.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = 'FAILED'\n</code></pre>"},{"location":"api/types/#configuration-types","title":"Configuration Types","text":""},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult","title":"ConfigResult","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Result type for all configuration.</p>"},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult.general","title":"general  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>general: ConfigGeneralResult | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult.interface","title":"interface  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interface: ConfigInterfaceResult | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult.dlna","title":"dlna  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dlna: ConfigDLNAResult | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult.scraping","title":"scraping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scraping: ConfigScrapingResult | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult.defaults","title":"defaults  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defaults: ConfigDefaultSettingsResult | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.ConfigResult.ui","title":"ui  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ui: dict[str, Any] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.StashConfig","title":"StashConfig","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Result type for stash configuration.</p>"},{"location":"api/types/#stash_graphql_client.types.config.StashConfig-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.config.StashConfig.path","title":"path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>path: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.StashConfig.exclude_video","title":"exclude_video  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_video: bool | UnsetType = Field(\n    default=UNSET, alias=\"excludeVideo\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.config.StashConfig.exclude_image","title":"exclude_image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_image: bool | UnsetType = Field(\n    default=UNSET, alias=\"excludeImage\"\n)\n</code></pre>"},{"location":"api/types/#metadata-types","title":"Metadata Types","text":""},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput","title":"ScanMetadataInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for metadata scanning from schema/types/metadata.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.paths","title":"paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>paths: list[str] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.rescan","title":"rescan  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rescan: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.scanGenerateCovers","title":"scanGenerateCovers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scanGenerateCovers: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.scanGeneratePreviews","title":"scanGeneratePreviews  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scanGeneratePreviews: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.scanGenerateImagePreviews","title":"scanGenerateImagePreviews  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scanGenerateImagePreviews: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.scanGenerateSprites","title":"scanGenerateSprites  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scanGenerateSprites: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.scanGeneratePhashes","title":"scanGeneratePhashes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scanGeneratePhashes: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.scanGenerateThumbnails","title":"scanGenerateThumbnails  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scanGenerateThumbnails: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.scanGenerateClipPreviews","title":"scanGenerateClipPreviews  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scanGenerateClipPreviews: bool | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.ScanMetadataInput.filter","title":"filter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>filter: ScanMetaDataFilterInput | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput","title":"GenerateMetadataInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for metadata generation from schema/types/metadata.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.covers","title":"covers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>covers: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.sprites","title":"sprites  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sprites: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.previews","title":"previews  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>previews: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.imagePreviews","title":"imagePreviews  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imagePreviews: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.previewOptions","title":"previewOptions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>previewOptions: (\n    GeneratePreviewOptionsInput | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.markers","title":"markers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>markers: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.markerImagePreviews","title":"markerImagePreviews  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>markerImagePreviews: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.markerScreenshots","title":"markerScreenshots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>markerScreenshots: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.transcodes","title":"transcodes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>transcodes: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.forceTranscodes","title":"forceTranscodes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forceTranscodes: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.phashes","title":"phashes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phashes: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.interactiveHeatmapsSpeeds","title":"interactiveHeatmapsSpeeds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interactiveHeatmapsSpeeds: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.imageThumbnails","title":"imageThumbnails  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imageThumbnails: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.clipPreviews","title":"clipPreviews  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clipPreviews: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.sceneIDs","title":"sceneIDs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sceneIDs: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.markerIDs","title":"markerIDs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>markerIDs: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.GenerateMetadataInput.overwrite","title":"overwrite  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>overwrite: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.AutoTagMetadataInput","title":"AutoTagMetadataInput","text":"<p>               Bases: <code>StashInput</code></p> <p>Input for auto-tagging metadata from schema/types/metadata.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.metadata.AutoTagMetadataInput-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.metadata.AutoTagMetadataInput.paths","title":"paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>paths: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.AutoTagMetadataInput.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.AutoTagMetadataInput.studios","title":"studios  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studios: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.metadata.AutoTagMetadataInput.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#plugin-types","title":"Plugin Types","text":""},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin","title":"Plugin","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Plugin type from schema/types/plugin.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.enabled","title":"enabled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enabled: bool | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.paths","title":"paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>paths: PluginPaths | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.tasks","title":"tasks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tasks: list[PluginTask] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.hooks","title":"hooks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hooks: list[PluginHook] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.settings","title":"settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>settings: list[PluginSetting] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.Plugin.requires","title":"requires  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.PluginTask","title":"PluginTask","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Plugin task type from schema/types/plugin.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.plugin.PluginTask-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.plugin.PluginTask.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.PluginTask.plugin","title":"plugin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plugin: Plugin | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.plugin.PluginTask.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#package-types","title":"Package Types","text":""},{"location":"api/types/#stash_graphql_client.types.package.Package","title":"Package","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Package type from schema/types/package.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.package.Package-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.package.Package.package_id","title":"package_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>package_id: str | UnsetType = Field(\n    default=UNSET, alias=\"package_id\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.package.Package.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.package.Package.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.package.Package.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: Timestamp | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.package.Package.requires","title":"requires  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires: list[Package] | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.package.Package.source_url","title":"source_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_url: str | UnsetType = Field(\n    default=UNSET, alias=\"sourceURL\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.package.Package.source_package","title":"source_package  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_package: Package | None | UnsetType = Field(\n    default=UNSET, alias=\"source_package\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.package.Package.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: Map | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#scraper-types","title":"Scraper Types","text":""},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper","title":"Scraper","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Scraper from schema/types/scraper.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper.performer","title":"performer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performer: ScraperSpec | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper.scene","title":"scene  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scene: ScraperSpec | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper.gallery","title":"gallery  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gallery: ScraperSpec | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: ScraperSpec | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.Scraper.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: ScraperSpec | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene","title":"ScrapedScene","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Scene data from scraper from schema/types/scraper.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.code","title":"code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>code: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.director","title":"director  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>director: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.date","title":"date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>date: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.image","title":"image  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>image: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: SceneFileType | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.studio","title":"studio  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>studio: ScrapedStudio | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[ScrapedTag] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.performers","title":"performers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performers: list[ScrapedPerformer] | None | UnsetType = (\n    UNSET\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.groups","title":"groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groups: list[ScrapedGroup] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.remote_site_id","title":"remote_site_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>remote_site_id: str | None | UnsetType = Field(\n    default=UNSET, alias=\"remoteSiteID\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.duration","title":"duration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>duration: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedScene.fingerprints","title":"fingerprints  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fingerprints: (\n    list[StashBoxFingerprint] | None | UnsetType\n) = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer","title":"ScrapedPerformer","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>A performer from a scraping operation from schema/types/scraped-performer.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.stored_id","title":"stored_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stored_id: str | None | UnsetType = Field(\n    default=UNSET, alias=\"storedID\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.disambiguation","title":"disambiguation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>disambiguation: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.gender","title":"gender  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gender: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.birthdate","title":"birthdate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>birthdate: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.ethnicity","title":"ethnicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ethnicity: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.eye_color","title":"eye_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eye_color: str | None | UnsetType = Field(\n    default=UNSET, alias=\"eyeColor\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.height","title":"height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>height: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.measurements","title":"measurements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>measurements: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.fake_tits","title":"fake_tits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fake_tits: str | None | UnsetType = Field(\n    default=UNSET, alias=\"fakeTits\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.penis_length","title":"penis_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>penis_length: str | None | UnsetType = Field(\n    default=UNSET, alias=\"penisLength\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.circumcised","title":"circumcised  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>circumcised: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.career_length","title":"career_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>career_length: str | None | UnsetType = Field(\n    default=UNSET, alias=\"careerLength\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.tattoos","title":"tattoos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tattoos: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.piercings","title":"piercings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>piercings: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[ScrapedTag] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.images","title":"images  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>images: list[str] | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.details","title":"details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>details: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.death_date","title":"death_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>death_date: str | None | UnsetType = Field(\n    default=UNSET, alias=\"deathDate\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.hair_color","title":"hair_color  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hair_color: str | None | UnsetType = Field(\n    default=UNSET, alias=\"hairColor\"\n)\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.weight","title":"weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weight: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.scraped_types.ScrapedPerformer.remote_site_id","title":"remote_site_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>remote_site_id: str | None | UnsetType = Field(\n    default=UNSET, alias=\"remoteSiteID\"\n)\n</code></pre>"},{"location":"api/types/#stashbox-types","title":"StashBox Types","text":""},{"location":"api/types/#stash_graphql_client.types.stashbox.StashBox","title":"StashBox","text":"<p>               Bases: <code>BaseModel</code></p> <p>StashBox configuration from schema/types/stash-box.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.stashbox.StashBox-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.stashbox.StashBox.endpoint","title":"endpoint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>endpoint: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.stashbox.StashBox.api_key","title":"api_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>api_key: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.stashbox.StashBox.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.stashbox.StashBox.max_requests_per_minute","title":"max_requests_per_minute  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_requests_per_minute: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#logging-types","title":"Logging Types","text":""},{"location":"api/types/#stash_graphql_client.types.logging.LogEntry","title":"LogEntry","text":"<p>               Bases: <code>BaseModel</code></p> <p>Log entry type from schema/types/logging.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.logging.LogEntry-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.logging.LogEntry.time","title":"time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time: Time | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogEntry.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: LogLevel | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogEntry.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel","title":"LogLevel","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Log level enum from schema/types/logging.graphql.</p>"},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel.TRACE","title":"TRACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRACE = 'Trace'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel.DEBUG","title":"DEBUG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEBUG = 'Debug'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel.INFO","title":"INFO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFO = 'Info'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel.PROGRESS","title":"PROGRESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROGRESS = 'Progress'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel.WARNING","title":"WARNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WARNING = 'Warning'\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.logging.LogLevel.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'Error'\n</code></pre>"},{"location":"api/types/#version-types","title":"Version Types","text":""},{"location":"api/types/#stash_graphql_client.types.version.Version","title":"Version","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Version information.</p>"},{"location":"api/types/#stash_graphql_client.types.version.Version-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.version.Version.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: str | None | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.version.Version.hash","title":"hash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hash: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.version.Version.build_time","title":"build_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>build_time: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.version.LatestVersion","title":"LatestVersion","text":"<p>               Bases: <code>FromGraphQLMixin</code>, <code>BaseModel</code></p> <p>Latest version information.</p>"},{"location":"api/types/#stash_graphql_client.types.version.LatestVersion-attributes","title":"Attributes","text":""},{"location":"api/types/#stash_graphql_client.types.version.LatestVersion.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.version.LatestVersion.shorthash","title":"shorthash  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shorthash: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.version.LatestVersion.release_date","title":"release_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>release_date: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/types/#stash_graphql_client.types.version.LatestVersion.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: str | UnsetType = UNSET\n</code></pre>"},{"location":"api/client/mixins/config/","title":"Configuration Operations","text":"<p>Operations for managing Stash configuration and settings.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for configuration methods.</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.configure_general","title":"configure_general  <code>async</code>","text":"<pre><code>configure_general(\n    input_data: ConfigGeneralInput | dict[str, Any],\n) -&gt; ConfigGeneralResult\n</code></pre> <p>Configure general Stash settings.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ConfigGeneralInput | dict[str, Any]</code> <p>ConfigGeneralInput object or dictionary containing general settings</p> required <p>Returns:</p> Type Description <code>ConfigGeneralResult</code> <p>ConfigGeneralResult with updated configuration</p> <p>Examples:</p> <p>Configure database path: <pre><code>config = await client.configure_general({\n    \"databasePath\": \"/path/to/database.db\"\n})\nprint(f\"Database path: {config.database_path}\")\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import ConfigGeneralInput\n\ninput_data = ConfigGeneralInput(\n    databasePath=\"/path/to/database.db\",\n    generatedPath=\"/path/to/generated\"\n)\nconfig = await client.configure_general(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.configure_interface","title":"configure_interface  <code>async</code>","text":"<pre><code>configure_interface(\n    input_data: ConfigInterfaceInput | dict[str, Any],\n) -&gt; ConfigInterfaceResult\n</code></pre> <p>Configure Stash interface settings.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ConfigInterfaceInput | dict[str, Any]</code> <p>ConfigInterfaceInput object or dictionary containing interface settings</p> required <p>Returns:</p> Type Description <code>ConfigInterfaceResult</code> <p>ConfigInterfaceResult with updated configuration</p> <p>Examples:</p> <p>Configure interface options: <pre><code>config = await client.configure_interface({\n    \"soundOnPreview\": True,\n    \"wallShowTitle\": False\n})\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import ConfigInterfaceInput\n\ninput_data = ConfigInterfaceInput(\n    soundOnPreview=True,\n    wallShowTitle=False,\n    autostartVideo=True\n)\nconfig = await client.configure_interface(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.configure_dlna","title":"configure_dlna  <code>async</code>","text":"<pre><code>configure_dlna(\n    input_data: ConfigDLNAInput | dict[str, Any],\n) -&gt; ConfigDLNAResult\n</code></pre> <p>Configure DLNA server settings.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ConfigDLNAInput | dict[str, Any]</code> <p>ConfigDLNAInput object or dictionary containing DLNA settings</p> required <p>Returns:</p> Type Description <code>ConfigDLNAResult</code> <p>ConfigDLNAResult with updated configuration</p> <p>Examples:</p> <p>Enable DLNA server: <pre><code>config = await client.configure_dlna({\n    \"enabled\": True,\n    \"port\": 1338,\n    \"serverName\": \"Stash DLNA\"\n})\nprint(f\"DLNA enabled: {config.enabled}\")\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import ConfigDLNAInput\n\ninput_data = ConfigDLNAInput(\n    enabled=True,\n    port=1338,\n    serverName=\"Stash DLNA\",\n    whitelistedIPs=[\"192.168.1.0/24\"]\n)\nconfig = await client.configure_dlna(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.configure_defaults","title":"configure_defaults  <code>async</code>","text":"<pre><code>configure_defaults(\n    input_data: ConfigDefaultSettingsInput | dict[str, Any],\n) -&gt; ConfigDefaultSettingsResult\n</code></pre> <p>Configure default metadata operation settings.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ConfigDefaultSettingsInput | dict[str, Any]</code> <p>ConfigDefaultSettingsInput object or dictionary containing default settings</p> required <p>Returns:</p> Type Description <code>ConfigDefaultSettingsResult</code> <p>ConfigDefaultSettingsResult with updated configuration</p> <p>Examples:</p> <p>Configure default delete behavior: <pre><code>config = await client.configure_defaults({\n    \"deleteFile\": False,\n    \"deleteGenerated\": True\n})\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import ConfigDefaultSettingsInput\n\ninput_data = ConfigDefaultSettingsInput(\n    deleteFile=False,\n    deleteGenerated=True\n)\nconfig = await client.configure_defaults(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.configure_ui","title":"configure_ui  <code>async</code>","text":"<pre><code>configure_ui(\n    input_data: dict[str, Any] | None = None,\n    partial: dict[str, Any] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Configure UI settings.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any] | None</code> <p>Complete UI configuration dictionary (optional)</p> <code>None</code> <code>partial</code> <code>dict[str, Any] | None</code> <p>Partial UI configuration to merge (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated UI configuration dictionary</p> <p>Examples:</p> <p>Update UI configuration: <pre><code>config = await client.configure_ui(\n    partial={\"theme\": \"dark\", \"language\": \"en-US\"}\n)\n</code></pre></p> <p>Replace entire UI config: <pre><code>config = await client.configure_ui(\n    input_data={\"theme\": \"dark\", \"language\": \"en-US\"}\n)\n</code></pre></p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.configure_ui_setting","title":"configure_ui_setting  <code>async</code>","text":"<pre><code>configure_ui_setting(\n    key: str, value: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Configure a single UI setting.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Setting key to update</p> required <code>value</code> <code>Any</code> <p>New value for the setting</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Updated UI configuration dictionary</p> <p>Examples:</p> <p>Update a single UI setting: <pre><code>config = await client.configure_ui_setting(\"theme\", \"dark\")\n</code></pre></p> <p>Update multiple settings one at a time: <pre><code>await client.configure_ui_setting(\"theme\", \"dark\")\nawait client.configure_ui_setting(\"language\", \"en-US\")\n</code></pre></p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.generate_api_key","title":"generate_api_key  <code>async</code>","text":"<pre><code>generate_api_key(\n    input_data: GenerateAPIKeyInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Generate a new API key.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>GenerateAPIKeyInput | dict[str, Any]</code> <p>GenerateAPIKeyInput object or dictionary containing: - clear: Whether to clear existing API key (optional)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Generated API key string</p> <p>Examples:</p> <p>Generate new API key: <pre><code>api_key = await client.generate_api_key({\"clear\": False})\nprint(f\"New API key: {api_key}\")\n</code></pre></p> <p>Clear and generate new key: <pre><code>from stash_graphql_client.types import GenerateAPIKeyInput\n\ninput_data = GenerateAPIKeyInput(clear=True)\napi_key = await client.generate_api_key(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.find_saved_filter","title":"find_saved_filter  <code>async</code>","text":"<pre><code>find_saved_filter(id: str) -&gt; SavedFilter | None\n</code></pre> <p>Find a saved filter by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Filter ID</p> required <p>Returns:</p> Type Description <code>SavedFilter | None</code> <p>SavedFilter object if found, None otherwise</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.find_saved_filters","title":"find_saved_filters  <code>async</code>","text":"<pre><code>find_saved_filters(\n    mode: FilterMode | None = None,\n) -&gt; list[SavedFilter]\n</code></pre> <p>Find all saved filters, optionally filtered by mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>FilterMode | None</code> <p>Optional filter mode to filter by</p> <code>None</code> <p>Returns:</p> Type Description <code>list[SavedFilter]</code> <p>List of SavedFilter objects</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.configure_scraping","title":"configure_scraping  <code>async</code>","text":"<pre><code>configure_scraping(\n    input_data: ConfigScrapingInput | dict[str, Any],\n) -&gt; ConfigScrapingResult\n</code></pre> <p>Configure scraping settings.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ConfigScrapingInput | dict[str, Any]</code> <p>ConfigScrapingInput object or dictionary</p> required <p>Returns:</p> Type Description <code>ConfigScrapingResult</code> <p>ConfigScrapingResult with updated configuration</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.validate_stashbox_credentials","title":"validate_stashbox_credentials  <code>async</code>","text":"<pre><code>validate_stashbox_credentials(\n    input_data: StashBoxInput | dict[str, Any],\n) -&gt; StashBoxValidationResult\n</code></pre> <p>Validate StashBox credentials.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>StashBoxInput | dict[str, Any]</code> <p>StashBoxInput object or dictionary containing endpoint and api_key</p> required <p>Returns:</p> Type Description <code>StashBoxValidationResult</code> <p>StashBoxValidationResult with validation status</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.enable_dlna","title":"enable_dlna  <code>async</code>","text":"<pre><code>enable_dlna(\n    input_data: EnableDLNAInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Enable DLNA server.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>EnableDLNAInput | dict[str, Any]</code> <p>EnableDLNAInput object or dictionary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.disable_dlna","title":"disable_dlna  <code>async</code>","text":"<pre><code>disable_dlna(\n    input_data: DisableDLNAInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Disable DLNA server.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>DisableDLNAInput | dict[str, Any]</code> <p>DisableDLNAInput object or dictionary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.add_temp_dlna_ip","title":"add_temp_dlna_ip  <code>async</code>","text":"<pre><code>add_temp_dlna_ip(\n    input_data: AddTempDLNAIPInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Add temporary DLNA IP whitelist.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>AddTempDLNAIPInput | dict[str, Any]</code> <p>AddTempDLNAIPInput object or dictionary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.remove_temp_dlna_ip","title":"remove_temp_dlna_ip  <code>async</code>","text":"<pre><code>remove_temp_dlna_ip(\n    input_data: RemoveTempDLNAIPInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Remove temporary DLNA IP from whitelist.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>RemoveTempDLNAIPInput | dict[str, Any]</code> <p>RemoveTempDLNAIPInput object or dictionary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/config/#stash_graphql_client.client.mixins.config.ConfigClientMixin.get_configuration","title":"get_configuration  <code>async</code>","text":"<pre><code>get_configuration() -&gt; ConfigResult\n</code></pre> <p>Get complete Stash configuration.</p> <p>Returns:</p> Type Description <code>ConfigResult</code> <p>ConfigResult containing all configuration sections: - general: General settings (paths, logging, parallel tasks, etc.) - interface: UI/UX settings (language, menus, previews, etc.) - dlna: DLNA server configuration - scraping: Scraper settings (user agent, cert check, etc.) - defaults: Default settings for scan/identify/generate operations - ui: UI customization settings (plugin configs, etc.)</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the GraphQL request fails</p> <p>Examples:</p> <p>Get full configuration: <pre><code>config = await client.get_configuration()\nprint(f\"Database: {config.general.databasePath}\")\nprint(f\"Language: {config.interface.language}\")\nprint(f\"DLNA enabled: {config.dlna.enabled}\")\n</code></pre></p> <p>Check specific settings: <pre><code>config = await client.get_configuration()\nif config.general.parallelTasks &lt; 4:\n    print(\"Consider increasing parallel tasks for better performance\")\n\nif not config.scraping.scraperCertCheck:\n    print(\"WARNING: SSL certificate checking is disabled!\")\n</code></pre></p> <p>Inspect plugin UI settings: <pre><code>config = await client.get_configuration()\nif config.ui:\n    for plugin_id, settings in config.ui.items():\n        print(f\"Plugin {plugin_id}: {settings}\")\n</code></pre></p>"},{"location":"api/client/mixins/file/","title":"File Operations","text":"<p>Operations for managing files and folders.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for file-related client methods.</p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.find_file","title":"find_file  <code>async</code>","text":"<pre><code>find_file(\n    id: str | None = None, path: str | None = None\n) -&gt; BaseFile | None\n</code></pre> <p>Find a file by its ID or path.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str | None</code> <p>The ID of the file to find (optional)</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The path of the file to find (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseFile | None</code> <p>BaseFile object (VideoFile, ImageFile, GalleryFile, or BasicFile) if found,</p> <code>BaseFile | None</code> <p>None otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither id nor path is provided</p> <p>Examples:</p> <p>Find a file by ID: <pre><code>file = await client.find_file(id=\"123\")\nif file:\n    print(f\"Found file: {file.path}\")\n</code></pre></p> <p>Find a file by path: <pre><code>file = await client.find_file(path=\"/path/to/video.mp4\")\nif file:\n    print(f\"File size: {file.size} bytes\")\n</code></pre></p> <p>Check file type: <pre><code>from stash_graphql_client.types import VideoFile, ImageFile\n\nfile = await client.find_file(path=\"/path/to/file.mp4\")\nif isinstance(file, VideoFile):\n    print(f\"Video: {file.width}x{file.height}, {file.duration}s\")\nelif isinstance(file, ImageFile):\n    print(f\"Image: {file.width}x{file.height}\")\n</code></pre></p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.find_files","title":"find_files  <code>async</code>","text":"<pre><code>find_files(\n    file_filter: dict[str, Any] | None = None,\n    filter_: dict[str, Any] | None = None,\n    ids: list[str] | None = None,\n) -&gt; FindFilesResultType\n</code></pre> <p>Find files matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>file_filter</code> <code>dict[str, Any] | None</code> <p>Optional file-specific filter: - path: StringCriterionInput - basename: StringCriterionInput - dir: StringCriterionInput - parent_folder: HierarchicalMultiCriterionInput - zip_file: MultiCriterionInput - mod_time: TimestampCriterionInput - size: IntCriterionInput</p> <code>None</code> <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>Optional list of file IDs to retrieve</p> <code>None</code> <p>Returns:</p> Type Description <code>FindFilesResultType</code> <p>FindFilesResultType containing: - count: Total number of matching files - megapixels: Total megapixels of image files - duration: Total duration in seconds of video files - size: Total size in bytes - files: List of BaseFile objects</p> <p>Examples:</p> <p>Find all files in a directory: <pre><code>result = await client.find_files(\n    file_filter={\n        \"path\": {\n            \"value\": \"/videos/\",\n            \"modifier\": \"INCLUDES\"\n        }\n    }\n)\nprint(f\"Found {result.count} files, total size: {result.size} bytes\")\n</code></pre></p> <p>Find video files by size: <pre><code>result = await client.find_files(\n    file_filter={\n        \"size\": {\n            \"value\": 1000000000,  # 1GB\n            \"modifier\": \"GREATER_THAN\"\n        }\n    }\n)\nfor file in result.files:\n    print(f\"{file.path}: {file.size} bytes\")\n</code></pre></p> <p>Find files by IDs: <pre><code>result = await client.find_files(ids=[\"1\", \"2\", \"3\"])\n</code></pre></p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.move_files","title":"move_files  <code>async</code>","text":"<pre><code>move_files(\n    input_data: MoveFilesInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Move files to a new location.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>MoveFilesInput | dict[str, Any]</code> <p>MoveFilesInput object or dictionary containing: - ids: List of file IDs to move (required) - destination_folder: Destination folder path (optional) - destination_folder_id: Destination folder ID (optional) - destination_basename: New basename for single file (optional)</p> <p>Note: Either destination_folder or destination_folder_id must be provided</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the move was successful, False otherwise</p> <p>Examples:</p> <p>Move files to a new folder by path: <pre><code>success = await client.move_files({\n    \"ids\": [\"1\", \"2\", \"3\"],\n    \"destination_folder\": \"/new/location\"\n})\n</code></pre></p> <p>Move files to a new folder by ID: <pre><code>success = await client.move_files({\n    \"ids\": [\"1\", \"2\"],\n    \"destination_folder_id\": \"folder123\"\n})\n</code></pre></p> <p>Move and rename a single file: <pre><code>success = await client.move_files({\n    \"ids\": [\"1\"],\n    \"destination_folder\": \"/new/location\",\n    \"destination_basename\": \"newname.mp4\"\n})\n</code></pre></p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.file_set_fingerprints","title":"file_set_fingerprints  <code>async</code>","text":"<pre><code>file_set_fingerprints(\n    input_data: FileSetFingerprintsInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Set fingerprints for a file.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>FileSetFingerprintsInput | dict[str, Any]</code> <p>FileSetFingerprintsInput object or dictionary containing: - id: File ID (required) - fingerprints: List of SetFingerprintsInput objects with:     - type: Fingerprint type (required)     - value: Fingerprint value (optional)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the operation was successful, False otherwise</p> <p>Examples:</p> <p>Set MD5 fingerprint: <pre><code>success = await client.file_set_fingerprints({\n    \"id\": \"file123\",\n    \"fingerprints\": [\n        {\"type\": \"MD5\", \"value\": \"abc123def456\"}\n    ]\n})\n</code></pre></p> <p>Set multiple fingerprints: <pre><code>success = await client.file_set_fingerprints({\n    \"id\": \"file123\",\n    \"fingerprints\": [\n        {\"type\": \"MD5\", \"value\": \"abc123\"},\n        {\"type\": \"PHASH\", \"value\": \"def456\"},\n    ]\n})\n</code></pre></p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.scene_assign_file","title":"scene_assign_file  <code>async</code>","text":"<pre><code>scene_assign_file(\n    input_data: AssignSceneFileInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Assign a file to a scene.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>AssignSceneFileInput | dict[str, Any]</code> <p>AssignSceneFileInput object or dictionary containing: - scene_id: Scene ID (required) - file_id: File ID (required)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the assignment was successful, False otherwise</p> <p>Examples:</p> <p>Assign a file to a scene: <pre><code>success = await client.scene_assign_file({\n    \"scene_id\": \"scene123\",\n    \"file_id\": \"file456\"\n})\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import AssignSceneFileInput\n\ninput_data = AssignSceneFileInput(\n    scene_id=\"scene123\",\n    file_id=\"file456\"\n)\nsuccess = await client.scene_assign_file(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.delete_files","title":"delete_files  <code>async</code>","text":"<pre><code>delete_files(ids: list[str]) -&gt; bool\n</code></pre> <p>Delete files.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of file IDs to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the files were successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any file ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.find_folder","title":"find_folder  <code>async</code>","text":"<pre><code>find_folder(\n    id: str | None = None, path: str | None = None\n) -&gt; Folder | None\n</code></pre> <p>Find a folder by its ID or path.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str | None</code> <p>The ID of the folder to find (optional)</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The path of the folder to find (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>Folder | None</code> <p>Folder object if found, None otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither id nor path is provided</p>"},{"location":"api/client/mixins/file/#stash_graphql_client.client.mixins.file.FileClientMixin.find_folders","title":"find_folders  <code>async</code>","text":"<pre><code>find_folders(\n    folder_filter: FolderFilterType\n    | dict[str, Any]\n    | None = None,\n    filter_: dict[str, Any] | None = None,\n    ids: list[str] | None = None,\n) -&gt; FindFoldersResultType\n</code></pre> <p>Find folders matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>folder_filter</code> <code>FolderFilterType | dict[str, Any] | None</code> <p>Optional folder-specific filter (FolderFilterType or dict)</p> <code>None</code> <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters (FindFilterType or dict)</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>Optional list of folder IDs to retrieve</p> <code>None</code> <p>Returns:</p> Type Description <code>FindFoldersResultType</code> <p>FindFoldersResultType containing count and list of folders</p>"},{"location":"api/client/mixins/filter/","title":"Filter Operations","text":"<p>Operations for saving and managing search filters.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for filter-related client methods.</p>"},{"location":"api/client/mixins/filter/#stash_graphql_client.client.mixins.filter.FilterClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/filter/#stash_graphql_client.client.mixins.filter.FilterClientMixin.save_filter","title":"save_filter  <code>async</code>","text":"<pre><code>save_filter(\n    input_data: SaveFilterInput | dict[str, Any],\n) -&gt; SavedFilter\n</code></pre> <p>Save or update a filter.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>SaveFilterInput | dict[str, Any]</code> <p>SaveFilterInput object or dictionary containing: - mode: FilterMode (required) - Type of filter (SCENES, PERFORMERS, etc.) - name: str (required) - Name of the filter - id: str (optional) - If provided, updates existing filter - find_filter: FindFilterType (optional) - General filter parameters - object_filter: dict (optional) - Type-specific filter criteria - ui_options: dict (optional) - UI display options</p> required <p>Returns:</p> Type Description <code>SavedFilter</code> <p>SavedFilter object with the saved filter data</p> <p>Examples:</p> <p>Save a new filter: <pre><code>from stash_graphql_client.types import SaveFilterInput, FilterMode\n\ninput_data = SaveFilterInput(\n    mode=FilterMode.SCENES,\n    name=\"My Favorite Scenes\",\n    find_filter={\"per_page\": 25},\n    object_filter={\"is_missing\": \"performers\"}\n)\nsaved_filter = await client.save_filter(input_data)\n</code></pre></p> <p>Update an existing filter: <pre><code>input_data = SaveFilterInput(\n    id=\"123\",\n    mode=FilterMode.SCENES,\n    name=\"Updated Filter Name\"\n)\nsaved_filter = await client.save_filter(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/filter/#stash_graphql_client.client.mixins.filter.FilterClientMixin.destroy_saved_filter","title":"destroy_saved_filter  <code>async</code>","text":"<pre><code>destroy_saved_filter(\n    input_data: DestroyFilterInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete a saved filter.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>DestroyFilterInput | dict[str, Any]</code> <p>DestroyFilterInput object or dictionary containing: - id: Filter ID to delete (required)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the filter was successfully deleted</p> <p>Examples:</p> <pre><code>from stash_graphql_client.types import DestroyFilterInput\n\ninput_data = DestroyFilterInput(id=\"123\")\nsuccess = await client.destroy_saved_filter(input_data)\n</code></pre> <p>Using a dictionary: <pre><code>success = await client.destroy_saved_filter({\"id\": \"123\"})\n</code></pre></p>"},{"location":"api/client/mixins/gallery/","title":"Gallery Operations","text":"<p>Operations for managing galleries (image collections).</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for gallery-related client methods.</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.find_gallery","title":"find_gallery  <code>async</code>","text":"<pre><code>find_gallery(id: str) -&gt; Gallery | None\n</code></pre> <p>Find a gallery by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the gallery to find</p> required <p>Returns:</p> Type Description <code>Gallery | None</code> <p>Gallery object if found, None otherwise</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.find_galleries","title":"find_galleries  <code>async</code>","text":"<pre><code>find_galleries(\n    filter_: dict[str, Any] | None = None,\n    gallery_filter: dict[str, Any] | None = None,\n    q: str | None = None,\n) -&gt; FindGalleriesResultType\n</code></pre> <p>Find galleries matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>gallery_filter</code> <code>dict[str, Any] | None</code> <p>Optional gallery-specific filter</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <p>Returns:</p> Type Description <code>FindGalleriesResultType</code> <p>FindGalleriesResultType containing: - count: Total number of matching galleries - galleries: List of Gallery objects</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.create_gallery","title":"create_gallery  <code>async</code>","text":"<pre><code>create_gallery(gallery: Gallery) -&gt; Gallery\n</code></pre> <p>Create a new gallery in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>gallery</code> <code>Gallery</code> <p>Gallery object with the data to create. Required fields: - title: Gallery title</p> required <p>Returns:</p> Type Description <code>Gallery</code> <p>Created Gallery object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the gallery data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.update_gallery","title":"update_gallery  <code>async</code>","text":"<pre><code>update_gallery(gallery: Gallery) -&gt; Gallery\n</code></pre> <p>Update an existing gallery in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>gallery</code> <code>Gallery</code> <p>Gallery object with updated data. Required fields: - id: Gallery ID to update Any other fields that are set will be updated. Fields that are None will be ignored.</p> required <p>Returns:</p> Type Description <code>Gallery</code> <p>Updated Gallery object with any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the gallery data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.galleries_update","title":"galleries_update  <code>async</code>","text":"<pre><code>galleries_update(galleries: list[Gallery]) -&gt; list[Gallery]\n</code></pre> <p>Update multiple galleries with individual data.</p> <p>Parameters:</p> Name Type Description Default <code>galleries</code> <code>list[Gallery]</code> <p>List of Gallery objects to update, each must have an ID</p> required <p>Returns:</p> Type Description <code>list[Gallery]</code> <p>List of updated Gallery objects</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.gallery_destroy","title":"gallery_destroy  <code>async</code>","text":"<pre><code>gallery_destroy(\n    ids: list[str],\n    delete_file: bool | None = None,\n    delete_generated: bool | None = None,\n) -&gt; bool\n</code></pre> <p>Delete galleries.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of gallery IDs to delete</p> required <code>delete_file</code> <code>bool | None</code> <p>If true, delete associated files</p> <code>None</code> <code>delete_generated</code> <code>bool | None</code> <p>If true, delete generated files</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.remove_gallery_images","title":"remove_gallery_images  <code>async</code>","text":"<pre><code>remove_gallery_images(\n    gallery_id: str, image_ids: list[str]\n) -&gt; bool\n</code></pre> <p>Remove images from a gallery.</p> <p>Parameters:</p> Name Type Description Default <code>gallery_id</code> <code>str</code> <p>Gallery ID</p> required <code>image_ids</code> <code>list[str]</code> <p>List of image IDs to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.set_gallery_cover","title":"set_gallery_cover  <code>async</code>","text":"<pre><code>set_gallery_cover(\n    gallery_id: str, cover_image_id: str\n) -&gt; bool\n</code></pre> <p>Set the cover image for a gallery.</p> <p>Parameters:</p> Name Type Description Default <code>gallery_id</code> <code>str</code> <p>Gallery ID</p> required <code>cover_image_id</code> <code>str</code> <p>ID of the image to use as cover</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.reset_gallery_cover","title":"reset_gallery_cover  <code>async</code>","text":"<pre><code>reset_gallery_cover(gallery_id: str) -&gt; bool\n</code></pre> <p>Reset the cover image for a gallery.</p> <p>Parameters:</p> Name Type Description Default <code>gallery_id</code> <code>str</code> <p>Gallery ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.gallery_chapter_create","title":"gallery_chapter_create  <code>async</code>","text":"<pre><code>gallery_chapter_create(\n    gallery_id: str, title: str, image_index: int\n) -&gt; GalleryChapter\n</code></pre> <p>Create a new gallery chapter.</p> <p>Parameters:</p> Name Type Description Default <code>gallery_id</code> <code>str</code> <p>Gallery ID</p> required <code>title</code> <code>str</code> <p>Chapter title</p> required <code>image_index</code> <code>int</code> <p>Index of the image where the chapter starts</p> required <p>Returns:</p> Type Description <code>GalleryChapter</code> <p>Created GalleryChapter object</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.gallery_chapter_update","title":"gallery_chapter_update  <code>async</code>","text":"<pre><code>gallery_chapter_update(\n    id: str,\n    gallery_id: str | None = None,\n    title: str | None = None,\n    image_index: int | None = None,\n) -&gt; GalleryChapter\n</code></pre> <p>Update a gallery chapter.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Chapter ID</p> required <code>gallery_id</code> <code>str | None</code> <p>Optional gallery ID to move chapter to</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional new title</p> <code>None</code> <code>image_index</code> <code>int | None</code> <p>Optional new image index</p> <code>None</code> <p>Returns:</p> Type Description <code>GalleryChapter</code> <p>Updated GalleryChapter object</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.add_gallery_images","title":"add_gallery_images  <code>async</code>","text":"<pre><code>add_gallery_images(\n    gallery_id: str, image_ids: list[str]\n) -&gt; bool\n</code></pre> <p>Add images to a gallery.</p> <p>Parameters:</p> Name Type Description Default <code>gallery_id</code> <code>str</code> <p>Gallery ID</p> required <code>image_ids</code> <code>list[str]</code> <p>List of image IDs to add</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> <p>Examples:</p> <p>Add images to a gallery: <pre><code>success = await client.add_gallery_images(\n    gallery_id=gallery.id,\n    image_ids=[\"456\", \"789\"],\n)\n</code></pre></p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.update_gallery_images","title":"update_gallery_images  <code>async</code>","text":"<pre><code>update_gallery_images(\n    gallery_id: str, image_ids: list[str], mode: str = \"SET\"\n) -&gt; bool\n</code></pre> <p>Update gallery images with the specified mode.</p> <p>This is a convenience method that delegates to either add_gallery_images or remove_gallery_images based on the mode parameter.</p> <p>Parameters:</p> Name Type Description Default <code>gallery_id</code> <code>str</code> <p>Gallery ID</p> required <code>image_ids</code> <code>list[str]</code> <p>List of image IDs to set, add, or remove</p> required <code>mode</code> <code>str</code> <p>Operation mode - \"SET\", \"ADD\", or \"REMOVE\" (default: \"SET\") - \"SET\": Replace all gallery images with the provided list - \"ADD\": Add the images to the gallery - \"REMOVE\": Remove the images from the gallery</p> <code>'SET'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mode is not one of \"SET\", \"ADD\", or \"REMOVE\"</p> <p>Examples:</p> <p>Set gallery images (replace all): <pre><code>success = await client.update_gallery_images(\n    gallery_id=\"123\",\n    image_ids=[\"img_1\", \"img_2\"],\n    mode=\"SET\",\n)\n</code></pre></p> <p>Add images to gallery: <pre><code>success = await client.update_gallery_images(\n    gallery_id=\"123\",\n    image_ids=[\"img_3\"],\n    mode=\"ADD\",\n)\n</code></pre></p> <p>Remove images from gallery: <pre><code>success = await client.update_gallery_images(\n    gallery_id=\"123\",\n    image_ids=[\"img_1\"],\n    mode=\"REMOVE\",\n)\n</code></pre></p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.gallery_chapter_destroy","title":"gallery_chapter_destroy  <code>async</code>","text":"<pre><code>gallery_chapter_destroy(id: str) -&gt; bool\n</code></pre> <p>Delete a gallery chapter.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Chapter ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/gallery/#stash_graphql_client.client.mixins.gallery.GalleryClientMixin.bulk_gallery_update","title":"bulk_gallery_update  <code>async</code>","text":"<pre><code>bulk_gallery_update(\n    input_data: BulkGalleryUpdateInput | dict[str, Any],\n) -&gt; list[Gallery]\n</code></pre> <p>Bulk update galleries.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>BulkGalleryUpdateInput | dict[str, Any]</code> <p>BulkGalleryUpdateInput object or dictionary containing: - ids: List of gallery IDs to update (optional) - And any fields to update (e.g., organized, rating100, etc.)</p> required <p>Returns:</p> Type Description <code>list[Gallery]</code> <p>List of updated Gallery objects</p>"},{"location":"api/client/mixins/group/","title":"Group Operations","text":"<p>Operations for managing groups (movies/collections).</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for group-related client methods.</p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.find_group","title":"find_group  <code>async</code>","text":"<pre><code>find_group(group_id: str) -&gt; Group | None\n</code></pre> <p>Find a group by ID.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Group ID to search for</p> required <p>Returns:</p> Type Description <code>Group | None</code> <p>Group object if found, None otherwise</p> <p>Examples:</p> <pre><code>group = await client.find_group(\"123\")\nif group:\n    print(f\"Found group: {group.name}\")\n    print(f\"Duration: {group.duration} seconds\")\n    print(f\"Director: {group.director}\")\n</code></pre> <p>Access group relationships: <pre><code>group = await client.find_group(\"123\")\nif group:\n    # Get scene titles\n    scene_titles = [s.title for s in group.scenes]\n    # Get studio name\n    studio_name = group.studio.name if group.studio else None\n    # Get tag names\n    tags = [t.name for t in group.tags]\n    # Get sub-groups\n    sub_groups = [sg.group.name for sg in group.sub_groups]\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.find_groups","title":"find_groups  <code>async</code>","text":"<pre><code>find_groups(\n    filter_: dict[str, Any] | None = None,\n    group_filter: dict[str, Any] | None = None,\n    ids: list[str] | None = None,\n    q: str | None = None,\n) -&gt; FindGroupsResultType\n</code></pre> <p>Find groups matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>group_filter</code> <code>dict[str, Any] | None</code> <p>Optional group-specific filter: - name: StringCriterionInput - director: StringCriterionInput - synopsis: StringCriterionInput - duration: IntCriterionInput - rating100: IntCriterionInput - date: DateCriterionInput - url: StringCriterionInput - is_missing: str (what data is missing) - studios: HierarchicalMultiCriterionInput - tags: HierarchicalMultiCriterionInput</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>Optional list of group IDs to filter by</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <p>Returns:</p> Type Description <code>FindGroupsResultType</code> <p>FindGroupsResultType containing: - count: Total number of matching groups - groups: List of Group objects</p> <p>Examples:</p> <p>Find all groups: <pre><code>result = await client.find_groups()\nprint(f\"Found {result.count} groups\")\nfor group in result.groups:\n    print(f\"- {group.name}\")\n</code></pre></p> <p>Search by name: <pre><code>result = await client.find_groups(q=\"Action\")\nprint(f\"Found {result.count} groups matching 'Action'\")\n</code></pre></p> <p>Find groups by filter: <pre><code>result = await client.find_groups(\n    group_filter={\n        \"name\": {\n            \"value\": \"Series\",\n            \"modifier\": \"INCLUDES\"\n        }\n    }\n)\n</code></pre></p> <p>Find groups with specific tags: <pre><code>result = await client.find_groups(\n    group_filter={\n        \"tags\": {\n            \"value\": [\"tag1\", \"tag2\"],\n            \"modifier\": \"INCLUDES_ALL\"\n        }\n    }\n)\n</code></pre></p> <p>Find groups with high rating and sort by name: <pre><code>result = await client.find_groups(\n    filter_={\n        \"direction\": \"ASC\",\n        \"sort\": \"name\",\n    },\n    group_filter={\n        \"rating100\": {\n            \"value\": 80,\n            \"modifier\": \"GREATER_THAN\"\n        }\n    }\n)\n</code></pre></p> <p>Paginate results: <pre><code>result = await client.find_groups(\n    filter_={\n        \"page\": 1,\n        \"per_page\": 25,\n    }\n)\n</code></pre></p> <p>Find specific groups by IDs: <pre><code>result = await client.find_groups(ids=[\"123\", \"456\", \"789\"])\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.create_group","title":"create_group  <code>async</code>","text":"<pre><code>create_group(group: Group) -&gt; Group\n</code></pre> <p>Create a new group in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>Group</code> <p>Group object with the data to create. Required fields: - name: Group name</p> required <p>Returns:</p> Type Description <code>Group</code> <p>Created Group object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the group data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Create a basic group: <pre><code>group = Group(name=\"Test Series\")\ncreated = await client.create_group(group)\nprint(f\"Created group with ID: {created.id}\")\n</code></pre></p> <p>Create group with metadata: <pre><code>group = Group(\n    name=\"Action Movie Series\",\n    director=\"John Director\",\n    synopsis=\"An action-packed series\",\n    duration=7200,\n    date=\"2020-01-01\",\n    rating100=85,\n)\ncreated = await client.create_group(group)\n</code></pre></p> <p>Create group with relationships: <pre><code>from stash_graphql_client.types import Tag, Studio\n\n# Fetch tags and studio\ntag1 = await client.find_tag(\"tag1_id\")\ntag2 = await client.find_tag(\"tag2_id\")\nstudio = await client.find_studio(\"studio_id\")\n\ngroup = Group(\n    name=\"Tagged Group\",\n    tags=[tag1, tag2],\n    studio=studio,\n)\ncreated = await client.create_group(group)\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.update_group","title":"update_group  <code>async</code>","text":"<pre><code>update_group(group: Group) -&gt; Group\n</code></pre> <p>Update an existing group in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>Group</code> <p>Group object with updated data. Must include ID field.</p> required <p>Returns:</p> Type Description <code>Group</code> <p>Updated Group object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the group ID is missing or data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Update group name and director: <pre><code>group = await client.find_group(\"123\")\ngroup.name = \"Updated Name\"\ngroup.director = \"New Director\"\nupdated = await client.update_group(group)\n</code></pre></p> <p>Update group rating: <pre><code>group = await client.find_group(\"123\")\ngroup.rating100 = 90\nupdated = await client.update_group(group)\n</code></pre></p> <p>Update group tags: <pre><code>group = await client.find_group(\"123\")\ntag1 = await client.find_tag(\"tag1_id\")\ntag2 = await client.find_tag(\"tag2_id\")\ngroup.tags = [tag1, tag2]\nupdated = await client.update_group(group)\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.group_destroy","title":"group_destroy  <code>async</code>","text":"<pre><code>group_destroy(\n    input_data: GroupDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete a group from Stash.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>GroupDestroyInput | dict[str, Any]</code> <p>GroupDestroyInput or dict with: - id: Group ID to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if deletion was successful</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Delete by ID using dict: <pre><code>result = await client.group_destroy({\"id\": \"123\"})\nif result:\n    print(\"Group deleted successfully\")\n</code></pre></p> <p>Delete using GroupDestroyInput: <pre><code>from stash_graphql_client.types import GroupDestroyInput\n\ninput_data = GroupDestroyInput(id=\"123\")\nresult = await client.group_destroy(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.groups_destroy","title":"groups_destroy  <code>async</code>","text":"<pre><code>groups_destroy(ids: list[str]) -&gt; bool\n</code></pre> <p>Delete multiple groups from Stash.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of group IDs to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if deletion was successful</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <pre><code>result = await client.groups_destroy([\"123\", \"456\", \"789\"])\nif result:\n    print(\"Groups deleted successfully\")\n</code></pre>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.bulk_group_update","title":"bulk_group_update  <code>async</code>","text":"<pre><code>bulk_group_update(\n    input_data: BulkGroupUpdateInput | dict[str, Any],\n) -&gt; list[Group]\n</code></pre> <p>Bulk update multiple groups.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>BulkGroupUpdateInput | dict[str, Any]</code> <p>BulkGroupUpdateInput or dict with: - ids: List of group IDs to update - rating100: Optional rating (1-100) - studio_id: Optional studio ID - director: Optional director name - urls: Optional list of URLs - tag_ids: Optional list of tag IDs - containing_groups: Optional groups that contain these groups - sub_groups: Optional sub-groups</p> required <p>Returns:</p> Type Description <code>list[Group]</code> <p>List of updated Group objects</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Update rating for multiple groups: <pre><code>result = await client.bulk_group_update({\n    \"ids\": [\"1\", \"2\", \"3\"],\n    \"rating100\": 85\n})\nprint(f\"Updated {len(result)} groups\")\n</code></pre></p> <p>Add tags to multiple groups: <pre><code>from stash_graphql_client.types import BulkGroupUpdateInput\n\ninput_data = BulkGroupUpdateInput(\n    ids=[\"1\", \"2\", \"3\"],\n    tag_ids=[\"tag1\", \"tag2\"]\n)\nresult = await client.bulk_group_update(input_data)\n</code></pre></p> <p>Set studio for multiple groups: <pre><code>result = await client.bulk_group_update({\n    \"ids\": [\"1\", \"2\", \"3\"],\n    \"studio_id\": \"studio_123\"\n})\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.add_group_sub_groups","title":"add_group_sub_groups  <code>async</code>","text":"<pre><code>add_group_sub_groups(\n    input_data: GroupSubGroupAddInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Add sub-groups to a group.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>GroupSubGroupAddInput | dict[str, Any]</code> <p>GroupSubGroupAddInput or dict with: - containing_group_id: ID of the parent group - sub_groups: List of GroupDescriptionInput dicts with group_id and optional description - insert_index: Optional index at which to insert (default: append to end)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Add sub-groups to end: <pre><code>result = await client.add_group_sub_groups({\n    \"containing_group_id\": \"parent_123\",\n    \"sub_groups\": [\n        {\"group_id\": \"child_456\"},\n        {\"group_id\": \"child_789\", \"description\": \"Episode 1\"}\n    ]\n})\n</code></pre></p> <p>Insert sub-groups at specific index: <pre><code>from stash_graphql_client.types import (\n    GroupSubGroupAddInput,\n    GroupDescriptionInput\n)\n\ninput_data = GroupSubGroupAddInput(\n    containing_group_id=\"parent_123\",\n    sub_groups=[\n        GroupDescriptionInput(group_id=\"child_456\", description=\"Episode 2\")\n    ],\n    insert_index=1\n)\nresult = await client.add_group_sub_groups(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.remove_group_sub_groups","title":"remove_group_sub_groups  <code>async</code>","text":"<pre><code>remove_group_sub_groups(\n    input_data: GroupSubGroupRemoveInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Remove sub-groups from a group.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>GroupSubGroupRemoveInput | dict[str, Any]</code> <p>GroupSubGroupRemoveInput or dict with: - containing_group_id: ID of the parent group - sub_group_ids: List of sub-group IDs to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Remove sub-groups: <pre><code>result = await client.remove_group_sub_groups({\n    \"containing_group_id\": \"parent_123\",\n    \"sub_group_ids\": [\"child_456\", \"child_789\"]\n})\n</code></pre></p> <p>Using typed input: <pre><code>from stash_graphql_client.types import GroupSubGroupRemoveInput\n\ninput_data = GroupSubGroupRemoveInput(\n    containing_group_id=\"parent_123\",\n    sub_group_ids=[\"child_456\", \"child_789\"]\n)\nresult = await client.remove_group_sub_groups(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/group/#stash_graphql_client.client.mixins.group.GroupClientMixin.reorder_sub_groups","title":"reorder_sub_groups  <code>async</code>","text":"<pre><code>reorder_sub_groups(\n    input_data: ReorderSubGroupsInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Reorder sub-groups within a group.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ReorderSubGroupsInput | dict[str, Any]</code> <p>ReorderSubGroupsInput or dict with: - group_id: ID of the parent group - sub_group_ids: List of sub-group IDs to reorder (must be subset of existing) - insert_at_id: Sub-group ID at which to insert the reordered groups - insert_after: If True, insert after insert_at_id; if False, insert before</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Reorder sub-groups: <pre><code>result = await client.reorder_sub_groups({\n    \"group_id\": \"parent_123\",\n    \"sub_group_ids\": [\"child_2\", \"child_3\"],\n    \"insert_at_id\": \"child_1\",\n    \"insert_after\": True\n})\n</code></pre></p> <p>Using typed input: <pre><code>from stash_graphql_client.types import ReorderSubGroupsInput\n\ninput_data = ReorderSubGroupsInput(\n    group_id=\"parent_123\",\n    sub_group_ids=[\"child_2\", \"child_3\"],\n    \"insert_at_id\": \"child_1\",\n    insert_after=False\n)\nresult = await client.reorder_sub_groups(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/image/","title":"Image Operations","text":"<p>Operations for managing images.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for image-related client methods.</p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.find_image","title":"find_image  <code>async</code>","text":"<pre><code>find_image(id: str) -&gt; Image | None\n</code></pre> <p>Find an image by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the image to find</p> required <p>Returns:</p> Type Description <code>Image | None</code> <p>Image object if found, None otherwise</p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.find_images","title":"find_images  <code>async</code>","text":"<pre><code>find_images(\n    filter_: dict[str, Any] | None = None,\n    image_filter: dict[str, Any] | None = None,\n    q: str | None = None,\n) -&gt; FindImagesResultType\n</code></pre> <p>Find images matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>image_filter</code> <code>dict[str, Any] | None</code> <p>Optional image-specific filter</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <p>Returns:</p> Type Description <code>FindImagesResultType</code> <p>FindImagesResultType containing: - count: Total number of matching images - images: List of Image objects</p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.create_image","title":"create_image  <code>async</code>","text":"<pre><code>create_image(image: Image) -&gt; Image\n</code></pre> <p>Create a new image in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>Image object with the data to create. Required fields: - title: Image title</p> required <p>Returns:</p> Type Description <code>Image</code> <p>Created Image object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the image data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.update_image","title":"update_image  <code>async</code>","text":"<pre><code>update_image(image: Image) -&gt; Image\n</code></pre> <p>Update an existing image in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>Image object with updated data. Required fields: - id: Image ID to update Any other fields that are set will be updated. Fields that are None will be ignored.</p> required <p>Returns:</p> Type Description <code>Image</code> <p>Updated Image object with any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the image data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.image_destroy","title":"image_destroy  <code>async</code>","text":"<pre><code>image_destroy(\n    input_data: ImageDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete an image.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ImageDestroyInput | dict[str, Any]</code> <p>ImageDestroyInput object or dictionary containing: - id: Image ID to delete (required) - delete_file: Whether to delete the image's file (optional, default: False) - delete_generated: Whether to delete generated files (optional, default: True)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the image was successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the image ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.images_destroy","title":"images_destroy  <code>async</code>","text":"<pre><code>images_destroy(\n    input_data: ImagesDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete multiple images.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ImagesDestroyInput | dict[str, Any]</code> <p>ImagesDestroyInput object or dictionary containing: - ids: List of image IDs to delete (required) - delete_file: Whether to delete the images' files (optional, default: False) - delete_generated: Whether to delete generated files (optional, default: True)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the images were successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any image ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.bulk_image_update","title":"bulk_image_update  <code>async</code>","text":"<pre><code>bulk_image_update(\n    input_data: BulkImageUpdateInput | dict[str, Any],\n) -&gt; list[Image]\n</code></pre> <p>Bulk update images.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>BulkImageUpdateInput | dict[str, Any]</code> <p>BulkImageUpdateInput object or dictionary containing: - ids: List of image IDs to update (optional) - And any fields to update (e.g., organized, rating100, etc.)</p> required <p>Returns:</p> Type Description <code>list[Image]</code> <p>List of updated Image objects</p> <p>Examples:</p> <p>Mark multiple images as organized: <pre><code>images = await client.bulk_image_update({\n    \"ids\": [\"1\", \"2\", \"3\"],\n    \"organized\": True\n})\n</code></pre></p> <p>Add tags to multiple images: <pre><code>from stash_graphql_client.types import BulkImageUpdateInput, BulkUpdateIds\n\ninput_data = BulkImageUpdateInput(\n    ids=[\"1\", \"2\", \"3\"],\n    tag_ids=BulkUpdateIds(ids=[\"tag1\", \"tag2\"], mode=\"ADD\")\n)\nimages = await client.bulk_image_update(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.images_update","title":"images_update  <code>async</code>","text":"<pre><code>images_update(\n    updates: list[ImageUpdateInput] | list[dict[str, Any]],\n) -&gt; list[Image]\n</code></pre> <p>Update multiple images with individual update data.</p> <p>This is different from bulk_image_update which applies the same updates to all images. This method allows updating each image with different values.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[ImageUpdateInput] | list[dict[str, Any]]</code> <p>List of ImageUpdateInput objects or dictionaries, each containing: - id: Image ID to update (required) - Any other fields to update for that specific image</p> required <p>Returns:</p> Type Description <code>list[Image]</code> <p>List of updated Image objects (may contain None for failed updates)</p> <p>Examples:</p> <p>Update multiple images with different values: <pre><code>from stash_graphql_client.types import ImageUpdateInput\n\nupdates = [\n    ImageUpdateInput(id=\"1\", title=\"First Image\", organized=True),\n    ImageUpdateInput(id=\"2\", title=\"Second Image\", rating100=90),\n]\nimages = await client.images_update(updates)\n</code></pre></p> <p>Using dictionaries: <pre><code>updates = [\n    {\"id\": \"1\", \"organized\": True},\n    {\"id\": \"2\", \"rating100\": 75},\n]\nimages = await client.images_update(updates)\n</code></pre></p>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.image_increment_o","title":"image_increment_o  <code>async</code>","text":"<pre><code>image_increment_o(id: str) -&gt; int\n</code></pre> <p>Increment the O-counter for an image.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Image ID</p> required <p>Returns:</p> Type Description <code>int</code> <p>New O-count value after incrementing</p> Example <pre><code>new_count = await client.image_increment_o(\"123\")\nprint(f\"New O-count: {new_count}\")\n</code></pre>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.image_decrement_o","title":"image_decrement_o  <code>async</code>","text":"<pre><code>image_decrement_o(id: str) -&gt; int\n</code></pre> <p>Decrement the O-counter for an image.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Image ID</p> required <p>Returns:</p> Type Description <code>int</code> <p>New O-count value after decrementing</p> Example <pre><code>new_count = await client.image_decrement_o(\"123\")\nprint(f\"New O-count: {new_count}\")\n</code></pre>"},{"location":"api/client/mixins/image/#stash_graphql_client.client.mixins.image.ImageClientMixin.image_reset_o","title":"image_reset_o  <code>async</code>","text":"<pre><code>image_reset_o(id: str) -&gt; int\n</code></pre> <p>Reset the O-counter for an image to 0.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Image ID</p> required <p>Returns:</p> Type Description <code>int</code> <p>New O-count value (0)</p> Example <pre><code>count = await client.image_reset_o(\"123\")\nprint(f\"O-count reset to: {count}\")\n</code></pre>"},{"location":"api/client/mixins/jobs/","title":"Job Operations","text":"<p>Operations for managing background jobs.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for job-related client methods.</p>"},{"location":"api/client/mixins/jobs/#stash_graphql_client.client.mixins.jobs.JobsClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/jobs/#stash_graphql_client.client.mixins.jobs.JobsClientMixin.find_job","title":"find_job  <code>async</code>","text":"<pre><code>find_job(job_id: str) -&gt; Job | None\n</code></pre> <p>Find a job by ID.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Job ID to find</p> required <p>Returns:</p> Type Description <code>Job | None</code> <p>Job object if found, None otherwise</p> <p>Examples:</p> <p>Find a job and check its status: <pre><code>job = await client.find_job(\"123\")\nif job:\n    print(f\"Job status: {job.status}\")\n</code></pre></p>"},{"location":"api/client/mixins/jobs/#stash_graphql_client.client.mixins.jobs.JobsClientMixin.wait_for_job","title":"wait_for_job  <code>async</code>","text":"<pre><code>wait_for_job(\n    job_id: str | int,\n    status: JobStatus = FINISHED,\n    period: float = 1.5,\n    timeout: float = 120.0,\n) -&gt; bool | None\n</code></pre> <p>Wait for a job to reach a specific status.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str | int</code> <p>Job ID to wait for</p> required <code>status</code> <code>JobStatus</code> <p>Status to wait for (default: JobStatus.FINISHED)</p> <code>FINISHED</code> <code>period</code> <code>float</code> <p>Time between checks in seconds (default: 1.5)</p> <code>1.5</code> <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds (default: 120)</p> <code>120.0</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>True if job reached desired status</p> <code>bool | None</code> <p>False if job finished with different status</p> <code>bool | None</code> <p>None if job not found</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If timeout is reached</p> <code>ValueError</code> <p>If job is not found</p>"},{"location":"api/client/mixins/jobs/#stash_graphql_client.client.mixins.jobs.JobsClientMixin.stop_job","title":"stop_job  <code>async</code>","text":"<pre><code>stop_job(job_id: str) -&gt; bool\n</code></pre> <p>Stop a specific job.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Job ID to stop</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if job was stopped successfully, False otherwise</p> <p>Examples:</p> <p>Stop a running job: <pre><code>job_id = await client.metadata_generate(...)\nsuccess = await client.stop_job(job_id)\nif success:\n    print(f\"Job {job_id} stopped\")\n</code></pre></p>"},{"location":"api/client/mixins/jobs/#stash_graphql_client.client.mixins.jobs.JobsClientMixin.stop_all_jobs","title":"stop_all_jobs  <code>async</code>","text":"<pre><code>stop_all_jobs() -&gt; bool\n</code></pre> <p>Stop all running jobs.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all jobs were stopped successfully, False otherwise</p> <p>Examples:</p> <p>Stop all running jobs: <pre><code>success = await client.stop_all_jobs()\nif success:\n    print(\"All jobs stopped\")\n</code></pre></p>"},{"location":"api/client/mixins/jobs/#stash_graphql_client.client.mixins.jobs.JobsClientMixin.job_queue","title":"job_queue  <code>async</code>","text":"<pre><code>job_queue() -&gt; list[Job]\n</code></pre> <p>Get all jobs in the queue.</p> <p>Returns:</p> Type Description <code>list[Job]</code> <p>List of Job objects representing all jobs (running, pending, finished)</p> <p>Examples:</p> <p>Get all jobs: <pre><code>jobs = await client.job_queue()\nfor job in jobs:\n    print(f\"Job {job.id}: {job.status} - {job.description}\")\n</code></pre></p> <p>Filter by status: <pre><code>jobs = await client.job_queue()\nrunning = [j for j in jobs if j.status == JobStatus.RUNNING]\nprint(f\"Running jobs: {len(running)}\")\n</code></pre></p>"},{"location":"api/client/mixins/marker/","title":"Scene Marker Operations","text":"<p>Operations for managing scene markers (bookmarks/chapters).</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for marker-related client methods.</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.find_marker","title":"find_marker  <code>async</code>","text":"<pre><code>find_marker(id: str) -&gt; SceneMarker | None\n</code></pre> <p>Find a scene marker by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the marker to find</p> required <p>Returns:</p> Type Description <code>SceneMarker | None</code> <p>SceneMarker object if found, None otherwise</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.find_markers","title":"find_markers  <code>async</code>","text":"<pre><code>find_markers(\n    filter_: dict[str, Any] | None = None,\n    marker_filter: dict[str, Any] | None = None,\n    q: str | None = None,\n) -&gt; FindSceneMarkersResultType\n</code></pre> <p>Find scene markers matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>marker_filter</code> <code>dict[str, Any] | None</code> <p>Optional marker-specific filter</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <p>Returns:</p> Type Description <code>FindSceneMarkersResultType</code> <p>FindSceneMarkersResultType containing: - count: Total number of matching markers - scene_markers: List of SceneMarker objects</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.create_marker","title":"create_marker  <code>async</code>","text":"<pre><code>create_marker(marker: SceneMarker) -&gt; SceneMarker\n</code></pre> <p>Create a new scene marker in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>SceneMarker</code> <p>SceneMarker object with the data to create. Required fields: - title: Marker title - scene_id: ID of the scene this marker belongs to - seconds: Time in seconds where the marker occurs</p> required <p>Returns:</p> Type Description <code>SceneMarker</code> <p>Created SceneMarker object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marker data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.scene_marker_tags","title":"scene_marker_tags  <code>async</code>","text":"<pre><code>scene_marker_tags(scene_id: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>Get scene marker tags for a scene.</p> <p>Parameters:</p> Name Type Description Default <code>scene_id</code> <code>str</code> <p>Scene ID</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of scene marker tags, each containing: - tag: Tag object - scene_markers: List of SceneMarker objects</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.update_marker","title":"update_marker  <code>async</code>","text":"<pre><code>update_marker(marker: SceneMarker) -&gt; SceneMarker\n</code></pre> <p>Update an existing scene marker in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>marker</code> <code>SceneMarker</code> <p>SceneMarker object with updated data. Required fields: - id: Marker ID to update Any other fields that are set will be updated. Fields that are None will be ignored.</p> required <p>Returns:</p> Type Description <code>SceneMarker</code> <p>Updated SceneMarker object with any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the marker data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.scene_marker_destroy","title":"scene_marker_destroy  <code>async</code>","text":"<pre><code>scene_marker_destroy(id: str) -&gt; bool\n</code></pre> <p>Delete a scene marker.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene marker ID to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the scene marker was successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the scene marker ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.scene_markers_destroy","title":"scene_markers_destroy  <code>async</code>","text":"<pre><code>scene_markers_destroy(ids: list[str]) -&gt; bool\n</code></pre> <p>Delete multiple scene markers.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of scene marker IDs to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the scene markers were successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any scene marker ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.bulk_scene_marker_update","title":"bulk_scene_marker_update  <code>async</code>","text":"<pre><code>bulk_scene_marker_update(\n    input_data: BulkSceneMarkerUpdateInput | dict[str, Any],\n) -&gt; list[SceneMarker]\n</code></pre> <p>Bulk update scene markers.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>BulkSceneMarkerUpdateInput | dict[str, Any]</code> <p>BulkSceneMarkerUpdateInput object or dictionary containing: - ids: List of scene marker IDs to update (optional) - And any fields to update (e.g., primary_tag_id, tag_ids, etc.)</p> required <p>Returns:</p> Type Description <code>list[SceneMarker]</code> <p>List of updated SceneMarker objects</p> <p>Examples:</p> <p>Update multiple markers' primary tag: <pre><code>markers = await client.bulk_scene_marker_update({\n    \"ids\": [\"1\", \"2\", \"3\"],\n    \"primary_tag_id\": \"tag123\"\n})\n</code></pre></p> <p>Add tags to multiple markers: <pre><code>from stash_graphql_client.types import BulkSceneMarkerUpdateInput, BulkUpdateIds\n\ninput_data = BulkSceneMarkerUpdateInput(\n    ids=[\"1\", \"2\", \"3\"],\n    tag_ids=BulkUpdateIds(ids=[\"tag1\", \"tag2\"], mode=\"ADD\")\n)\nmarkers = await client.bulk_scene_marker_update(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.marker_wall","title":"marker_wall  <code>async</code>","text":"<pre><code>marker_wall(q: str | None = None) -&gt; list[SceneMarker]\n</code></pre> <p>Get marker wall - random markers for display.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>str | None</code> <p>Optional search query to filter markers</p> <code>None</code> <p>Returns:</p> Type Description <code>list[SceneMarker]</code> <p>List of SceneMarker objects selected for wall display</p> <p>Examples:</p> <p>Get all wall markers: <pre><code>markers = await client.marker_wall()\nprint(f\"Found {len(markers)} markers for wall\")\n</code></pre></p> <p>Search wall markers: <pre><code>markers = await client.marker_wall(q=\"interview\")\n</code></pre></p>"},{"location":"api/client/mixins/marker/#stash_graphql_client.client.mixins.marker.MarkerClientMixin.marker_strings","title":"marker_strings  <code>async</code>","text":"<pre><code>marker_strings(\n    q: str | None = None, sort: str | None = None\n) -&gt; list[MarkerStringsResultType]\n</code></pre> <p>Get marker title strings with counts.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>str | None</code> <p>Optional search query to filter marker titles</p> <code>None</code> <code>sort</code> <code>str | None</code> <p>Optional sort order for results</p> <code>None</code> <p>Returns:</p> Type Description <code>list[MarkerStringsResultType]</code> <p>List of MarkerStringsResultType objects containing: - id: Marker title ID - title: Marker title string - count: Number of markers with this title</p> <p>Examples:</p> <p>Get all marker title strings: <pre><code>strings = await client.marker_strings()\nfor s in strings:\n    print(f\"{s.title}: {s.count} markers\")\n</code></pre></p> <p>Search and sort marker strings: <pre><code>strings = await client.marker_strings(q=\"bj\", sort=\"count\")\n</code></pre></p>"},{"location":"api/client/mixins/metadata/","title":"Metadata Operations","text":"<p>Operations for scanning, generating, and managing metadata.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for metadata and database operation methods.</p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_generate","title":"metadata_generate  <code>async</code>","text":"<pre><code>metadata_generate(\n    options: GenerateMetadataOptions\n    | dict[str, Any]\n    | None = None,\n    input_data: GenerateMetadataInput\n    | dict[str, Any]\n    | None = None,\n) -&gt; str\n</code></pre> <p>Generate metadata.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>GenerateMetadataOptions | dict[str, Any] | None</code> <p>GenerateMetadataOptions object or dictionary of what to generate: - covers: bool - Generate covers - sprites: bool - Generate sprites - previews: bool - Generate previews - imagePreviews: bool - Generate image previews - previewOptions: GeneratePreviewOptionsInput     - previewSegments: int - Number of segments in a preview file     - previewSegmentDuration: float - Duration of each segment in seconds     - previewExcludeStart: str - Duration to exclude from start     - previewExcludeEnd: str - Duration to exclude from end     - previewPreset: PreviewPreset - Preset when generating preview - markers: bool - Generate markers - markerImagePreviews: bool - Generate marker image previews - markerScreenshots: bool - Generate marker screenshots - transcodes: bool - Generate transcodes - forceTranscodes: bool - Generate transcodes even if not required - phashes: bool - Generate phashes - interactiveHeatmapsSpeeds: bool - Generate interactive heatmaps speeds - imageThumbnails: bool - Generate image thumbnails - clipPreviews: bool - Generate clip previews</p> <code>None</code> <code>input_data</code> <code>GenerateMetadataInput | dict[str, Any] | None</code> <p>Optional GenerateMetadataInput object or dictionary to specify what to process: - sceneIDs: list[str] - List of scene IDs to generate for (default: all) - markerIDs: list[str] - List of marker IDs to generate for (default: all) - overwrite: bool - Overwrite existing media (default: False)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the generation task</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_scan","title":"metadata_scan  <code>async</code>","text":"<pre><code>metadata_scan(\n    paths: list[str] | None = None,\n    flags: dict[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Start a metadata scan job.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list[str] | None</code> <p>List of paths to scan (None = all paths)</p> <code>None</code> <code>flags</code> <code>dict[str, Any] | None</code> <p>Dict of scan flags to override defaults (rescan, scanGenerateCovers, etc.)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the scan operation</p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.get_configuration_defaults","title":"get_configuration_defaults  <code>async</code>","text":"<pre><code>get_configuration_defaults() -&gt; ConfigDefaultSettingsResult\n</code></pre> <p>Get default configuration settings.</p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_clean","title":"metadata_clean  <code>async</code>","text":"<pre><code>metadata_clean(\n    input_data: CleanMetadataInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Clean metadata and remove orphaned database entries.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>CleanMetadataInput | dict[str, Any]</code> <p>CleanMetadataInput object or dictionary containing: - paths: List of paths to clean (optional) - dry_run: Whether to perform a dry run (optional, default: False)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the clean operation</p> <p>Examples:</p> <p>Clean all metadata: <pre><code>job_id = await client.metadata_clean({\"dry_run\": False})\nprint(f\"Clean job started: {job_id}\")\n</code></pre></p> <p>Dry run to see what would be cleaned: <pre><code>job_id = await client.metadata_clean({\"dry_run\": True})\n</code></pre></p> <p>Clean specific paths: <pre><code>from stash_graphql_client.types import CleanMetadataInput\n\ninput_data = CleanMetadataInput(\n    paths=[\"/path/to/clean\"],\n    dry_run=False\n)\njob_id = await client.metadata_clean(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_clean_generated","title":"metadata_clean_generated  <code>async</code>","text":"<pre><code>metadata_clean_generated(\n    input_data: CleanGeneratedInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Clean generated files (sprites, previews, screenshots, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>CleanGeneratedInput | dict[str, Any]</code> <p>CleanGeneratedInput object or dictionary containing: - blobFiles: Clean blob files (optional) - dryRun: Whether to perform a dry run (optional, default: False) - imageThumbnails: Clean image thumbnails (optional) - markers: Clean marker files (optional) - screenshots: Clean screenshot files (optional) - sprites: Clean sprite files (optional) - transcodes: Clean transcode files (optional)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the clean operation</p> <p>Examples:</p> <p>Clean all generated files: <pre><code>job_id = await client.metadata_clean_generated({\n    \"blobFiles\": True,\n    \"imageThumbnails\": True,\n    \"markers\": True,\n    \"screenshots\": True,\n    \"sprites\": True,\n    \"transcodes\": True,\n    \"dryRun\": False\n})\n</code></pre></p> <p>Dry run to see what would be cleaned: <pre><code>job_id = await client.metadata_clean_generated({\"dryRun\": True})\n</code></pre></p> <p>Clean only specific types: <pre><code>from stash_graphql_client.types import CleanGeneratedInput\n\ninput_data = CleanGeneratedInput(\n    sprites=True,\n    screenshots=True,\n    dryRun=False\n)\njob_id = await client.metadata_clean_generated(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_auto_tag","title":"metadata_auto_tag  <code>async</code>","text":"<pre><code>metadata_auto_tag(\n    input_data: AutoTagMetadataInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Start auto-tagging metadata task.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>AutoTagMetadataInput | dict[str, Any]</code> <p>AutoTagMetadataInput object or dictionary containing: - paths: List of paths to tag, None for all files (optional) - performers: List of performer IDs to tag with, or [\"\"] for all (optional) - studios: List of studio IDs to tag with, or [\"\"] for all (optional) - tags: List of tag IDs to tag with, or [\"*\"] for all (optional)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the auto-tagging task</p> <p>Examples:</p> <p>Auto-tag all files with all performers: <pre><code>job_id = await client.metadata_auto_tag({\n    \"performers\": [\"*\"]\n})\nprint(f\"Auto-tag job started: {job_id}\")\n</code></pre></p> <p>Auto-tag specific paths with specific performers: <pre><code>from stash_graphql_client.types import AutoTagMetadataInput\n\ninput_data = AutoTagMetadataInput(\n    paths=[\"/path/to/videos\"],\n    performers=[\"1\", \"2\", \"3\"],\n    studios=[\"*\"],\n    tags=None\n)\njob_id = await client.metadata_auto_tag(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_identify","title":"metadata_identify  <code>async</code>","text":"<pre><code>metadata_identify(\n    input_data: IdentifyMetadataInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Start metadata identification task using scrapers.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>IdentifyMetadataInput | dict[str, Any]</code> <p>IdentifyMetadataInput object or dictionary containing: - sources: List of scraper sources to use (required) - options: Identification options (optional) - sceneIDs: List of scene IDs to identify (optional) - paths: List of scene paths to identify (optional, ignored if sceneIDs set)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the identification task</p> <p>Examples:</p> <p>Identify scenes using a stash-box endpoint: <pre><code>job_id = await client.metadata_identify({\n    \"sources\": [\n        {\n            \"source\": {\n                \"stashBoxEndpoint\": \"https://stashdb.org/graphql\"\n            }\n        }\n    ],\n    \"sceneIDs\": [\"1\", \"2\", \"3\"]\n})\nprint(f\"Identify job started: {job_id}\")\n</code></pre></p> <p>Identify with custom options: <pre><code>from stash_graphql_client.types import (\n    IdentifyMetadataInput,\n    IdentifySourceInput,\n    ScraperSourceInput,\n    IdentifyMetadataOptionsInput\n)\n\ninput_data = IdentifyMetadataInput(\n    sources=[\n        IdentifySourceInput(\n            source=ScraperSourceInput(\n                stashBoxEndpoint=\"https://stashdb.org/graphql\"\n            ),\n            options=IdentifyMetadataOptionsInput(\n                setCoverImage=True,\n                includeMalePerformers=False\n            )\n        )\n    ],\n    paths=[\"/path/to/scenes\"]\n)\njob_id = await client.metadata_identify(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_import","title":"metadata_import  <code>async</code>","text":"<pre><code>metadata_import() -&gt; str\n</code></pre> <p>Start full metadata import from metadata directory.</p> <p>This operation completely wipes the database and imports from the metadata directory. Use with caution.</p> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the import task</p> <p>Examples:</p> <p>Start full metadata import: <pre><code>job_id = await client.metadata_import()\nprint(f\"Import job started: {job_id}\")\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.metadata_export","title":"metadata_export  <code>async</code>","text":"<pre><code>metadata_export() -&gt; str\n</code></pre> <p>Start full metadata export to metadata directory.</p> <p>Exports the entire database to the configured metadata directory.</p> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the export task</p> <p>Examples:</p> <p>Start full metadata export: <pre><code>job_id = await client.metadata_export()\nprint(f\"Export job started: {job_id}\")\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.export_objects","title":"export_objects  <code>async</code>","text":"<pre><code>export_objects(\n    input_data: ExportObjectsInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Export objects to a downloadable file.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ExportObjectsInput | dict[str, Any]</code> <p>ExportObjectsInput object or dictionary containing: - ids: List of object IDs to export (optional) - all: Export all objects (optional, default: False) - type: Object type to export (required) - format: Export format (optional)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Download token for the exported file</p> <p>Examples:</p> <p>Export all scenes: <pre><code>token = await client.export_objects({\n    \"all\": True,\n    \"type\": \"SCENE\"\n})\ndownload_url = f\"{client.url}/downloads/{token}\"\n</code></pre></p> <p>Export specific performers: <pre><code>from stash_graphql_client.types import ExportObjectsInput\n\ninput_data = ExportObjectsInput(\n    ids=[\"1\", \"2\", \"3\"],\n    type=\"PERFORMER\"\n)\ntoken = await client.export_objects(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.import_objects","title":"import_objects  <code>async</code>","text":"<pre><code>import_objects(\n    input_data: ImportObjectsInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Import objects from a file.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ImportObjectsInput | dict[str, Any]</code> <p>ImportObjectsInput object or dictionary containing: - file: File to import from (required) - duplicateBehaviour: How to handle duplicates (optional) - missingRefBehaviour: How to handle missing references (optional)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Import job ID</p> <p>Examples:</p> <p>Import from file: <pre><code>job_id = await client.import_objects({\n    \"file\": \"/path/to/export.json\"\n})\nprint(f\"Import job started: {job_id}\")\n</code></pre></p> <p>Import with duplicate handling: <pre><code>from stash_graphql_client.types import ImportObjectsInput\n\ninput_data = ImportObjectsInput(\n    file=\"/path/to/export.json\",\n    duplicateBehaviour=\"IGNORE\"\n)\njob_id = await client.import_objects(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.backup_database","title":"backup_database  <code>async</code>","text":"<pre><code>backup_database(\n    input_data: BackupDatabaseInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Create a database backup.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>BackupDatabaseInput | dict[str, Any]</code> <p>BackupDatabaseInput object or dictionary containing: - download: Whether to download the backup (optional, default: True)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Backup file path or download token</p> <p>Examples:</p> <p>Create and download backup: <pre><code>token = await client.backup_database({\"download\": True})\ndownload_url = f\"{client.url}/downloads/{token}\"\n</code></pre></p> <p>Create backup without downloading: <pre><code>from stash_graphql_client.types import BackupDatabaseInput\n\ninput_data = BackupDatabaseInput(download=False)\npath = await client.backup_database(input_data)\nprint(f\"Backup created at: {path}\")\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.anonymise_database","title":"anonymise_database  <code>async</code>","text":"<pre><code>anonymise_database(\n    input_data: AnonymiseDatabaseInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Anonymise the database by removing identifying information.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>AnonymiseDatabaseInput | dict[str, Any]</code> <p>AnonymiseDatabaseInput object or dictionary containing: - download: Whether to download the anonymised backup (optional, default: True)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Anonymised backup file path or download token</p> <p>Examples:</p> <p>Anonymise and download: <pre><code>token = await client.anonymise_database({\"download\": True})\ndownload_url = f\"{client.url}/downloads/{token}\"\n</code></pre></p> <p>Anonymise without downloading: <pre><code>from stash_graphql_client.types import AnonymiseDatabaseInput\n\ninput_data = AnonymiseDatabaseInput(download=False)\npath = await client.anonymise_database(input_data)\nprint(f\"Anonymised backup created at: {path}\")\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.migrate","title":"migrate  <code>async</code>","text":"<pre><code>migrate(input_data: MigrateInput | dict[str, Any]) -&gt; str\n</code></pre> <p>Migrate database to the latest schema version.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>MigrateInput | dict[str, Any]</code> <p>MigrateInput object or dictionary containing: - backupPath: Path to create backup before migration (required)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Migration job ID</p> <p>Examples:</p> <p>Migrate database with backup: <pre><code>job_id = await client.migrate({\"backupPath\": \"/path/to/backup.db\"})\nprint(f\"Migration job started: {job_id}\")\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import MigrateInput\n\ninput_data = MigrateInput(backupPath=\"/path/to/backup.db\")\njob_id = await client.migrate(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.migrate_hash_naming","title":"migrate_hash_naming  <code>async</code>","text":"<pre><code>migrate_hash_naming() -&gt; str\n</code></pre> <p>Migrate hash naming scheme to the latest version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Migration job ID</p> <p>Examples:</p> <p>Migrate hash naming: <pre><code>job_id = await client.migrate_hash_naming()\nprint(f\"Hash naming migration started: {job_id}\")\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.migrate_scene_screenshots","title":"migrate_scene_screenshots  <code>async</code>","text":"<pre><code>migrate_scene_screenshots(\n    input_data: MigrateSceneScreenshotsInput\n    | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Migrate scene screenshots to the latest storage format.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>MigrateSceneScreenshotsInput | dict[str, Any]</code> <p>MigrateSceneScreenshotsInput object or dictionary containing: - deleteFiles: Delete old screenshot files (optional) - overwriteExisting: Overwrite existing screenshots (optional)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Migration job ID</p> <p>Examples:</p> <p>Migrate screenshots and delete old files: <pre><code>job_id = await client.migrate_scene_screenshots({\n    \"deleteFiles\": True,\n    \"overwriteExisting\": False\n})\nprint(f\"Screenshot migration started: {job_id}\")\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import MigrateSceneScreenshotsInput\n\ninput_data = MigrateSceneScreenshotsInput(\n    deleteFiles=True,\n    overwriteExisting=True\n)\njob_id = await client.migrate_scene_screenshots(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.migrate_blobs","title":"migrate_blobs  <code>async</code>","text":"<pre><code>migrate_blobs(\n    input_data: MigrateBlobsInput | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Migrate blobs to the latest storage format.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>MigrateBlobsInput | dict[str, Any]</code> <p>MigrateBlobsInput object or dictionary containing: - deleteOld: Delete old blob files after migration (optional)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Migration job ID</p> <p>Examples:</p> <p>Migrate blobs and keep old files: <pre><code>job_id = await client.migrate_blobs({\"deleteOld\": False})\nprint(f\"Blob migration started: {job_id}\")\n</code></pre></p> <p>Using the input type: <pre><code>from stash_graphql_client.types import MigrateBlobsInput\n\ninput_data = MigrateBlobsInput(deleteOld=True)\njob_id = await client.migrate_blobs(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.optimise_database","title":"optimise_database  <code>async</code>","text":"<pre><code>optimise_database() -&gt; str\n</code></pre> <p>Optimize the database.</p> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the optimization task</p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.setup","title":"setup  <code>async</code>","text":"<pre><code>setup(input_data: SetupInput | dict[str, Any]) -&gt; bool\n</code></pre> <p>Run initial Stash setup.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>SetupInput | dict[str, Any]</code> <p>SetupInput object or dictionary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/metadata/#stash_graphql_client.client.mixins.metadata.MetadataClientMixin.download_ffmpeg","title":"download_ffmpeg  <code>async</code>","text":"<pre><code>download_ffmpeg() -&gt; str\n</code></pre> <p>Download FFmpeg binary.</p> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the download task</p>"},{"location":"api/client/mixins/package/","title":"Package Operations","text":"<p>Operations for managing Stash packages.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for package-related client methods.</p>"},{"location":"api/client/mixins/package/#stash_graphql_client.client.mixins.package.PackageClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/package/#stash_graphql_client.client.mixins.package.PackageClientMixin.install_packages","title":"install_packages  <code>async</code>","text":"<pre><code>install_packages(\n    package_type: PackageType | str,\n    packages: list[PackageSpecInput] | list[dict[str, Any]],\n) -&gt; str\n</code></pre> <p>Install packages.</p> <p>Parameters:</p> Name Type Description Default <code>package_type</code> <code>PackageType | str</code> <p>Type of packages to install (PackageType.SCRAPER or PackageType.PLUGIN)</p> required <code>packages</code> <code>list[PackageSpecInput] | list[dict[str, Any]]</code> <p>List of PackageSpecInput objects or dictionaries containing: - id: Package ID (required) - sourceURL: Source URL for the package (required)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the installation task</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Install a scraper package: <pre><code>from stash_graphql_client.types import PackageType, PackageSpecInput\n\npackages = [\n    PackageSpecInput(id=\"package-id\", source_url=\"https://example.com/package.yml\")\n]\njob_id = await client.install_packages(PackageType.SCRAPER, packages)\nprint(f\"Installation job started: {job_id}\")\n</code></pre></p> <p>Install multiple plugin packages using dictionaries: <pre><code>packages = [\n    {\"id\": \"plugin-1\", \"sourceURL\": \"https://example.com/plugin1.yml\"},\n    {\"id\": \"plugin-2\", \"sourceURL\": \"https://example.com/plugin2.yml\"}\n]\njob_id = await client.install_packages(\"Plugin\", packages)\n</code></pre></p>"},{"location":"api/client/mixins/package/#stash_graphql_client.client.mixins.package.PackageClientMixin.update_packages","title":"update_packages  <code>async</code>","text":"<pre><code>update_packages(\n    package_type: PackageType | str,\n    packages: list[PackageSpecInput]\n    | list[dict[str, Any]]\n    | None = None,\n) -&gt; str\n</code></pre> <p>Update packages.</p> <p>Parameters:</p> Name Type Description Default <code>package_type</code> <code>PackageType | str</code> <p>Type of packages to update (PackageType.SCRAPER or PackageType.PLUGIN)</p> required <code>packages</code> <code>list[PackageSpecInput] | list[dict[str, Any]] | None</code> <p>Optional list of PackageSpecInput objects or dictionaries containing: - id: Package ID (required) - sourceURL: Source URL for the package (required) If None, all packages of the given type will be updated.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the update task</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Update all scraper packages: <pre><code>from stash_graphql_client.types import PackageType\n\njob_id = await client.update_packages(PackageType.SCRAPER)\nprint(f\"Update job started: {job_id}\")\n</code></pre></p> <p>Update specific plugin packages: <pre><code>from stash_graphql_client.types import PackageType, PackageSpecInput\n\npackages = [\n    PackageSpecInput(id=\"plugin-id\", source_url=\"https://example.com/plugin.yml\")\n]\njob_id = await client.update_packages(PackageType.PLUGIN, packages)\n</code></pre></p> <p>Update using dictionaries: <pre><code>packages = [\n    {\"id\": \"scraper-1\", \"sourceURL\": \"https://example.com/scraper1.yml\"}\n]\njob_id = await client.update_packages(\"Scraper\", packages)\n</code></pre></p>"},{"location":"api/client/mixins/package/#stash_graphql_client.client.mixins.package.PackageClientMixin.uninstall_packages","title":"uninstall_packages  <code>async</code>","text":"<pre><code>uninstall_packages(\n    package_type: PackageType | str,\n    packages: list[PackageSpecInput] | list[dict[str, Any]],\n) -&gt; str\n</code></pre> <p>Uninstall packages.</p> <p>Parameters:</p> Name Type Description Default <code>package_type</code> <code>PackageType | str</code> <p>Type of packages to uninstall (PackageType.SCRAPER or PackageType.PLUGIN)</p> required <code>packages</code> <code>list[PackageSpecInput] | list[dict[str, Any]]</code> <p>List of PackageSpecInput objects or dictionaries containing: - id: Package ID (required) - sourceURL: Source URL for the package (required)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the uninstallation task</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Uninstall a scraper package: <pre><code>from stash_graphql_client.types import PackageType, PackageSpecInput\n\npackages = [\n    PackageSpecInput(id=\"package-id\", source_url=\"https://example.com/package.yml\")\n]\njob_id = await client.uninstall_packages(PackageType.SCRAPER, packages)\nprint(f\"Uninstallation job started: {job_id}\")\n</code></pre></p> <p>Uninstall multiple plugin packages using dictionaries: <pre><code>packages = [\n    {\"id\": \"plugin-1\", \"sourceURL\": \"https://example.com/plugin1.yml\"},\n    {\"id\": \"plugin-2\", \"sourceURL\": \"https://example.com/plugin2.yml\"}\n]\njob_id = await client.uninstall_packages(\"Plugin\", packages)\n</code></pre></p>"},{"location":"api/client/mixins/package/#stash_graphql_client.client.mixins.package.PackageClientMixin.installed_packages","title":"installed_packages  <code>async</code>","text":"<pre><code>installed_packages(\n    package_type: PackageType | str,\n) -&gt; list[Package]\n</code></pre> <p>List installed packages.</p> <p>Parameters:</p> Name Type Description Default <code>package_type</code> <code>PackageType | str</code> <p>Type of packages to list (PackageType.SCRAPER or PackageType.PLUGIN)</p> required <p>Returns:</p> Type Description <code>list[Package]</code> <p>List of Package objects representing installed packages</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>List all installed scrapers: <pre><code>from stash_graphql_client.types import PackageType\n\npackages = await client.installed_packages(PackageType.SCRAPER)\nfor pkg in packages:\n    print(f\"{pkg.name} v{pkg.version} - {pkg.package_id}\")\n</code></pre></p> <p>List all installed plugins: <pre><code>packages = await client.installed_packages(\"Plugin\")\nprint(f\"Found {len(packages)} installed plugins\")\n</code></pre></p>"},{"location":"api/client/mixins/package/#stash_graphql_client.client.mixins.package.PackageClientMixin.available_packages","title":"available_packages  <code>async</code>","text":"<pre><code>available_packages(\n    package_type: PackageType | str, source: str\n) -&gt; list[Package]\n</code></pre> <p>List available packages from a source.</p> <p>Parameters:</p> Name Type Description Default <code>package_type</code> <code>PackageType | str</code> <p>Type of packages to list (PackageType.SCRAPER or PackageType.PLUGIN)</p> required <code>source</code> <code>str</code> <p>Source URL to query for available packages</p> required <p>Returns:</p> Type Description <code>list[Package]</code> <p>List of Package objects representing available packages</p> <p>Raises:</p> Type Description <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>List available scrapers from official source: <pre><code>from stash_graphql_client.types import PackageType\n\npackages = await client.available_packages(\n    PackageType.SCRAPER,\n    \"https://stashapp.github.io/scrapers\"\n)\nfor pkg in packages:\n    print(f\"{pkg.name} v{pkg.version} - {pkg.package_id}\")\n</code></pre></p> <p>List available plugins: <pre><code>packages = await client.available_packages(\n    \"Plugin\",\n    \"https://stashapp.github.io/plugins\"\n)\nprint(f\"Found {len(packages)} available plugins\")\n</code></pre></p>"},{"location":"api/client/mixins/performer/","title":"Performer Operations","text":"<p>Operations for managing performers (actors/models).</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for performer-related client methods.</p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.find_performer","title":"find_performer  <code>async</code>","text":"<pre><code>find_performer(\n    performer: int | str | dict,\n) -&gt; Performer | None\n</code></pre> <p>Find a performer by ID, name, or filter.</p> <p>Parameters:</p> Name Type Description Default <code>performer</code> <code>int | str | dict</code> <p>Can be: - ID (int/str): Find by ID - Name (str): Find by name - Dict: Find by filter criteria</p> required <p>Returns:</p> Type Description <code>Performer | None</code> <p>Performer object if found, None otherwise</p> <p>Examples:</p> <p>Find by ID: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    print(f\"Found performer: {performer.name}\")\n</code></pre></p> <p>Find by name: <pre><code>performer = await client.find_performer(\"Performer Name\")\nif performer:\n    print(f\"Found performer with ID: {performer.id}\")\n</code></pre></p> <p>Find by filter: <pre><code>performer = await client.find_performer({\n    \"name\": \"Performer Name\",\n    \"disambiguation\": \"2000s\"\n})\n</code></pre></p> <p>Access performer relationships: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    # Get scene titles\n    scene_titles = [s.title for s in performer.scenes]\n    # Get studio name\n    studio_name = performer.studio.name if performer.studio else None\n    # Get tag names\n    tags = [t.name for t in performer.tags]\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.find_performers","title":"find_performers  <code>async</code>","text":"<pre><code>find_performers(\n    filter_: dict[str, Any] | None = None,\n    performer_filter: dict[str, Any] | None = None,\n    q: str | None = None,\n) -&gt; FindPerformersResultType\n</code></pre> <p>Find performers matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <code>performer_filter</code> <code>dict[str, Any] | None</code> <p>Optional performer-specific filter: - birth_year: IntCriterionInput - age: IntCriterionInput - ethnicity: StringCriterionInput - country: StringCriterionInput - eye_color: StringCriterionInput - height: StringCriterionInput - measurements: StringCriterionInput - fake_tits: StringCriterionInput - career_length: StringCriterionInput - tattoos: StringCriterionInput - piercings: StringCriterionInput - favorite: bool - rating100: IntCriterionInput - gender: GenderEnum - is_missing: str (what data is missing) - name: StringCriterionInput - studios: HierarchicalMultiCriterionInput - tags: HierarchicalMultiCriterionInput</p> <code>None</code> <p>Returns:</p> Type Description <code>FindPerformersResultType</code> <p>FindPerformersResultType containing: - count: Total number of matching performers - performers: List of Performer objects</p> <p>Examples:</p> <p>Find all favorite performers: <pre><code>result = await client.find_performers(\n    performer_filter={\"favorite\": True}\n)\nprint(f\"Found {result.count} favorite performers\")\nfor performer in result.performers:\n    print(f\"- {performer.name}\")\n</code></pre></p> <p>Find performers with specific tags: <pre><code>result = await client.find_performers(\n    performer_filter={\n        \"tags\": {\n            \"value\": [\"tag1\", \"tag2\"],\n            \"modifier\": \"INCLUDES_ALL\"\n        }\n    }\n)\n</code></pre></p> <p>Find performers with high rating and sort by name: <pre><code>result = await client.find_performers(\n    filter_={\n        \"direction\": \"ASC\",\n        \"sort\": \"name\",\n    },\n    performer_filter={\n        \"rating100\": {\n            \"value\": 80,\n            \"modifier\": \"GREATER_THAN\"\n        }\n    }\n)\n</code></pre></p> <p>Paginate results: <pre><code>result = await client.find_performers(\n    filter_={\n        \"page\": 1,\n        \"per_page\": 25,\n    }\n)\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.create_performer","title":"create_performer  <code>async</code>","text":"<pre><code>create_performer(performer: Performer) -&gt; Performer\n</code></pre> <p>Create a new performer in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>performer</code> <code>Performer</code> <p>Performer object with the data to create. Required fields: - name: Performer name</p> required <p>Returns:</p> Type Description <code>Performer</code> <p>Created Performer object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the performer data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Create a basic performer: <pre><code>performer = Performer(\n    name=\"Performer Name\",\n)\ncreated = await client.create_performer(performer)\nprint(f\"Created performer with ID: {created.id}\")\n</code></pre></p> <p>Create performer with metadata: <pre><code>performer = Performer(\n    name=\"Performer Name\",\n    # Add metadata\n    gender=\"FEMALE\",\n    birthdate=\"1990-01-01\",\n    ethnicity=\"Caucasian\",\n    country=\"USA\",\n    eye_color=\"Blue\",\n    height_cm=170,\n    measurements=\"34B-24-36\",\n    fake_tits=\"No\",\n    career_length=\"2010-2020\",\n    tattoos=\"None\",\n    piercings=\"Ears\",\n    url=\"https://example.com/performer\",\n    twitter=\"@performer\",\n    instagram=\"@performer\",\n    details=\"Performer details\",\n)\ncreated = await client.create_performer(performer)\n</code></pre></p> <p>Create performer with relationships: <pre><code>performer = Performer(\n    name=\"Performer Name\",\n    # Add relationships\n    tags=[tag1, tag2],\n    image=\"https://example.com/image.jpg\",\n    stash_ids=[stash_id1, stash_id2],\n)\ncreated = await client.create_performer(performer)\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.update_performer","title":"update_performer  <code>async</code>","text":"<pre><code>update_performer(performer: Performer) -&gt; Performer\n</code></pre> <p>Update an existing performer in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>performer</code> <code>Performer</code> <p>Performer object with updated data. Required fields: - id: Performer ID to update Any other fields that are set will be updated. Fields that are None will be ignored.</p> required <p>Returns:</p> Type Description <code>Performer</code> <p>Updated Performer object with any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the performer data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Update performer name and metadata: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    performer.name = \"New Name\"\n    performer.gender = \"FEMALE\"\n    performer.birthdate = \"1990-01-01\"\n    updated = await client.update_performer(performer)\n    print(f\"Updated performer: {updated.name}\")\n</code></pre></p> <p>Update performer relationships: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    # Add new tags\n    performer.tags.extend([new_tag1, new_tag2])\n    # Update image\n    performer.image = \"https://example.com/new-image.jpg\"\n    updated = await client.update_performer(performer)\n</code></pre></p> <p>Update performer URLs: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    # Replace URLs\n    performer.url = \"https://example.com/new-url\"\n    performer.twitter = \"@new_twitter\"\n    performer.instagram = \"@new_instagram\"\n    updated = await client.update_performer(performer)\n</code></pre></p> <p>Remove performer relationships: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    # Clear tags\n    performer.tags = []\n    # Clear image\n    performer.image = None\n    updated = await client.update_performer(performer)\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.update_performer_image","title":"update_performer_image  <code>async</code>","text":"<pre><code>update_performer_image(\n    performer: Performer, image_url: str\n) -&gt; Performer\n</code></pre> <p>Update a performer's image.</p> <p>Parameters:</p> Name Type Description Default <code>performer</code> <code>Performer</code> <p>Performer object with at least the ID set</p> required <code>image_url</code> <code>str</code> <p>URL or data URI of the image to set</p> required <p>Returns:</p> Type Description <code>Performer</code> <p>Updated Performer object with the new image</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the performer data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Update performer image with a data URI: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    # Update with data URI\n    image_url = \"data:image/jpeg;base64,...\"\n    updated = await client.update_performer_image(performer, image_url)\n</code></pre></p> <p>Update performer image from a file: <pre><code>performer = await client.find_performer(\"123\")\nif performer:\n    # Use the performer's update_avatar method\n    updated = await performer.update_avatar(client, \"/path/to/image.jpg\")\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.performer_destroy","title":"performer_destroy  <code>async</code>","text":"<pre><code>performer_destroy(\n    input_data: PerformerDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete a performer.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>PerformerDestroyInput | dict[str, Any]</code> <p>PerformerDestroyInput object or dictionary containing: - id: Performer ID to delete (required)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the performer was successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the performer ID is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Delete a performer: <pre><code>result = await client.performer_destroy({\"id\": \"123\"})\nprint(f\"Performer deleted: {result}\")\n</code></pre></p> <p>Using the input type: <pre><code>from ...types import PerformerDestroyInput\n\ninput_data = PerformerDestroyInput(id=\"123\")\nresult = await client.performer_destroy(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.performers_destroy","title":"performers_destroy  <code>async</code>","text":"<pre><code>performers_destroy(ids: list[str]) -&gt; bool\n</code></pre> <p>Delete multiple performers.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of performer IDs to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the performers were successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any performer ID is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Delete multiple performers: <pre><code>result = await client.performers_destroy([\"123\", \"456\", \"789\"])\nprint(f\"Performers deleted: {result}\")\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.all_performers","title":"all_performers  <code>async</code>","text":"<pre><code>all_performers() -&gt; list[Performer]\n</code></pre> <p>Get all performers.</p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.bulk_performer_update","title":"bulk_performer_update  <code>async</code>","text":"<pre><code>bulk_performer_update(\n    input_data: BulkPerformerUpdateInput | dict[str, Any],\n) -&gt; list[Performer]\n</code></pre> <p>Bulk update performers.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>BulkPerformerUpdateInput | dict[str, Any]</code> <p>BulkPerformerUpdateInput object or dictionary containing: - ids: List of performer IDs to update (optional) - And any fields to update (e.g., gender, birthdate, tags, etc.)</p> required <p>Returns:</p> Type Description <code>list[Performer]</code> <p>List of updated Performer objects</p> <p>Examples:</p> <p>Update multiple performers' gender: <pre><code>performers = await client.bulk_performer_update({\n    \"ids\": [\"1\", \"2\", \"3\"],\n    \"gender\": \"FEMALE\"\n})\n</code></pre></p> <p>Add tags to multiple performers: <pre><code>from stash_graphql_client.types import BulkPerformerUpdateInput, BulkUpdateIds\n\ninput_data = BulkPerformerUpdateInput(\n    ids=[\"1\", \"2\", \"3\"],\n    tag_ids=BulkUpdateIds(ids=[\"tag1\", \"tag2\"], mode=\"ADD\")\n)\nperformers = await client.bulk_performer_update(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.performer_merge","title":"performer_merge  <code>async</code>","text":"<pre><code>performer_merge(\n    input_data: PerformerMergeInput | dict[str, Any],\n) -&gt; Performer\n</code></pre> <p>Merge performers into a single performer.</p> <p>Minimum Stash Version: v0.30.2+ or commit <code>65e82a0</code> or newer</p> <p>This feature requires Stash v0.30.2 or later (or development builds with commit 65e82a0+). Older Stash versions will raise a GraphQL error.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>PerformerMergeInput | dict[str, Any]</code> <p>PerformerMergeInput object or dictionary containing: - source: List of performer IDs to merge (required) - destination: ID of the performer to merge into (required) - values: Optional PerformerUpdateInput to override destination values</p> required <p>Returns:</p> Type Description <code>Performer</code> <p>The merged Performer object</p> <p>Raises:</p> Type Description <code>StashGraphQLError</code> <p>If Stash version is too old or merge fails</p> <p>Examples:</p> <p>Merge performers: <pre><code>merged = await client.performer_merge({\n    \"source\": [\"performer1-id\", \"performer2-id\"],\n    \"destination\": \"destination-performer-id\"\n})\n</code></pre></p> <p>Merge with overrides: <pre><code>from stash_graphql_client.types import PerformerMergeInput, PerformerUpdateInput\n\nmerged = await client.performer_merge(\n    PerformerMergeInput(\n        source=[\"performer1-id\", \"performer2-id\"],\n        destination=\"destination-performer-id\",\n        values=PerformerUpdateInput(\n            id=\"destination-performer-id\",\n            name=\"New Name\",\n            gender=\"FEMALE\"\n        )\n    )\n)\n</code></pre></p>"},{"location":"api/client/mixins/performer/#stash_graphql_client.client.mixins.performer.PerformerClientMixin.map_performer_ids","title":"map_performer_ids  <code>async</code>","text":"<pre><code>map_performer_ids(\n    performers: list[str | dict[str, Any] | Performer],\n    create: bool = False,\n    on_multiple: OnMultipleMatch = RETURN_FIRST,\n) -&gt; list[str]\n</code></pre> <p>Convert performer names/objects to IDs, optionally creating missing performers.</p> <p>This is a convenience method to resolve performer references to their IDs, reducing boilerplate when working with performer relationships.</p> <p>Parameters:</p> Name Type Description Default <code>performers</code> <code>list[str | dict[str, Any] | Performer]</code> <p>List of performer references, can be: - str: Performer name (searches by name, then aliases) - dict: Performer filter criteria (e.g., {\"name\": \"John\", \"disambiguation\": \"Actor\"}) - Performer: Performer object (extracts ID if present, otherwise searches by name)</p> required <code>create</code> <code>bool</code> <p>If True, create performers that don't exist. Default is False.</p> <code>False</code> <code>on_multiple</code> <code>OnMultipleMatch</code> <p>Strategy when multiple matches found. Default is RETURN_FIRST.</p> <code>RETURN_FIRST</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of performer IDs. Skips performers that aren't found (unless create=True).</p> <p>Examples:</p> <p>Map performer names to IDs: <pre><code>performer_ids = await client.map_performer_ids([\"Jane Doe\", \"John Smith\"])\n# Returns: [\"1\", \"2\"] (IDs of existing performers)\n</code></pre></p> <p>Auto-create missing performers: <pre><code>performer_ids = await client.map_performer_ids(\n    [\"Jane Doe\", \"NewPerformer\"],\n    create=True\n)\n# Creates \"NewPerformer\" if it doesn't exist\n</code></pre></p> <p>Handle multiple matches: <pre><code>performer_ids = await client.map_performer_ids(\n    [\"AmbiguousName\"],\n    on_multiple=OnMultipleMatch.RETURN_NONE  # Skip ambiguous matches\n)\n</code></pre></p> <p>Use in scene creation: <pre><code>scene = Scene(\n    title=\"My Scene\",\n    performers=[]  # Will populate with performer IDs\n)\nscene.performers = await client.map_performer_ids(\n    [\"Jane Doe\", \"John Smith\"],\n    create=True\n)\ncreated_scene = await client.create_scene(scene)\n</code></pre></p>"},{"location":"api/client/mixins/plugin/","title":"Plugin Operations","text":"<p>Operations for managing Stash plugins.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for plugin-related client methods.</p>"},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin.get_plugins","title":"get_plugins  <code>async</code>","text":"<pre><code>get_plugins() -&gt; list[Plugin]\n</code></pre> <p>Get all loaded plugins.</p> <p>Returns:</p> Type Description <code>list[Plugin]</code> <p>List of Plugin objects representing all loaded plugins</p> <p>Examples:</p> <p>Get all plugins: <pre><code>plugins = await client.get_plugins()\nfor plugin in plugins:\n    print(f\"Plugin: {plugin.name} (enabled={plugin.enabled})\")\n</code></pre></p> <p>Filter enabled plugins: <pre><code>plugins = await client.get_plugins()\nenabled = [p for p in plugins if p.enabled]\nprint(f\"Enabled plugins: {len(enabled)}\")\n</code></pre></p>"},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin.get_plugin_tasks","title":"get_plugin_tasks  <code>async</code>","text":"<pre><code>get_plugin_tasks() -&gt; list[PluginTask]\n</code></pre> <p>Get all available plugin tasks.</p> <p>Returns:</p> Type Description <code>list[PluginTask]</code> <p>List of PluginTask objects representing all available plugin operations</p> <p>Examples:</p> <p>Get all plugin tasks: <pre><code>tasks = await client.get_plugin_tasks()\nfor task in tasks:\n    print(f\"Task: {task.name} - {task.description}\")\n    print(f\"  Plugin: {task.plugin.name}\")\n</code></pre></p> <p>Find tasks for a specific plugin: <pre><code>tasks = await client.get_plugin_tasks()\nplugin_tasks = [t for t in tasks if t.plugin.id == \"my-plugin-id\"]\n</code></pre></p>"},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin.set_plugins_enabled","title":"set_plugins_enabled  <code>async</code>","text":"<pre><code>set_plugins_enabled(\n    enabled_map: BoolMap | dict[str, bool],\n) -&gt; bool\n</code></pre> <p>Enable or disable plugins.</p> <p>Parameters:</p> Name Type Description Default <code>enabled_map</code> <code>BoolMap | dict[str, bool]</code> <p>Dictionary mapping plugin IDs to enabled status (True/False).         Plugins not in the map are not affected.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the operation was successful, False otherwise</p> <p>Examples:</p> <p>Enable a plugin: <pre><code>success = await client.set_plugins_enabled({\n    \"my-plugin-id\": True\n})\n</code></pre></p> <p>Disable multiple plugins: <pre><code>success = await client.set_plugins_enabled({\n    \"plugin-1\": False,\n    \"plugin-2\": False,\n    \"plugin-3\": True\n})\n</code></pre></p>"},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin.run_plugin_task","title":"run_plugin_task  <code>async</code>","text":"<pre><code>run_plugin_task(\n    plugin_id: str,\n    task_name: str | None = None,\n    description: str | None = None,\n    args_map: Map | dict[str, Any] | None = None,\n) -&gt; str\n</code></pre> <p>Run a plugin task asynchronously via the job queue.</p> <p>If task_name is provided, the task must exist in the plugin config and the task's configuration will be used. If no task_name is provided, the plugin will be executed with the arguments provided only.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>str</code> <p>ID of the plugin to run</p> required <code>task_name</code> <code>str | None</code> <p>Optional name of the task to run (uses task's default config)</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description for the job queue</p> <code>None</code> <code>args_map</code> <code>Map | dict[str, Any] | None</code> <p>Optional arguments to pass to the plugin (as a dictionary)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Job ID for the plugin task</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operation fails or no job ID is returned</p> <p>Examples:</p> <p>Run a plugin task with a task name: <pre><code>job_id = await client.run_plugin_task(\n    plugin_id=\"my-plugin\",\n    task_name=\"scan\",\n    description=\"Scanning library\"\n)\nawait client.wait_for_job(job_id)\n</code></pre></p> <p>Run a plugin with custom arguments: <pre><code>job_id = await client.run_plugin_task(\n    plugin_id=\"my-plugin\",\n    args_map={\"path\": \"/videos\", \"recursive\": True}\n)\n</code></pre></p> <p>Run with both task name and additional arguments: <pre><code>job_id = await client.run_plugin_task(\n    plugin_id=\"my-plugin\",\n    task_name=\"process\",\n    description=\"Processing files\",\n    args_map={\"overwrite\": True}\n)\n</code></pre></p>"},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin.run_plugin_operation","title":"run_plugin_operation  <code>async</code>","text":"<pre><code>run_plugin_operation(\n    plugin_id: str, args: Map | dict[str, Any] | None = None\n) -&gt; Any\n</code></pre> <p>Run a plugin operation synchronously (not via job queue).</p> <p>The operation is run immediately and does not use the job queue. Returns the result directly from the plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>str</code> <p>ID of the plugin to run</p> required <code>args</code> <code>Map | dict[str, Any] | None</code> <p>Optional arguments to pass to the plugin (as a dictionary)</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result from the plugin operation (type depends on the plugin)</p> <p>Examples:</p> <p>Run a plugin operation: <pre><code>result = await client.run_plugin_operation(\n    plugin_id=\"my-plugin\",\n    args={\"action\": \"query\", \"id\": \"123\"}\n)\nprint(f\"Plugin returned: {result}\")\n</code></pre></p> <p>Run without arguments: <pre><code>result = await client.run_plugin_operation(plugin_id=\"my-plugin\")\n</code></pre></p>"},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin.reload_plugins","title":"reload_plugins  <code>async</code>","text":"<pre><code>reload_plugins() -&gt; bool\n</code></pre> <p>Reload all plugins.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if plugins were reloaded successfully, False otherwise</p> <p>Examples:</p> <p>Reload all plugins: <pre><code>success = await client.reload_plugins()\nif success:\n    print(\"Plugins reloaded successfully\")\n</code></pre></p>"},{"location":"api/client/mixins/plugin/#stash_graphql_client.client.mixins.plugin.PluginClientMixin.configure_plugin","title":"configure_plugin  <code>async</code>","text":"<pre><code>configure_plugin(\n    plugin_id: str, config: Map | dict[str, Any]\n) -&gt; Map\n</code></pre> <p>Configure a plugin's settings.</p> <p>Overwrites the entire plugin configuration for the given plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>str</code> <p>ID of the plugin to configure</p> required <code>config</code> <code>Map | dict[str, Any]</code> <p>Configuration dictionary to set for the plugin</p> required <p>Returns:</p> Type Description <code>Map</code> <p>The updated plugin configuration</p> <p>Examples:</p> <p>Configure a plugin: <pre><code>config = await client.configure_plugin(\n    plugin_id=\"my-plugin\",\n    config={\n        \"api_key\": \"secret-key\",\n        \"endpoint\": \"https://api.example.com\",\n        \"enabled_features\": [\"feature1\", \"feature2\"]\n    }\n)\nprint(f\"Updated config: {config}\")\n</code></pre></p> <p>Update specific settings: <pre><code># Get current config first\nplugins = await client.get_plugins()\nmy_plugin = next(p for p in plugins if p.id == \"my-plugin\")\n\n# Modify and save\nconfig = await client.configure_plugin(\n    plugin_id=\"my-plugin\",\n    config={\"setting1\": \"value1\", \"setting2\": True}\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/","title":"Scene Operations","text":"<p>Operations for managing scenes (videos).</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for scene-related client methods.</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.find_scene","title":"find_scene  <code>async</code>","text":"<pre><code>find_scene(id: str) -&gt; Scene | None\n</code></pre> <p>Find a scene by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the scene to find</p> required <p>Returns:</p> Type Description <code>Scene | None</code> <p>Scene object if found, None otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If scene ID is None or empty</p> <p>Examples:</p> <p>Find a scene and check its title: <pre><code>scene = await client.find_scene(\"123\")\n\nif scene:\n    print(f\"Found scene: {scene.title}\")\n</code></pre></p> <p>Access scene relationships: <pre><code>scene = await client.find_scene(\"123\")\n\nif scene:\n    # Get performer names\n    performers = [p.name for p in scene.performers]\n    # Get studio name\n    studio_name = scene.studio.name if scene.studio else None\n    # Get tag names\n    tags = [t.name for t in scene.tags]\n</code></pre></p> <p>Check scene paths: <pre><code>scene = await client.find_scene(\"123\")\n\nif scene:\n    # Get streaming URL\n    stream_url = scene.paths.stream\n    # Get preview URL\n    preview_url = scene.paths.preview\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.find_scenes","title":"find_scenes  <code>async</code>","text":"<pre><code>find_scenes(\n    filter_: dict[str, Any] | None = None,\n    scene_filter: dict[str, Any] | None = None,\n    q: str | None = None,\n) -&gt; FindScenesResultType\n</code></pre> <p>Find scenes matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <code>scene_filter</code> <code>dict[str, Any] | None</code> <p>Optional scene-specific filter: - file_count: IntCriterionInput - is_missing: str (what data is missing) - organized: bool - path: StringCriterionInput - performer_count: IntCriterionInput - performer_tags: HierarchicalMultiCriterionInput - performers: MultiCriterionInput - rating100: IntCriterionInput - resolution: ResolutionEnum - studios: HierarchicalMultiCriterionInput - tag_count: IntCriterionInput - tags: HierarchicalMultiCriterionInput - title: StringCriterionInput</p> <code>None</code> <p>Returns:</p> Type Description <code>FindScenesResultType</code> <p>FindScenesResultType containing: - count: Total number of matching scenes - duration: Total duration in seconds - filesize: Total size in bytes - scenes: List of Scene objects</p> <p>Examples:</p> <p>Find all organized scenes: <pre><code>result = await client.find_scenes(\n    scene_filter={\"organized\": True}\n)\nprint(f\"Found {result.count} organized scenes\")\nfor scene in result.scenes:\n    print(f\"- {scene.title}\")\n</code></pre></p> <p>Find scenes with specific performers: <pre><code>result = await client.find_scenes(\n    scene_filter={\n        \"performers\": {\n            \"value\": [\"performer1\", \"performer2\"],\n            \"modifier\": \"INCLUDES_ALL\"\n        }\n    }\n)\n</code></pre></p> <p>Find scenes with high rating and sort by date: <pre><code>result = await client.find_scenes(\n    filter_={\n        \"direction\": \"DESC\",\n        \"sort\": \"date\",\n    },\n    scene_filter={\n        \"rating100\": {\n            \"value\": 80,\n            \"modifier\": \"GREATER_THAN\"\n        }\n    }\n)\n</code></pre></p> <p>Paginate results: <pre><code>result = await client.find_scenes(\n    filter_={\n        \"page\": 1,\n        \"per_page\": 25,\n    }\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.create_scene","title":"create_scene  <code>async</code>","text":"<pre><code>create_scene(scene: Scene) -&gt; Scene\n</code></pre> <p>Create a new scene in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>scene</code> <code>Scene</code> <p>Scene object with the data to create. Required fields: - title: Scene title - urls: List of URLs associated with the scene - organized: Whether the scene is organized</p> <p>Note: created_at and updated_at are handled by Stash</p> required <p>Returns:</p> Type Description <code>Scene</code> <p>Created Scene object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the scene data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Create a basic scene: <pre><code>scene = Scene(\n    title=\"My Scene\",\n    urls=[\"https://example.com/scene\"],\n    organized=True,  # created_at and updated_at handled by Stash\n)\ncreated = await client.create_scene(scene)\nprint(f\"Created scene with ID: {created.id}\")\n</code></pre></p> <p>Create scene with relationships: <pre><code>scene = Scene(\n    title=\"My Scene\",\n    urls=[\"https://example.com/scene\"],\n    organized=True,  # created_at and updated_at handled by Stash\n    # Add relationships\n    performers=[performer1, performer2],\n    studio=studio,\n    tags=[tag1, tag2],\n)\ncreated = await client.create_scene(scene)\n</code></pre></p> <p>Create scene with metadata: <pre><code>scene = Scene(\n    title=\"My Scene\",\n    urls=[\"https://example.com/scene\"],\n    organized=True,  # created_at and updated_at handled by Stash\n    # Add metadata\n    details=\"Scene description\",\n    date=\"2024-01-31\",\n    rating100=85,\n    code=\"SCENE123\",\n)\ncreated = await client.create_scene(scene)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.update_scene","title":"update_scene  <code>async</code>","text":"<pre><code>update_scene(scene: Scene) -&gt; Scene\n</code></pre> <p>Update an existing scene in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>scene</code> <code>Scene</code> <p>Scene object with updated data. Required fields: - id: Scene ID to update Any other fields that are set will be updated. Fields that are None will be ignored.</p> required <p>Returns:</p> Type Description <code>Scene</code> <p>Updated Scene object with any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the scene data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Update scene title and rating: <pre><code>scene = await client.find_scene(\"123\")\nif scene:\n    scene.title = \"New Title\"\n    scene.rating100 = 90\n    updated = await client.update_scene(scene)\n    print(f\"Updated scene: {updated.title}\")\n</code></pre></p> <p>Update scene relationships: <pre><code>scene = await client.find_scene(\"123\")\nif scene:\n    # Add new performers\n    scene.performers.extend([new_performer1, new_performer2])\n    # Set new studio\n    scene.studio = new_studio\n    # Add new tags\n    scene.tags.extend([new_tag1, new_tag2])\n    updated = await client.update_scene(scene)\n</code></pre></p> <p>Update scene metadata: <pre><code>scene = await client.find_scene(\"123\")\nif scene:\n    # Update metadata\n    scene.details = \"New description\"\n    scene.date = \"2024-01-31\"\n    scene.code = \"NEWCODE123\"\n    scene.organized = True\n    updated = await client.update_scene(scene)\n</code></pre></p> <p>Update scene URLs: <pre><code>scene = await client.find_scene(\"123\")\nif scene:\n    # Replace URLs\n    scene.urls = [\n        \"https://example.com/new-url\",\n    ]\n    updated = await client.update_scene(scene)\n</code></pre></p> <p>Remove scene relationships: <pre><code>scene = await client.find_scene(\"123\")\nif scene:\n    # Clear studio\n    scene.studio = None\n    # Clear performers\n    scene.performers = []\n    updated = await client.update_scene(scene)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.find_duplicate_scenes","title":"find_duplicate_scenes  <code>async</code>","text":"<pre><code>find_duplicate_scenes(\n    distance: int | None = None,\n    duration_diff: float | None = None,\n) -&gt; list[list[Scene]]\n</code></pre> <p>Find groups of scenes that are perceptual duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>int | None</code> <p>Maximum phash distance between scenes to be considered duplicates</p> <code>None</code> <code>duration_diff</code> <code>float | None</code> <p>Maximum difference in seconds between scene durations</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[Scene]]</code> <p>List of scene groups, where each group is a list of duplicate scenes</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.parse_scene_filenames","title":"parse_scene_filenames  <code>async</code>","text":"<pre><code>parse_scene_filenames(\n    filter_: dict[str, Any] | None = None,\n    config: dict[str, Any] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Parse scene filenames using the given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional filter to select scenes</p> <code>None</code> <code>config</code> <code>dict[str, Any] | None</code> <p>Parser configuration: - whitespace_separator: bool - field_separator: str - fields: list[str]</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing parse results</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_wall","title":"scene_wall  <code>async</code>","text":"<pre><code>scene_wall(q: str | None = None) -&gt; list[Scene]\n</code></pre> <p>Get random scenes for the wall.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>str | None</code> <p>Optional search query</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Scene]</code> <p>List of random Scene objects</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.bulk_scene_update","title":"bulk_scene_update  <code>async</code>","text":"<pre><code>bulk_scene_update(\n    input_data: dict[str, Any],\n) -&gt; list[Scene]\n</code></pre> <p>Update multiple scenes at once.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any]</code> <p>Dictionary containing: - ids: List of scene IDs to update - Any other fields to update on all scenes</p> required <p>Returns:</p> Type Description <code>list[Scene]</code> <p>List of updated Scene objects</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scenes_update","title":"scenes_update  <code>async</code>","text":"<pre><code>scenes_update(scenes: list[Scene]) -&gt; list[Scene]\n</code></pre> <p>Update multiple scenes with individual data.</p> <p>Parameters:</p> Name Type Description Default <code>scenes</code> <code>list[Scene]</code> <p>List of Scene objects to update, each must have an ID</p> required <p>Returns:</p> Type Description <code>list[Scene]</code> <p>List of updated Scene objects</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_generate_screenshot","title":"scene_generate_screenshot  <code>async</code>","text":"<pre><code>scene_generate_screenshot(\n    id: str, at: float | None = None\n) -&gt; str\n</code></pre> <p>Generate a screenshot for a scene.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <code>at</code> <code>float | None</code> <p>Optional time in seconds to take screenshot at</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the generated screenshot</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the scene is not found</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.find_scene_by_hash","title":"find_scene_by_hash  <code>async</code>","text":"<pre><code>find_scene_by_hash(\n    input_data: SceneHashInput | dict[str, Any],\n) -&gt; Scene | None\n</code></pre> <p>Find a scene by its hash (checksum or oshash).</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>SceneHashInput | dict[str, Any]</code> <p>SceneHashInput object or dictionary containing: - checksum: MD5 checksum of the file (optional) - oshash: OSHash of the file (optional)</p> <p>Note: At least one hash must be provided</p> required <p>Returns:</p> Type Description <code>Scene | None</code> <p>Scene object if found, None otherwise</p> <p>Examples:</p> <p>Find scene by MD5 checksum: <pre><code>scene = await client.find_scene_by_hash({\n    \"checksum\": \"abc123def456...\"\n})\nif scene:\n    print(f\"Found scene: {scene.title}\")\n</code></pre></p> <p>Find scene by OSHash: <pre><code>scene = await client.find_scene_by_hash({\n    \"oshash\": \"xyz789...\"\n})\n</code></pre></p> <p>Using the input type: <pre><code>from ...types import SceneHashInput\n\ninput_data = SceneHashInput(checksum=\"abc123\")\nscene = await client.find_scene_by_hash(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_destroy","title":"scene_destroy  <code>async</code>","text":"<pre><code>scene_destroy(\n    input_data: SceneDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete a scene.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>SceneDestroyInput | dict[str, Any]</code> <p>SceneDestroyInput object or dictionary containing: - id: Scene ID to delete (required) - delete_file: Whether to delete the scene's file (optional, default: False) - delete_generated: Whether to delete generated files (optional, default: True)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the scene was successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the scene ID is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Delete a scene without deleting the file: <pre><code>result = await client.scene_destroy({\n    \"id\": \"123\",\n    \"delete_file\": False,\n    \"delete_generated\": True\n})\nprint(f\"Scene deleted: {result}\")\n</code></pre></p> <p>Delete a scene and its file: <pre><code>result = await client.scene_destroy({\n    \"id\": \"123\",\n    \"delete_file\": True,\n    \"delete_generated\": True\n})\n</code></pre></p> <p>Using the input type: <pre><code>from ...types import SceneDestroyInput\n\ninput_data = SceneDestroyInput(\n    id=\"123\",\n    delete_file=True,\n    delete_generated=True\n)\nresult = await client.scene_destroy(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scenes_destroy","title":"scenes_destroy  <code>async</code>","text":"<pre><code>scenes_destroy(\n    input_data: ScenesDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete multiple scenes.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ScenesDestroyInput | dict[str, Any]</code> <p>ScenesDestroyInput object or dictionary containing: - ids: List of scene IDs to delete (required) - delete_file: Whether to delete the scenes' files (optional, default: False) - delete_generated: Whether to delete generated files (optional, default: True)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the scenes were successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any scene ID is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Delete multiple scenes without deleting files: <pre><code>result = await client.scenes_destroy({\n    \"ids\": [\"123\", \"456\", \"789\"],\n    \"delete_file\": False,\n    \"delete_generated\": True\n})\nprint(f\"Scenes deleted: {result}\")\n</code></pre></p> <p>Delete multiple scenes and their files: <pre><code>result = await client.scenes_destroy({\n    \"ids\": [\"123\", \"456\"],\n    \"delete_file\": True,\n    \"delete_generated\": True\n})\n</code></pre></p> <p>Using the input type: <pre><code>from ...types import ScenesDestroyInput\n\ninput_data = ScenesDestroyInput(\n    ids=[\"123\", \"456\", \"789\"],\n    delete_file=False,\n    delete_generated=True\n)\nresult = await client.scenes_destroy(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_merge","title":"scene_merge  <code>async</code>","text":"<pre><code>scene_merge(\n    input_data: SceneMergeInput | dict[str, Any],\n) -&gt; Scene\n</code></pre> <p>Merge multiple scenes into one destination scene.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>SceneMergeInput | dict[str, Any]</code> <p>SceneMergeInput object or dictionary containing: - source: List of source scene IDs to merge (required) - destination: Destination scene ID (required) - values: Optional SceneUpdateInput with values to apply to merged scene - play_history: Whether to merge play history (optional, default: False) - o_history: Whether to merge o-count history (optional, default: False)</p> required <p>Returns:</p> Type Description <code>Scene</code> <p>Updated destination Scene object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input data is invalid</p> <code>TransportError</code> <p>If the request fails</p> <p>Examples:</p> <p>Merge two scenes into one: <pre><code>merged = await client.scene_merge({\n    \"source\": [\"123\", \"456\"],\n    \"destination\": \"789\"\n})\nprint(f\"Merged into scene: {merged.title}\")\n</code></pre></p> <p>Merge scenes and update metadata: <pre><code>from stash_graphql_client.types import SceneMergeInput\n\ninput_data = SceneMergeInput(\n    source=[\"123\", \"456\"],\n    destination=\"789\",\n    values={\"title\": \"Merged Scene\"},\n    play_history=True,\n    o_history=True\n)\nmerged = await client.scene_merge(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_add_o","title":"scene_add_o  <code>async</code>","text":"<pre><code>scene_add_o(\n    id: str, times: list[str] | None = None\n) -&gt; HistoryMutationResult\n</code></pre> <p>Add O-count entry for a scene.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <code>times</code> <code>list[str] | None</code> <p>Optional list of timestamps. If not provided, uses current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>HistoryMutationResult</code> <p>HistoryMutationResult containing: - count: New O-count value - history: List of all O timestamps</p> <p>Examples:</p> <p>Add O-count with current time: <pre><code>result = await client.scene_add_o(\"123\")\nprint(f\"New O-count: {result.count}\")\n</code></pre></p> <p>Add O-count with specific times: <pre><code>result = await client.scene_add_o(\n    \"123\",\n    times=[\"2024-01-15T10:30:00Z\", \"2024-01-16T14:20:00Z\"]\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_delete_o","title":"scene_delete_o  <code>async</code>","text":"<pre><code>scene_delete_o(\n    id: str, times: list[str] | None = None\n) -&gt; HistoryMutationResult\n</code></pre> <p>Delete O-count entry from a scene.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <code>times</code> <code>list[str] | None</code> <p>Optional list of timestamps to remove. If not provided, removes last entry.</p> <code>None</code> <p>Returns:</p> Type Description <code>HistoryMutationResult</code> <p>HistoryMutationResult containing: - count: New O-count value - history: List of remaining O timestamps</p> <p>Examples:</p> <p>Remove last O-count entry: <pre><code>result = await client.scene_delete_o(\"123\")\nprint(f\"New O-count: {result.count}\")\n</code></pre></p> <p>Remove specific timestamp: <pre><code>result = await client.scene_delete_o(\n    \"123\",\n    times=[\"2024-01-15T10:30:00Z\"]\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_reset_o","title":"scene_reset_o  <code>async</code>","text":"<pre><code>scene_reset_o(id: str) -&gt; int\n</code></pre> <p>Reset scene O-count to 0.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <p>Returns:</p> Type Description <code>int</code> <p>New O-count value (0)</p> Example <pre><code>count = await client.scene_reset_o(\"123\")\nprint(f\"O-count reset to: {count}\")\n</code></pre>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_save_activity","title":"scene_save_activity  <code>async</code>","text":"<pre><code>scene_save_activity(\n    id: str,\n    resume_time: float | None = None,\n    play_duration: float | None = None,\n) -&gt; bool\n</code></pre> <p>Save scene playback activity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <code>resume_time</code> <code>float | None</code> <p>Resume time point in seconds</p> <code>None</code> <code>play_duration</code> <code>float | None</code> <p>Duration played in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if activity was saved successfully</p> <p>Examples:</p> <p>Save resume point: <pre><code>await client.scene_save_activity(\"123\", resume_time=120.5)\n</code></pre></p> <p>Save play duration: <pre><code>await client.scene_save_activity(\"123\", play_duration=300.0)\n</code></pre></p> <p>Save both: <pre><code>await client.scene_save_activity(\n    \"123\",\n    resume_time=120.5,\n    play_duration=300.0\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_reset_activity","title":"scene_reset_activity  <code>async</code>","text":"<pre><code>scene_reset_activity(\n    id: str,\n    reset_resume: bool = False,\n    reset_duration: bool = False,\n) -&gt; bool\n</code></pre> <p>Reset scene activity tracking.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <code>reset_resume</code> <code>bool</code> <p>Whether to reset resume time point</p> <code>False</code> <code>reset_duration</code> <code>bool</code> <p>Whether to reset play duration</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if activity was reset successfully</p> <p>Examples:</p> <p>Reset resume point: <pre><code>await client.scene_reset_activity(\"123\", reset_resume=True)\n</code></pre></p> <p>Reset play duration: <pre><code>await client.scene_reset_activity(\"123\", reset_duration=True)\n</code></pre></p> <p>Reset both: <pre><code>await client.scene_reset_activity(\n    \"123\",\n    reset_resume=True,\n    reset_duration=True\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_add_play","title":"scene_add_play  <code>async</code>","text":"<pre><code>scene_add_play(\n    id: str, times: list[str] | None = None\n) -&gt; HistoryMutationResult\n</code></pre> <p>Add play count entry for a scene.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <code>times</code> <code>list[str] | None</code> <p>Optional list of timestamps. If not provided, uses current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>HistoryMutationResult</code> <p>HistoryMutationResult containing: - count: New play count value - history: List of all play timestamps</p> <p>Examples:</p> <p>Add play with current time: <pre><code>result = await client.scene_add_play(\"123\")\nprint(f\"New play count: {result.count}\")\n</code></pre></p> <p>Add play with specific times: <pre><code>result = await client.scene_add_play(\n    \"123\",\n    times=[\"2024-01-15T10:30:00Z\"]\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_delete_play","title":"scene_delete_play  <code>async</code>","text":"<pre><code>scene_delete_play(\n    id: str, times: list[str] | None = None\n) -&gt; HistoryMutationResult\n</code></pre> <p>Delete play count entry from a scene.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <code>times</code> <code>list[str] | None</code> <p>Optional list of timestamps to remove. If not provided, removes last entry.</p> <code>None</code> <p>Returns:</p> Type Description <code>HistoryMutationResult</code> <p>HistoryMutationResult containing: - count: New play count value - history: List of remaining play timestamps</p> <p>Examples:</p> <p>Remove last play entry: <pre><code>result = await client.scene_delete_play(\"123\")\nprint(f\"New play count: {result.count}\")\n</code></pre></p> <p>Remove specific timestamp: <pre><code>result = await client.scene_delete_play(\n    \"123\",\n    times=[\"2024-01-15T10:30:00Z\"]\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_reset_play_count","title":"scene_reset_play_count  <code>async</code>","text":"<pre><code>scene_reset_play_count(id: str) -&gt; int\n</code></pre> <p>Reset scene play count to 0.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Scene ID</p> required <p>Returns:</p> Type Description <code>int</code> <p>New play count value (0)</p> Example <pre><code>count = await client.scene_reset_play_count(\"123\")\nprint(f\"Play count reset to: {count}\")\n</code></pre>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.find_scenes_by_path_regex","title":"find_scenes_by_path_regex  <code>async</code>","text":"<pre><code>find_scenes_by_path_regex(\n    filter_: dict[str, Any] | None = None,\n) -&gt; FindScenesResultType\n</code></pre> <p>Find scenes by path regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Filter parameters</p> <code>None</code> <p>Returns:</p> Type Description <code>FindScenesResultType</code> <p>FindScenesResultType containing: - count: Total number of matches - duration: Total duration in seconds - filesize: Total file size in bytes - scenes: List of Scene objects matching the path pattern</p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.scene_streams","title":"scene_streams  <code>async</code>","text":"<pre><code>scene_streams(scene_id: str) -&gt; list[SceneStreamEndpoint]\n</code></pre> <p>Get streaming endpoints for a scene.</p> <p>Parameters:</p> Name Type Description Default <code>scene_id</code> <code>str</code> <p>The ID of the scene</p> required <p>Returns:</p> Type Description <code>list[SceneStreamEndpoint]</code> <p>List of SceneStreamEndpoint objects containing: - url: Stream URL - mime_type: MIME type of the stream - label: Label for the stream quality/format</p> <p>Examples:</p> <p>Get streaming endpoints: <pre><code>streams = await client.scene_streams(\"123\")\nfor stream in streams:\n    print(f\"{stream.label}: {stream.url} ({stream.mime_type})\")\n</code></pre></p> <p>Access specific stream properties: <pre><code>streams = await client.scene_streams(\"123\")\nif streams:\n    primary_stream = streams[0]\n    print(f\"Primary stream URL: {primary_stream.url}\")\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.merge_scene_markers","title":"merge_scene_markers  <code>async</code>","text":"<pre><code>merge_scene_markers(\n    target_scene_id: str, source_scene_ids: list[str]\n) -&gt; list[Any]\n</code></pre> <p>Merge scene markers from source scenes to target scene.</p> <p>This utility method copies all markers from one or more source scenes to a target scene. Useful when consolidating duplicate scenes or merging content.</p> <p>Parameters:</p> Name Type Description Default <code>target_scene_id</code> <code>str</code> <p>The ID of the target scene to copy markers to</p> required <code>source_scene_ids</code> <code>list[str]</code> <p>List of source scene IDs to copy markers from</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>List of SceneMarker objects that were created on the target scene</p> <p>Examples:</p> <p>Merge markers from a single source: <pre><code>markers = await client.merge_scene_markers(\n    target_scene_id=\"123\",\n    source_scene_ids=[\"456\"]\n)\nprint(f\"Copied {len(markers)} markers to target scene\")\n</code></pre></p> <p>Merge markers from multiple sources: <pre><code>markers = await client.merge_scene_markers(\n    target_scene_id=\"123\",\n    source_scene_ids=[\"456\", \"789\", \"101\"]\n)\nfor marker in markers:\n    print(f\"Marker: {marker.title} at {marker.seconds}s\")\n</code></pre></p> <p>Use with scene merge workflow: <pre><code># First merge the scenes\nmerged = await client.scene_merge({\n    \"source\": [\"source1\", \"source2\"],\n    \"destination\": \"target\"\n})\n\n# Then copy markers\nmarkers = await client.merge_scene_markers(\n    target_scene_id=\"target\",\n    source_scene_ids=[\"source1\", \"source2\"]\n)\n</code></pre></p>"},{"location":"api/client/mixins/scene/#stash_graphql_client.client.mixins.scene.SceneClientMixin.find_duplicate_scenes_wrapper","title":"find_duplicate_scenes_wrapper  <code>async</code>","text":"<pre><code>find_duplicate_scenes_wrapper(\n    distance: int = 0, duration_diff: float | None = None\n) -&gt; list[list[Scene]]\n</code></pre> <p>Find duplicate scenes with sensible default parameters.</p> <p>This is a convenience wrapper around find_duplicate_scenes() that provides better defaults for common use cases. A distance of 0 finds exact phash matches (true duplicates), while higher values find similar scenes.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>int</code> <p>Maximum phash distance (default: 0 for exact duplicates) - 0: Exact phash matches (identical frames) - 1-5: Very similar scenes (same content, different encode) - 6-10: Similar scenes (same source, different quality) - 11+: Potentially different scenes</p> <code>0</code> <code>duration_diff</code> <code>float | None</code> <p>Maximum duration difference in seconds (default: None) - None: No duration filtering - 0.0: Exact duration match - 1.0-10.0: Similar duration (accounts for encoding differences) - 10.0+: Loose duration matching</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[Scene]]</code> <p>List of scene groups, where each group is a list of duplicate scenes</p> <p>Examples:</p> <p>Find exact duplicates (phash distance = 0): <pre><code>duplicates = await client.find_duplicate_scenes_wrapper()\nfor group in duplicates:\n    print(f\"Found {len(group)} exact duplicates:\")\n    for scene in group:\n        print(f\"  - {scene.title}\")\n</code></pre></p> <p>Find similar scenes (allow small phash differences): <pre><code>similar = await client.find_duplicate_scenes_wrapper(distance=5)\nfor group in similar:\n    print(f\"Found {len(group)} similar scenes\")\n</code></pre></p> <p>Find duplicates with similar duration: <pre><code>duplicates = await client.find_duplicate_scenes_wrapper(\n    distance=0,\n    duration_diff=2.0  # Within 2 seconds\n)\n</code></pre></p> <p>Use in cleanup workflow: <pre><code># Find exact duplicates\nduplicates = await client.find_duplicate_scenes_wrapper()\n\nfor group in duplicates:\n    # Keep the first scene, delete the rest\n    to_delete = [scene.id for scene in group[1:]]\n    if to_delete:\n        await client.scenes_destroy({\n            \"ids\": to_delete,\n            \"delete_file\": True\n        })\n</code></pre></p>"},{"location":"api/client/mixins/scraper/","title":"Scraper Operations","text":"<p>Operations for scraping metadata from external sources.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for scraper-related client methods.</p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.list_scrapers","title":"list_scrapers  <code>async</code>","text":"<pre><code>list_scrapers(\n    types: list[ScrapeContentType],\n) -&gt; list[Scraper]\n</code></pre> <p>List available scrapers filtered by content types.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>list[ScrapeContentType]</code> <p>List of content types to filter scrapers by (GALLERY, IMAGE, MOVIE, GROUP, PERFORMER, SCENE)</p> required <p>Returns:</p> Type Description <code>list[Scraper]</code> <p>List of Scraper objects matching the requested types</p> <p>Examples:</p> <p>List all scene scrapers: <pre><code>scrapers = await client.list_scrapers([ScrapeContentType.SCENE])\nfor scraper in scrapers:\n    print(f\"Scene scraper: {scraper.name}\")\n</code></pre></p> <p>List multiple scraper types: <pre><code>from stash_graphql_client.types import ScrapeContentType\nscrapers = await client.list_scrapers([\n    ScrapeContentType.SCENE,\n    ScrapeContentType.PERFORMER\n])\n</code></pre></p> <p>Check scraper capabilities: <pre><code>scrapers = await client.list_scrapers([ScrapeContentType.SCENE])\nfor scraper in scrapers:\n    if scraper.scene:\n        print(f\"{scraper.name} supports: {scraper.scene.supported_scrapes}\")\n        print(f\"URLs: {scraper.scene.urls}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_scene","title":"scrape_single_scene  <code>async</code>","text":"<pre><code>scrape_single_scene(\n    source: ScraperSourceInput,\n    input: ScrapeSingleSceneInput,\n) -&gt; list[ScrapedScene]\n</code></pre> <p>Scrape for a single scene.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSingleSceneInput</code> <p>Scene scraping input (query, scene_id, or scene_input)</p> required <p>Returns:</p> Type Description <code>list[ScrapedScene]</code> <p>List of ScrapedScene objects</p> <p>Examples:</p> <p>Scrape by query string: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleSceneInput(query=\"scene title\")\nscenes = await client.scrape_single_scene(source, input)\n</code></pre></p> <p>Scrape by scene ID (using fingerprints): <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleSceneInput(scene_id=\"scene-456\")\nscenes = await client.scrape_single_scene(source, input)\n</code></pre></p> <p>Scrape from StashBox: <pre><code>source = ScraperSourceInput(stash_box_endpoint=\"https://stashdb.org\")\ninput = ScrapeSingleSceneInput(query=\"scene title\")\nscenes = await client.scrape_single_scene(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_multi_scenes","title":"scrape_multi_scenes  <code>async</code>","text":"<pre><code>scrape_multi_scenes(\n    source: ScraperSourceInput,\n    input: ScrapeMultiScenesInput,\n) -&gt; list[list[ScrapedScene]]\n</code></pre> <p>Scrape for multiple scenes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeMultiScenesInput</code> <p>Multi-scene scraping input (scene_ids)</p> required <p>Returns:</p> Type Description <code>list[list[ScrapedScene]]</code> <p>List of lists of ScrapedScene objects (one list per input scene)</p> <p>Examples:</p> <p>Scrape multiple scenes: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeMultiScenesInput(scene_ids=[\"1\", \"2\", \"3\"])\nresults = await client.scrape_multi_scenes(source, input)\nfor i, scenes in enumerate(results):\n    print(f\"Scene {i+1}: {len(scenes)} matches found\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_studio","title":"scrape_single_studio  <code>async</code>","text":"<pre><code>scrape_single_studio(\n    source: ScraperSourceInput,\n    input: ScrapeSingleStudioInput,\n) -&gt; list[ScrapedStudio]\n</code></pre> <p>Scrape for a single studio.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSingleStudioInput</code> <p>Studio scraping input (query - can be name or Stash ID)</p> required <p>Returns:</p> Type Description <code>list[ScrapedStudio]</code> <p>List of ScrapedStudio objects</p> <p>Examples:</p> <p>Scrape studio by name: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleStudioInput(query=\"Studio Name\")\nstudios = await client.scrape_single_studio(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_tag","title":"scrape_single_tag  <code>async</code>","text":"<pre><code>scrape_single_tag(\n    source: ScraperSourceInput, input: ScrapeSingleTagInput\n) -&gt; list[ScrapedTag]\n</code></pre> <p>Scrape for a single tag.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSingleTagInput</code> <p>Tag scraping input (query - can be name or Stash ID)</p> required <p>Returns:</p> Type Description <code>list[ScrapedTag]</code> <p>List of ScrapedTag objects</p> <p>Examples:</p> <p>Scrape tag by name: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleTagInput(query=\"Tag Name\")\ntags = await client.scrape_single_tag(source, input)\n</code></pre></p> <p>Scrape from StashBox: <pre><code>source = ScraperSourceInput(stash_box_endpoint=\"https://stashdb.org\")\ninput = ScrapeSingleTagInput(query=\"Tag Name\")\ntags = await client.scrape_single_tag(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_performer","title":"scrape_single_performer  <code>async</code>","text":"<pre><code>scrape_single_performer(\n    source: ScraperSourceInput,\n    input: ScrapeSinglePerformerInput,\n) -&gt; list[ScrapedPerformer]\n</code></pre> <p>Scrape for a single performer.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSinglePerformerInput</code> <p>Performer scraping input (query, performer_id, or performer_input)</p> required <p>Returns:</p> Type Description <code>list[ScrapedPerformer]</code> <p>List of ScrapedPerformer objects</p> <p>Examples:</p> <p>Scrape by query string: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSinglePerformerInput(query=\"Performer Name\")\nperformers = await client.scrape_single_performer(source, input)\n</code></pre></p> <p>Scrape by performer ID: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSinglePerformerInput(performer_id=\"123\")\nperformers = await client.scrape_single_performer(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_multi_performers","title":"scrape_multi_performers  <code>async</code>","text":"<pre><code>scrape_multi_performers(\n    source: ScraperSourceInput,\n    input: ScrapeMultiPerformersInput,\n) -&gt; list[list[ScrapedPerformer]]\n</code></pre> <p>Scrape for multiple performers.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeMultiPerformersInput</code> <p>Multi-performer scraping input (performer_ids)</p> required <p>Returns:</p> Type Description <code>list[list[ScrapedPerformer]]</code> <p>List of lists of ScrapedPerformer objects (one list per input performer)</p> <p>Examples:</p> <p>Scrape multiple performers: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeMultiPerformersInput(performer_ids=[\"1\", \"2\", \"3\"])\nresults = await client.scrape_multi_performers(source, input)\nfor i, performers in enumerate(results):\n    print(f\"Performer {i+1}: {len(performers)} matches found\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_gallery","title":"scrape_single_gallery  <code>async</code>","text":"<pre><code>scrape_single_gallery(\n    source: ScraperSourceInput,\n    input: ScrapeSingleGalleryInput,\n) -&gt; list[ScrapedGallery]\n</code></pre> <p>Scrape for a single gallery.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSingleGalleryInput</code> <p>Gallery scraping input (query, gallery_id, or gallery_input)</p> required <p>Returns:</p> Type Description <code>list[ScrapedGallery]</code> <p>List of ScrapedGallery objects</p> <p>Examples:</p> <p>Scrape by query string: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleGalleryInput(query=\"gallery title\")\ngalleries = await client.scrape_single_gallery(source, input)\n</code></pre></p> <p>Scrape by gallery ID: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleGalleryInput(gallery_id=\"456\")\ngalleries = await client.scrape_single_gallery(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_movie","title":"scrape_single_movie  <code>async</code>","text":"<pre><code>scrape_single_movie(\n    source: ScraperSourceInput,\n    input: ScrapeSingleMovieInput,\n) -&gt; list[ScrapedMovie]\n</code></pre> <p>Scrape for a single movie.</p> <p>.. deprecated::     Use :meth:<code>scrape_single_group</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSingleMovieInput</code> <p>Movie scraping input (query, movie_id, or movie_input)</p> required <p>Returns:</p> Type Description <code>list[ScrapedMovie]</code> <p>List of ScrapedMovie objects</p> <p>Examples:</p> <p>Scrape by query string: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleMovieInput(query=\"movie title\")\nmovies = await client.scrape_single_movie(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_group","title":"scrape_single_group  <code>async</code>","text":"<pre><code>scrape_single_group(\n    source: ScraperSourceInput,\n    input: ScrapeSingleGroupInput,\n) -&gt; list[ScrapedGroup]\n</code></pre> <p>Scrape for a single group.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSingleGroupInput</code> <p>Group scraping input (query, group_id, or group_input)</p> required <p>Returns:</p> Type Description <code>list[ScrapedGroup]</code> <p>List of ScrapedGroup objects</p> <p>Examples:</p> <p>Scrape by query string: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleGroupInput(query=\"group title\")\ngroups = await client.scrape_single_group(source, input)\n</code></pre></p> <p>Scrape by group ID: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleGroupInput(group_id=\"789\")\ngroups = await client.scrape_single_group(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_single_image","title":"scrape_single_image  <code>async</code>","text":"<pre><code>scrape_single_image(\n    source: ScraperSourceInput,\n    input: ScrapeSingleImageInput,\n) -&gt; list[ScrapedImage]\n</code></pre> <p>Scrape for a single image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ScraperSourceInput</code> <p>Scraper source (scraper_id or stash_box_endpoint)</p> required <code>input</code> <code>ScrapeSingleImageInput</code> <p>Image scraping input (query, image_id, or image_input)</p> required <p>Returns:</p> Type Description <code>list[ScrapedImage]</code> <p>List of ScrapedImage objects</p> <p>Examples:</p> <p>Scrape by query string: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleImageInput(query=\"image title\")\nimages = await client.scrape_single_image(source, input)\n</code></pre></p> <p>Scrape by image ID: <pre><code>source = ScraperSourceInput(scraper_id=\"scraper-123\")\ninput = ScrapeSingleImageInput(image_id=\"101\")\nimages = await client.scrape_single_image(source, input)\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_url","title":"scrape_url  <code>async</code>","text":"<pre><code>scrape_url(url: str, ty: ScrapeContentType) -&gt; Any\n</code></pre> <p>Scrape content based on a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to scrape</p> required <code>ty</code> <code>ScrapeContentType</code> <p>Type of content to scrape (GALLERY, IMAGE, MOVIE, GROUP, PERFORMER, SCENE)</p> required <p>Returns:</p> Type Description <code>Any</code> <p>ScrapedContent union type (could be any scraped type based on ty parameter)</p> Note <p>Returns ScrapedStudio, ScrapedTag, ScrapedScene, ScrapedGallery, ScrapedImage, ScrapedMovie, ScrapedGroup, or ScrapedPerformer depending on the content type.</p> <p>Examples:</p> <p>Scrape a scene from URL: <pre><code>from stash_graphql_client.types import ScrapeContentType\ncontent = await client.scrape_url(\n    \"https://example.com/scene/123\",\n    ScrapeContentType.SCENE\n)\nif content:\n    print(f\"Scraped scene: {content.title}\")\n</code></pre></p> <p>Scrape a performer from URL: <pre><code>content = await client.scrape_url(\n    \"https://example.com/performer/456\",\n    ScrapeContentType.PERFORMER\n)\nif content:\n    print(f\"Scraped performer: {content.name}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_performer_url","title":"scrape_performer_url  <code>async</code>","text":"<pre><code>scrape_performer_url(url: str) -&gt; ScrapedPerformer | None\n</code></pre> <p>Scrape a complete performer record based on a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to scrape performer from</p> required <p>Returns:</p> Type Description <code>ScrapedPerformer | None</code> <p>ScrapedPerformer object if successful, None otherwise</p> <p>Examples:</p> <p>Scrape performer from URL: <pre><code>performer = await client.scrape_performer_url(\"https://example.com/performer/123\")\nif performer:\n    print(f\"Name: {performer.name}\")\n    print(f\"Birthdate: {performer.birthdate}\")\n    print(f\"Gender: {performer.gender}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_scene_url","title":"scrape_scene_url  <code>async</code>","text":"<pre><code>scrape_scene_url(url: str) -&gt; ScrapedScene | None\n</code></pre> <p>Scrape a complete scene record based on a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to scrape scene from</p> required <p>Returns:</p> Type Description <code>ScrapedScene | None</code> <p>ScrapedScene object if successful, None otherwise</p> <p>Examples:</p> <p>Scrape scene from URL: <pre><code>scene = await client.scrape_scene_url(\"https://example.com/scene/123\")\nif scene:\n    print(f\"Title: {scene.title}\")\n    print(f\"Date: {scene.date}\")\n    print(f\"Studio: {scene.studio.name if scene.studio else 'Unknown'}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_gallery_url","title":"scrape_gallery_url  <code>async</code>","text":"<pre><code>scrape_gallery_url(url: str) -&gt; ScrapedGallery | None\n</code></pre> <p>Scrape a complete gallery record based on a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to scrape gallery from</p> required <p>Returns:</p> Type Description <code>ScrapedGallery | None</code> <p>ScrapedGallery object if successful, None otherwise</p> <p>Examples:</p> <p>Scrape gallery from URL: <pre><code>gallery = await client.scrape_gallery_url(\"https://example.com/gallery/123\")\nif gallery:\n    print(f\"Title: {gallery.title}\")\n    print(f\"Date: {gallery.date}\")\n    print(f\"Performers: {len(gallery.performers or [])}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_image_url","title":"scrape_image_url  <code>async</code>","text":"<pre><code>scrape_image_url(url: str) -&gt; ScrapedImage | None\n</code></pre> <p>Scrape a complete image record based on a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to scrape image from</p> required <p>Returns:</p> Type Description <code>ScrapedImage | None</code> <p>ScrapedImage object if successful, None otherwise</p> <p>Examples:</p> <p>Scrape image from URL: <pre><code>image = await client.scrape_image_url(\"https://example.com/image/123\")\nif image:\n    print(f\"Title: {image.title}\")\n    print(f\"Date: {image.date}\")\n    print(f\"Tags: {len(image.tags or [])}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_movie_url","title":"scrape_movie_url  <code>async</code>","text":"<pre><code>scrape_movie_url(url: str) -&gt; ScrapedMovie | None\n</code></pre> <p>Scrape a complete movie record based on a URL.</p> <p>.. deprecated::     Use :meth:<code>scrape_group_url</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to scrape movie from</p> required <p>Returns:</p> Type Description <code>ScrapedMovie | None</code> <p>ScrapedMovie object if successful, None otherwise</p> <p>Examples:</p> <p>Scrape movie from URL: <pre><code>movie = await client.scrape_movie_url(\"https://example.com/movie/123\")\nif movie:\n    print(f\"Name: {movie.name}\")\n    print(f\"Date: {movie.date}\")\n    print(f\"Duration: {movie.duration}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.scrape_group_url","title":"scrape_group_url  <code>async</code>","text":"<pre><code>scrape_group_url(url: str) -&gt; ScrapedGroup | None\n</code></pre> <p>Scrape a complete group record based on a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to scrape group from</p> required <p>Returns:</p> Type Description <code>ScrapedGroup | None</code> <p>ScrapedGroup object if successful, None otherwise</p> <p>Examples:</p> <p>Scrape group from URL: <pre><code>group = await client.scrape_group_url(\"https://example.com/group/123\")\nif group:\n    print(f\"Name: {group.name}\")\n    print(f\"Date: {group.date}\")\n    print(f\"Synopsis: {group.synopsis}\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.reload_scrapers","title":"reload_scrapers  <code>async</code>","text":"<pre><code>reload_scrapers() -&gt; bool\n</code></pre> <p>Reload all scrapers from configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> <p>Examples:</p> <p>Reload scrapers after configuration change: <pre><code>success = await client.reload_scrapers()\nif success:\n    print(\"Scrapers reloaded successfully\")\n    # List scrapers to verify\n    scrapers = await client.list_scrapers([ScrapeContentType.SCENE])\n    print(f\"Found {len(scrapers)} scene scrapers\")\n</code></pre></p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.submit_stashbox_fingerprints","title":"submit_stashbox_fingerprints  <code>async</code>","text":"<pre><code>submit_stashbox_fingerprints(\n    input_data: StashBoxFingerprintSubmissionInput\n    | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Submit fingerprints to StashBox.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>StashBoxFingerprintSubmissionInput | dict[str, Any]</code> <p>StashBoxFingerprintSubmissionInput object or dictionary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.submit_stashbox_scene_draft","title":"submit_stashbox_scene_draft  <code>async</code>","text":"<pre><code>submit_stashbox_scene_draft(\n    input_data: StashBoxDraftSubmissionInput\n    | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Submit scene draft to StashBox.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>StashBoxDraftSubmissionInput | dict[str, Any]</code> <p>StashBoxDraftSubmissionInput object or dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>Draft ID</p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.submit_stashbox_performer_draft","title":"submit_stashbox_performer_draft  <code>async</code>","text":"<pre><code>submit_stashbox_performer_draft(\n    input_data: StashBoxDraftSubmissionInput\n    | dict[str, Any],\n) -&gt; str\n</code></pre> <p>Submit performer draft to StashBox.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>StashBoxDraftSubmissionInput | dict[str, Any]</code> <p>StashBoxDraftSubmissionInput object or dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>Draft ID</p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.stashbox_batch_performer_tag","title":"stashbox_batch_performer_tag  <code>async</code>","text":"<pre><code>stashbox_batch_performer_tag(\n    input_data: dict[str, Any],\n) -&gt; str\n</code></pre> <p>Batch tag performers from StashBox.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any]</code> <p>Batch performer tag input dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID</p>"},{"location":"api/client/mixins/scraper/#stash_graphql_client.client.mixins.scraper.ScraperClientMixin.stashbox_batch_studio_tag","title":"stashbox_batch_studio_tag  <code>async</code>","text":"<pre><code>stashbox_batch_studio_tag(\n    input_data: dict[str, Any],\n) -&gt; str\n</code></pre> <p>Batch tag studios from StashBox.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any]</code> <p>Batch studio tag input dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID</p>"},{"location":"api/client/mixins/studio/","title":"Studio Operations","text":"<p>Operations for managing studios (production companies).</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for studio-related client methods.</p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.find_studio","title":"find_studio  <code>async</code>","text":"<pre><code>find_studio(id: str) -&gt; Studio | None\n</code></pre> <p>Find a studio by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the studio to find</p> required <p>Returns:</p> Type Description <code>Studio | None</code> <p>Studio object if found, None otherwise</p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.find_studios","title":"find_studios  <code>async</code>","text":"<pre><code>find_studios(\n    filter_: dict[str, Any] | None = None,\n    studio_filter: dict[str, Any] | None = None,\n    q: str | None = None,\n) -&gt; FindStudiosResultType\n</code></pre> <p>Find studios matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>studio_filter</code> <code>dict[str, Any] | None</code> <p>Optional studio-specific filter</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <p>Returns:</p> Type Description <code>FindStudiosResultType</code> <p>FindStudiosResultType containing: - count: Total number of matching studios - studios: List of Studio objects</p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.create_studio","title":"create_studio  <code>async</code>","text":"<pre><code>create_studio(studio: Studio) -&gt; Studio\n</code></pre> <p>Create a new studio in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>studio</code> <code>Studio</code> <p>Studio object with the data to create. Required fields: - name: Studio name</p> required <p>Returns:</p> Type Description <code>Studio</code> <p>Created Studio object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the studio data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.update_studio","title":"update_studio  <code>async</code>","text":"<pre><code>update_studio(studio: Studio) -&gt; Studio\n</code></pre> <p>Update an existing studio in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>studio</code> <code>Studio</code> <p>Studio object with updated data. Required fields: - id: Studio ID to update Any other fields that are set will be updated. Fields that are None will be ignored.</p> required <p>Returns:</p> Type Description <code>Studio</code> <p>Updated Studio object with any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the studio data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.studio_destroy","title":"studio_destroy  <code>async</code>","text":"<pre><code>studio_destroy(\n    input_data: StudioDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete a studio.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>StudioDestroyInput | dict[str, Any]</code> <p>StudioDestroyInput object or dictionary containing: - id: Studio ID to delete (required)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the studio was successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the studio ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.studios_destroy","title":"studios_destroy  <code>async</code>","text":"<pre><code>studios_destroy(ids: list[str]) -&gt; bool\n</code></pre> <p>Delete multiple studios.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of studio IDs to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the studios were successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any studio ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.bulk_studio_update","title":"bulk_studio_update  <code>async</code>","text":"<pre><code>bulk_studio_update(\n    input_data: BulkStudioUpdateInput | dict[str, Any],\n) -&gt; list[Studio]\n</code></pre> <p>Bulk update studios.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>BulkStudioUpdateInput | dict[str, Any]</code> <p>BulkStudioUpdateInput object or dictionary containing: - ids: List of studio IDs to update (optional) - And any fields to update (e.g., url, rating100, etc.)</p> required <p>Returns:</p> Type Description <code>list[Studio]</code> <p>List of updated Studio objects</p> <p>Examples:</p> <p>Update multiple studios' ratings: <pre><code>studios = await client.bulk_studio_update({\n    \"ids\": [\"1\", \"2\", \"3\"],\n    \"rating100\": 80\n})\n</code></pre></p> <p>Add tags to multiple studios: <pre><code>from stash_graphql_client.types import BulkStudioUpdateInput, BulkUpdateIds\n\ninput_data = BulkStudioUpdateInput(\n    ids=[\"1\", \"2\", \"3\"],\n    tag_ids=BulkUpdateIds(ids=[\"tag1\", \"tag2\"], mode=\"ADD\")\n)\nstudios = await client.bulk_studio_update(input_data)\n</code></pre></p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.find_studio_hierarchy","title":"find_studio_hierarchy  <code>async</code>","text":"<pre><code>find_studio_hierarchy(studio_id: str) -&gt; list[Studio]\n</code></pre> <p>Get full parent chain from root to this studio.</p> <p>Recursively traverses the parent_studio relationship to build a complete hierarchy from the root studio down to the specified studio.</p> <p>Parameters:</p> Name Type Description Default <code>studio_id</code> <code>str</code> <p>The ID of the studio to get hierarchy for</p> required <p>Returns:</p> Type Description <code>list[Studio]</code> <p>List of Studio objects ordered from root (index 0) to the specified</p> <code>list[Studio]</code> <p>studio (last index). Returns empty list if studio not found.</p> <p>Examples:</p> <p>Get studio hierarchy: <pre><code># Studio structure: Root &gt; Parent &gt; Child\nhierarchy = await client.find_studio_hierarchy(\"child_id\")\n# Returns: [&lt;Root Studio&gt;, &lt;Parent Studio&gt;, &lt;Child Studio&gt;]\nfor i, studio in enumerate(hierarchy):\n    print(f\"Level {i}: {studio.name}\")\n</code></pre></p> <p>Check if studio has parents: <pre><code>hierarchy = await client.find_studio_hierarchy(\"studio_id\")\nif len(hierarchy) &gt; 1:\n    print(f\"Root studio: {hierarchy[0].name}\")\n    print(f\"Direct parent: {hierarchy[-2].name}\")\n</code></pre></p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.find_studio_root","title":"find_studio_root  <code>async</code>","text":"<pre><code>find_studio_root(studio_id: str) -&gt; Studio | None\n</code></pre> <p>Find the top-level parent studio.</p> <p>Traverses the parent chain to find the root studio (the one with no parent).</p> <p>Parameters:</p> Name Type Description Default <code>studio_id</code> <code>str</code> <p>The ID of the studio to find root for</p> required <p>Returns:</p> Type Description <code>Studio | None</code> <p>Root Studio object, or None if studio not found</p> <p>Examples:</p> <p>Get root studio: <pre><code>root = await client.find_studio_root(\"child_studio_id\")\nif root:\n    print(f\"Root studio: {root.name}\")\n</code></pre></p> <p>Compare studio with its root: <pre><code>studio = await client.find_studio(\"studio_id\")\nroot = await client.find_studio_root(\"studio_id\")\nif studio and root:\n    if studio.id == root.id:\n        print(\"This is a root studio\")\n    else:\n        print(f\"Root is: {root.name}\")\n</code></pre></p>"},{"location":"api/client/mixins/studio/#stash_graphql_client.client.mixins.studio.StudioClientMixin.map_studio_ids","title":"map_studio_ids  <code>async</code>","text":"<pre><code>map_studio_ids(\n    studios: list[str | dict[str, Any] | Studio],\n    create: bool = False,\n) -&gt; list[str]\n</code></pre> <p>Convert studio names/objects to IDs, optionally creating missing studios.</p> <p>This is a convenience method to resolve studio references to their IDs, reducing boilerplate when working with studio relationships.</p> <p>Parameters:</p> Name Type Description Default <code>studios</code> <code>list[str | dict[str, Any] | Studio]</code> <p>List of studio references, can be: - str: Studio name (searches for exact match) - dict: Studio filter criteria (e.g., {\"name\": \"Acme Studios\"}) - Studio: Studio object (extracts ID if present, otherwise searches by name)</p> required <code>create</code> <code>bool</code> <p>If True, create studios that don't exist. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of studio IDs. Skips studios that aren't found (unless create=True).</p> <p>Examples:</p> <p>Map studio names to IDs: <pre><code>studio_ids = await client.map_studio_ids([\"Acme\", \"Foo Studios\", \"Bar Inc\"])\n# Returns: [\"1\", \"2\", \"3\"] (IDs of existing studios)\n</code></pre></p> <p>Auto-create missing studios: <pre><code>studio_ids = await client.map_studio_ids(\n    [\"Acme\", \"NewStudio\"],\n    create=True\n)\n# Creates \"NewStudio\" if it doesn't exist\n</code></pre></p> <p>Mix of strings and Studio objects: <pre><code>studio_obj = Studio(name=\"Acme\")\nstudio_ids = await client.map_studio_ids([studio_obj, \"Foo Studios\"])\n</code></pre></p> <p>Use in scene creation: <pre><code>scene = Scene(\n    title=\"My Scene\",\n    studio=None  # Will populate with studio ID\n)\nstudio_ids = await client.map_studio_ids([\"Acme\"], create=True)\nif studio_ids:\n    scene.studio = Studio(id=studio_ids[0])\ncreated_scene = await client.create_scene(scene)\n</code></pre></p>"},{"location":"api/client/mixins/subscription/","title":"Subscription Operations","text":"<p>WebSocket subscriptions for real-time updates.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for subscription-related client methods.</p>"},{"location":"api/client/mixins/subscription/#stash_graphql_client.client.mixins.subscription.SubscriptionClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/subscription/#stash_graphql_client.client.mixins.subscription.SubscriptionClientMixin.subscribe_to_jobs","title":"subscribe_to_jobs  <code>async</code>","text":"<pre><code>subscribe_to_jobs() -&gt; AsyncIterator[\n    AsyncIterator[JobStatusUpdate]\n]\n</code></pre> <p>Subscribe to job status updates.</p> <p>Returns:</p> Type Description <code>AsyncIterator[AsyncIterator[JobStatusUpdate]]</code> <p>An async context manager that yields an async iterator of JobStatusUpdate objects</p> Example <pre><code>async with client.subscribe_to_jobs() as subscription:\n    async for update in subscription:\n        print(f\"Job {update.job.id}: {update.status} ({update.progress}%)\")\n        if update.status == \"FINISHED\":\n            break\n</code></pre>"},{"location":"api/client/mixins/subscription/#stash_graphql_client.client.mixins.subscription.SubscriptionClientMixin.subscribe_to_logs","title":"subscribe_to_logs  <code>async</code>","text":"<pre><code>subscribe_to_logs() -&gt; AsyncIterator[\n    AsyncIterator[list[LogEntry]]\n]\n</code></pre> <p>Subscribe to log entries.</p> <p>Returns:</p> Type Description <code>AsyncIterator[AsyncIterator[list[LogEntry]]]</code> <p>An async context manager that yields an async iterator of LogEntry lists</p> Example <pre><code>async with client.subscribe_to_logs() as subscription:\n    async for logs in subscription:\n        for entry in logs:\n            print(f\"{entry.time} [{entry.level}] {entry.message}\")\n</code></pre>"},{"location":"api/client/mixins/subscription/#stash_graphql_client.client.mixins.subscription.SubscriptionClientMixin.subscribe_to_scan_complete","title":"subscribe_to_scan_complete  <code>async</code>","text":"<pre><code>subscribe_to_scan_complete() -&gt; AsyncIterator[\n    AsyncIterator[bool]\n]\n</code></pre> <p>Subscribe to scan completion events.</p> <p>Returns:</p> Type Description <code>AsyncIterator[AsyncIterator[bool]]</code> <p>An async context manager that yields an async iterator of scan completion events</p> Example <pre><code>async with client.subscribe_to_scan_complete() as subscription:\n    async for _ in subscription:\n        print(\"Scan completed!\")\n        await client.metadata_generate(...)  # Generate after scan\n</code></pre>"},{"location":"api/client/mixins/subscription/#stash_graphql_client.client.mixins.subscription.SubscriptionClientMixin.wait_for_job_with_updates","title":"wait_for_job_with_updates  <code>async</code>","text":"<pre><code>wait_for_job_with_updates(\n    job_id: str,\n    status: JobStatus = FINISHED,\n    timeout: float = 120,\n) -&gt; bool | None\n</code></pre> <p>Wait for a job to complete with real-time updates.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Job ID to wait for</p> required <code>status</code> <code>JobStatus</code> <p>Status to wait for</p> <code>FINISHED</code> <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds</p> <code>120</code> <p>Returns:</p> Type Description <code>bool | None</code> <p>True if job reached desired status</p> <code>bool | None</code> <p>False if job finished with different status</p> <code>bool | None</code> <p>None if job not found</p> Example <pre><code>job_id = await client.metadata_generate(...)\nif await client.wait_for_job_with_updates(job_id):\n    print(\"Generation complete!\")\n</code></pre>"},{"location":"api/client/mixins/system_query/","title":"System Query Operations","text":"<p>Operations for querying system status and statistics.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for system query methods.</p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.get_system_status","title":"get_system_status  <code>async</code>","text":"<pre><code>get_system_status() -&gt; SystemStatus | None\n</code></pre> <p>Get the current Stash system status.</p> <p>Returns:</p> Type Description <code>SystemStatus | None</code> <p>SystemStatus object containing system information and status</p> <code>SystemStatus | None</code> <p>None if the query fails</p> <p>Examples:</p> <p>Check system status: <pre><code>status = await client.get_system_status()\nif status:\n    print(f\"System status: {status.status}\")\n    print(f\"Database path: {status.databasePath}\")\n</code></pre></p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.check_system_ready","title":"check_system_ready  <code>async</code>","text":"<pre><code>check_system_ready() -&gt; None\n</code></pre> <p>Check if the Stash system is ready for processing.</p> <p>This method queries the system status and raises an exception if the system is not in OK status. It should be called before starting any processing operations.</p> <p>Raises:</p> Type Description <code>StashSystemNotReadyError</code> <p>If system status is SETUP or NEEDS_MIGRATION</p> <code>RuntimeError</code> <p>If system status cannot be determined</p> <p>Examples:</p> <p>Validate system before processing: <pre><code>try:\n    await client.check_system_ready()\n    # Safe to proceed with processing\n    await client.metadata_scan()\nexcept StashSystemNotReadyError as e:\n    print(f\"System not ready: {e}\")\n    # Handle migration or setup\n</code></pre></p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.stats","title":"stats  <code>async</code>","text":"<pre><code>stats() -&gt; StatsResultType\n</code></pre> <p>Get system statistics.</p> <p>Returns:</p> Type Description <code>StatsResultType</code> <p>StatsResultType object containing counts and metrics for all entity types</p> <p>Examples:</p> <p>Get system statistics: <pre><code>stats = await client.stats()\nprint(f\"Total scenes: {stats.scene_count}\")\nprint(f\"Total performers: {stats.performer_count}\")\nprint(f\"Total O-count: {stats.total_o_count}\")\nprint(f\"Library size: {stats.scenes_size / (1024**3):.2f} GB\")\n</code></pre></p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.logs","title":"logs  <code>async</code>","text":"<pre><code>logs() -&gt; list[LogEntry]\n</code></pre> <p>Get system logs.</p> <p>Returns:</p> Type Description <code>list[LogEntry]</code> <p>List of LogEntry objects containing log messages with timestamps and levels</p> <p>Examples:</p> <p>Get recent logs: <pre><code>logs = await client.logs()\nfor log in logs[-10:]:  # Last 10 entries\n    print(f\"[{log.time}] {log.level}: {log.message}\")\n</code></pre></p> <p>Filter by level: <pre><code>from stash_graphql_client.types import LogLevel\n\nlogs = await client.logs()\nerrors = [log for log in logs if log.level == LogLevel.ERROR]\nprint(f\"Found {len(errors)} errors\")\n</code></pre></p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.dlna_status","title":"dlna_status  <code>async</code>","text":"<pre><code>dlna_status() -&gt; DLNAStatus\n</code></pre> <p>Get DLNA server status.</p> <p>Returns:</p> Type Description <code>DLNAStatus</code> <p>DLNAStatus object containing DLNA server information</p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.directory","title":"directory  <code>async</code>","text":"<pre><code>directory(\n    path: str | None = None, locale: str = \"en\"\n) -&gt; Directory\n</code></pre> <p>Browse filesystem directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | None</code> <p>The directory path to list. If None, returns root directories</p> <code>None</code> <code>locale</code> <code>str</code> <p>Desired collation locale (e.g., 'en-US', 'pt-BR'). Default is 'en'</p> <code>'en'</code> <p>Returns:</p> Type Description <code>Directory</code> <p>Directory object containing path information and subdirectories</p> <p>Examples:</p> <p>List root directories: <pre><code>dir_info = await client.directory()\nprint(f\"Root directories: {dir_info.directories}\")\n</code></pre></p> <p>Browse specific path: <pre><code>dir_info = await client.directory(path=\"/media/videos\")\nprint(f\"Current path: {dir_info.path}\")\nprint(f\"Parent: {dir_info.parent}\")\nprint(f\"Subdirectories: {dir_info.directories}\")\n</code></pre></p> <p>Use specific locale for sorting: <pre><code>dir_info = await client.directory(path=\"/home/user\", locale=\"pt-BR\")\nfor subdir in dir_info.directories:\n    print(subdir)\n</code></pre></p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.sql_query","title":"sql_query  <code>async</code>","text":"<pre><code>sql_query(\n    sql: str, args: list[Any] | None = None\n) -&gt; SQLQueryResult\n</code></pre> <p>Execute a SQL query that returns rows.</p> Warning <p>This is a DANGEROUS operation that executes arbitrary SQL against the Stash database. Use with extreme caution. Incorrect queries can corrupt your database or expose sensitive information.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>The SQL query string to execute</p> required <code>args</code> <code>list[Any] | None</code> <p>Optional list of query parameters to bind to the SQL statement</p> <code>None</code> <p>Returns:</p> Type Description <code>SQLQueryResult</code> <p>SQLQueryResult containing columns and rows from the query result</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the query execution fails or SQL support is not available</p> <p>Examples:</p> <p>Query database for scenes: <pre><code>result = await client.sql_query(\n    \"SELECT id, title FROM scenes WHERE rating100 &gt; ?\",\n    args=[80]\n)\nprint(f\"Columns: {result.columns}\")\nfor row in result.rows:\n    print(f\"Scene ID: {row[0]}, Title: {row[1]}\")\n</code></pre></p> <p>Count performers by gender: <pre><code>result = await client.sql_query(\n    \"SELECT gender, COUNT(*) FROM performers GROUP BY gender\"\n)\nfor row in result.rows:\n    print(f\"{row[0]}: {row[1]} performers\")\n</code></pre></p> Note <p>This feature requires Stash version that supports SQL queries. The exact version requirement should be documented in the Stash API.</p>"},{"location":"api/client/mixins/system_query/#stash_graphql_client.client.mixins.system_query.SystemQueryClientMixin.sql_exec","title":"sql_exec  <code>async</code>","text":"<pre><code>sql_exec(\n    sql: str, args: list[Any] | None = None\n) -&gt; SQLExecResult\n</code></pre> <p>Execute a SQL statement without returning rows (INSERT, UPDATE, DELETE).</p> Warning <p>This is a DANGEROUS operation that executes arbitrary SQL against the Stash database. Use with EXTREME caution. Incorrect statements can corrupt or destroy your database. Always backup before using this method.</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>The SQL statement string to execute</p> required <code>args</code> <code>list[Any] | None</code> <p>Optional list of statement parameters to bind to the SQL</p> <code>None</code> <p>Returns:</p> Type Description <code>SQLExecResult</code> <p>SQLExecResult containing rows_affected and last_insert_id</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the statement execution fails or SQL support is not available</p> <p>Examples:</p> <p>Update scene ratings: <pre><code>result = await client.sql_exec(\n    \"UPDATE scenes SET rating100 = ? WHERE id = ?\",\n    args=[95, \"123\"]\n)\nprint(f\"Rows affected: {result.rows_affected}\")\n</code></pre></p> <p>Delete orphaned tags (BE CAREFUL!): <pre><code>result = await client.sql_exec(\n    \"DELETE FROM tags WHERE id NOT IN (SELECT tag_id FROM scene_tags)\"\n)\nprint(f\"Deleted {result.rows_affected} orphaned tags\")\n</code></pre></p> <p>Insert custom metadata: <pre><code>result = await client.sql_exec(\n    \"INSERT INTO custom_metadata (entity_id, key, value) VALUES (?, ?, ?)\",\n    args=[\"scene-123\", \"custom_field\", \"custom_value\"]\n)\nprint(f\"Last insert ID: {result.last_insert_id}\")\n</code></pre></p> Note <p>This feature requires Stash version that supports SQL execution. The exact version requirement should be documented in the Stash API. ALWAYS test queries in a development environment before production use.</p>"},{"location":"api/client/mixins/tag/","title":"Tag Operations","text":"<p>Operations for managing tags (categories/labels).</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for tag-related client methods.</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.find_tag","title":"find_tag  <code>async</code>","text":"<pre><code>find_tag(id: str) -&gt; Tag | None\n</code></pre> <p>Find a tag by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the tag to find</p> required <p>Returns:</p> Type Description <code>Tag | None</code> <p>Tag object if found, None otherwise</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.find_tags","title":"find_tags  <code>async</code>","text":"<pre><code>find_tags(\n    filter_: dict[str, Any] | None = None,\n    tag_filter: dict[str, Any] | None = None,\n    q: str | None = None,\n) -&gt; FindTagsResultType\n</code></pre> <p>Find tags matching the given filters.</p> <p>Parameters:</p> Name Type Description Default <code>filter_</code> <code>dict[str, Any] | None</code> <p>Optional general filter parameters: - q: str (search query) - direction: SortDirectionEnum (ASC/DESC) - page: int - per_page: int - sort: str (field to sort by)</p> <code>None</code> <code>tag_filter</code> <code>dict[str, Any] | None</code> <p>Optional tag-specific filter</p> <code>None</code> <code>q</code> <code>str | None</code> <p>Optional search query (alternative to filter_[\"q\"])</p> <code>None</code> <p>Returns:</p> Type Description <code>FindTagsResultType</code> <p>FindTagsResultType containing: - count: Total number of matching tags - tags: List of Tag objects</p> <p>Note:</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.create_tag","title":"create_tag  <code>async</code>","text":"<pre><code>create_tag(tag: Tag) -&gt; Tag\n</code></pre> <p>Create a new tag in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag</code> <p>Tag object with the data to create. Required fields: - name: Tag name</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>Created Tag object with ID and any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.tags_merge","title":"tags_merge  <code>async</code>","text":"<pre><code>tags_merge(source: list[str], destination: str) -&gt; Tag\n</code></pre> <p>Merge multiple tags into one.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>list[str]</code> <p>List of source tag IDs to merge</p> required <code>destination</code> <code>str</code> <p>Destination tag ID</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>Updated destination Tag object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.bulk_tag_update","title":"bulk_tag_update  <code>async</code>","text":"<pre><code>bulk_tag_update(\n    ids: list[str],\n    description: str | None = None,\n    aliases: list[str] | None = None,\n    favorite: bool | None = None,\n    parent_ids: list[str] | None = None,\n    child_ids: list[str] | None = None,\n) -&gt; list[Tag]\n</code></pre> <p>Update multiple tags at once.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of tag IDs to update</p> required <code>description</code> <code>str | None</code> <p>Optional description to set</p> <code>None</code> <code>aliases</code> <code>list[str] | None</code> <p>Optional list of aliases to set</p> <code>None</code> <code>favorite</code> <code>bool | None</code> <p>Optional favorite flag to set</p> <code>None</code> <code>parent_ids</code> <code>list[str] | None</code> <p>Optional list of parent tag IDs to set</p> <code>None</code> <code>child_ids</code> <code>list[str] | None</code> <p>Optional list of child tag IDs to set</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Tag]</code> <p>List of updated Tag objects</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.update_tag","title":"update_tag  <code>async</code>","text":"<pre><code>update_tag(tag: Tag) -&gt; Tag\n</code></pre> <p>Update an existing tag in Stash.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag</code> <p>Tag object with updated data. Required fields: - id: Tag ID to update Any other fields that are set will be updated. Fields that are None will be ignored.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>Updated Tag object with any server-generated fields</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag data is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.tag_destroy","title":"tag_destroy  <code>async</code>","text":"<pre><code>tag_destroy(\n    input_data: TagDestroyInput | dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Delete a tag.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>TagDestroyInput | dict[str, Any]</code> <p>TagDestroyInput object or dictionary containing: - id: Tag ID to delete (required)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the tag was successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.tags_destroy","title":"tags_destroy  <code>async</code>","text":"<pre><code>tags_destroy(ids: list[str]) -&gt; bool\n</code></pre> <p>Delete multiple tags.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of tag IDs to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the tags were successfully deleted</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any tag ID is invalid</p> <code>TransportError</code> <p>If the request fails</p>"},{"location":"api/client/mixins/tag/#stash_graphql_client.client.mixins.tag.TagClientMixin.map_tag_ids","title":"map_tag_ids  <code>async</code>","text":"<pre><code>map_tag_ids(\n    tags: list[str | dict[str, Any] | Tag],\n    create: bool = False,\n) -&gt; list[str]\n</code></pre> <p>Convert tag names/objects to IDs, optionally creating missing tags.</p> <p>This is a convenience method to resolve tag references to their IDs, reducing boilerplate when working with tag relationships.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>list[str | dict[str, Any] | Tag]</code> <p>List of tag references, can be: - str: Tag name (searches for exact match) - dict: Tag filter criteria (e.g., {\"name\": \"Action\"}) - Tag: Tag object (extracts ID if present, otherwise searches by name)</p> required <code>create</code> <code>bool</code> <p>If True, create tags that don't exist. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of tag IDs. Skips tags that aren't found (unless create=True).</p> <p>Examples:</p> <p>Map tag names to IDs: <pre><code>tag_ids = await client.map_tag_ids([\"Action\", \"Drama\", \"Comedy\"])\n# Returns: [\"1\", \"2\", \"3\"] (IDs of existing tags)\n</code></pre></p> <p>Auto-create missing tags: <pre><code>tag_ids = await client.map_tag_ids(\n    [\"Action\", \"NewTag\", \"Drama\"],\n    create=True\n)\n# Creates \"NewTag\" if it doesn't exist\n</code></pre></p> <p>Mix of strings and Tag objects: <pre><code>tag_obj = Tag(name=\"Action\")\ntag_ids = await client.map_tag_ids([tag_obj, \"Drama\"])\n</code></pre></p> <p>Use in scene creation: <pre><code>scene = Scene(\n    title=\"My Scene\",\n    tags=[]  # Will populate with tag IDs\n)\nscene.tags = await client.map_tag_ids(\n    [\"Action\", \"Drama\"],\n    create=True\n)\ncreated_scene = await client.create_scene(scene)\n</code></pre></p>"},{"location":"api/client/mixins/version/","title":"Version Operations","text":"<p>Operations for checking Stash version information.</p> <p>               Bases: <code>StashClientProtocol</code></p> <p>Mixin for version-related methods.</p>"},{"location":"api/client/mixins/version/#stash_graphql_client.client.mixins.version.VersionClientMixin-functions","title":"Functions","text":""},{"location":"api/client/mixins/version/#stash_graphql_client.client.mixins.version.VersionClientMixin.version","title":"version  <code>async</code>","text":"<pre><code>version() -&gt; Version\n</code></pre> <p>Get the current Stash version information.</p> <p>Returns:</p> Type Description <code>Version</code> <p>Version object containing version, hash, and build_time</p> <p>Examples:</p> <p>Get current version: <pre><code>version = await client.version()\nprint(f\"Stash version: {version.version}\")\nprint(f\"Git hash: {version.hash}\")\nprint(f\"Build time: {version.build_time}\")\n</code></pre></p>"},{"location":"api/client/mixins/version/#stash_graphql_client.client.mixins.version.VersionClientMixin.latestversion","title":"latestversion  <code>async</code>","text":"<pre><code>latestversion() -&gt; LatestVersion\n</code></pre> <p>Get the latest available Stash version from GitHub.</p> <p>Returns:</p> Type Description <code>LatestVersion</code> <p>LatestVersion object containing version, shorthash, release_date, and url</p> <p>Examples:</p> <p>Check for updates: <pre><code>current = await client.version()\nlatest = await client.latestversion()\nif current.version != latest.version:\n    print(f\"Update available: {latest.version}\")\n    print(f\"Release date: {latest.release_date}\")\n    print(f\"Download: {latest.url}\")\n</code></pre></p>"},{"location":"architecture/bidirectional-relationships/","title":"Bi-Directional Relationship Implementation","text":"<p>Last Updated: 2025-12-14 Status: Implemented - Tier 1 (Automatic Backend Sync)</p>"},{"location":"architecture/bidirectional-relationships/#executive-summary","title":"Executive Summary","text":"<p>Empirical testing confirms that Stash's backend automatically maintains bidirectional referential integrity for ALL relationship types. No dual mutation coordination is required. This document details the findings and implementation approach.</p>"},{"location":"architecture/bidirectional-relationships/#empirical-verification-results","title":"Empirical Verification Results","text":"<p>All tests passed (8/8) confirming automatic bidirectional synchronization:</p> Test Relationship Pattern Result Gallery \u2192 Scene (forward) Many-to-Many Direct field \u2705 Auto-sync Scene \u2192 Gallery (reverse) Many-to-Many Direct field \u2705 Auto-sync Tag Parent \u2192 Child Self-referential Direct field \u2705 Auto-sync Scene \u2192 Performer Many-to-Many Direct field \u2705 Auto-sync Scene \u2192 Studio Many-to-One Filter query \u2705 Auto-sync Group Hierarchy Complex metadata Nested objects \u2705 Auto-sync Edge Case: Removal Deletion propagation N/A \u2705 Auto-sync Edge Case: Bulk Update Multiple relationships N/A \u2705 Auto-sync"},{"location":"architecture/bidirectional-relationships/#test-details","title":"Test Details","text":"<p>Test Script: <code>verify_bidirectional_relationships.py</code> Verification Date: 2025-12-14 Stash Version: Latest (as of test date)</p> <p>Each test: 1. Created entities with relationships 2. Updated one side of the relationship 3. Verified the inverse side automatically updated 4. Cleaned up all test data</p>"},{"location":"architecture/bidirectional-relationships/#relationship-query-patterns","title":"Relationship Query Patterns","text":""},{"location":"architecture/bidirectional-relationships/#pattern-a-direct-nested-fields","title":"Pattern A: Direct Nested Fields","text":"<p>Used by: Gallery, Performer, Tag, Group</p> <p>Reading: <pre><code>query {\n  findGallery(id: \"123\") {\n    scenes {        # Direct field returns [Scene!]!\n      id\n      title\n    }\n  }\n}\n</code></pre></p> <p>Writing: <pre><code>mutation {\n  sceneUpdate(input: {\n    id: \"456\"\n    gallery_ids: [\"123\"]  # Updates scene \u2192 gallery link\n  }) {\n    id\n  }\n}\n# Backend automatically updates gallery.scenes\n</code></pre></p> <p>Python Example: <pre><code># Reading\nscene = await client.find_scene(\"456\")\ngalleries = scene.galleries  # [Gallery, Gallery, ...]\n\n# Writing - both directions sync automatically\nscene.galleries.append(new_gallery)\nawait scene.save(client)\n# new_gallery.scenes now includes this scene (no second save needed!)\n</code></pre></p>"},{"location":"architecture/bidirectional-relationships/#pattern-b-filter-based-queries","title":"Pattern B: Filter-Based Queries","text":"<p>Used by: Studio (and potentially others)</p> <p>Why this pattern? - More flexible (supports pagination, sorting, complex filters) - Studio doesn't have a direct <code>scenes</code> field - Instead, query scenes BY studio using filters</p> <p>Reading: <pre><code>query {\n  findScenes(\n    scene_filter: {\n      studios: {\n        value: [\"studio_id\"]\n        modifier: INCLUDES\n      }\n    }\n  ) {\n    count\n    scenes {\n      id\n      title\n    }\n  }\n}\n</code></pre></p> <p>Writing: <pre><code>mutation {\n  sceneUpdate(input: {\n    id: \"456\"\n    studio_id: \"studio_id\"\n  }) {\n    id\n  }\n}\n# Backend automatically updates studio.scene_count and filter results\n</code></pre></p> <p>Python Example: <pre><code># Reading - use filter query\nscenes = await client.find_scenes(\n    scene_filter={\"studios\": {\"value\": [studio.id]}}\n)\n\n# Writing - same as Pattern A\nscene.studio = new_studio\nawait scene.save(client)\n# Filter queries now return this scene for new_studio\n</code></pre></p>"},{"location":"architecture/bidirectional-relationships/#pattern-c-complex-objects-with-metadata","title":"Pattern C: Complex Objects with Metadata","text":"<p>Used by: Group hierarchies</p> <p>Why this pattern? - Relationships have additional metadata (e.g., description) - Not just a simple ID list</p> <p>Schema: <pre><code>type GroupDescription {\n  group: Group!         # The related group\n  description: String   # Metadata about this relationship\n}\n\ntype Group {\n  sub_groups: [GroupDescription!]!\n  containing_groups: [GroupDescription!]!\n}\n</code></pre></p> <p>Reading: <pre><code>query {\n  findGroup(id: \"123\") {\n    sub_groups {\n      group {\n        id\n        name\n      }\n      description  # Why this sub-group exists\n    }\n  }\n}\n</code></pre></p> <p>Writing: <pre><code>mutation {\n  groupUpdate(input: {\n    id: \"123\"\n    sub_groups: [{\n      group_id: \"456\"\n      description: \"Season 1\"\n    }]\n  }) {\n    id\n  }\n}\n# Backend automatically updates group 456's containing_groups\n</code></pre></p> <p>Python Example: <pre><code># Reading - nested structure\ngroup = await client.find_group(\"123\")\nfor sub_group_desc in group.sub_groups:\n    sub_group = sub_group_desc.group\n    notes = sub_group_desc.description\n\n# Writing\ngroup.sub_groups = [\n    GroupDescriptionInput(group_id=\"456\", description=\"Season 1\")\n]\nawait group.save(client)\n# Group 456's containing_groups now includes group 123\n</code></pre></p>"},{"location":"architecture/bidirectional-relationships/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"architecture/bidirectional-relationships/#relationshipmetadata-class","title":"RelationshipMetadata Class","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Callable, Literal\n\n@dataclass(frozen=True)\nclass RelationshipMetadata:\n    \"\"\"Metadata describing a bidirectional relationship.\n\n    All relationships in Stash auto-sync bidirectionally via backend\n    referential integrity. This metadata documents how to read/write\n    each relationship and provides convenience helpers.\n    \"\"\"\n\n    # ===== Write Configuration (Mutations) =====\n    target_field: str\n    \"\"\"Field name in *UpdateInput/*CreateInput (e.g., 'gallery_ids').\"\"\"\n\n    is_list: bool\n    \"\"\"True for many-to-many, False for many-to-one.\"\"\"\n\n    transform: Callable[[Any], Any] | None = None\n    \"\"\"Optional transform for complex types (e.g., StashID \u2192 StashIDInput).\"\"\"\n\n    # ===== Read Configuration (Queries) =====\n    query_field: str | None = None\n    \"\"\"Field name when reading (e.g., 'galleries'). Defaults to relationship name.\"\"\"\n\n    inverse_type: type | None = None\n    \"\"\"Type of the related entity (e.g., Gallery).\"\"\"\n\n    inverse_query_field: str | None = None\n    \"\"\"Field name on inverse type (e.g., 'scenes' on Gallery).\"\"\"\n\n    # ===== Query Strategy =====\n    query_strategy: Literal[\"direct_field\", \"filter_query\", \"complex_object\"] = \"direct_field\"\n    \"\"\"How to query the inverse relationship:\n    - 'direct_field': Use nested field (e.g., gallery.scenes)\n    - 'filter_query': Use find* with filter (e.g., findScenes(scene_filter))\n    - 'complex_object': Nested object with metadata (e.g., group.sub_groups[].group)\n    \"\"\"\n\n    filter_query_hint: str | None = None\n    \"\"\"For filter_query strategy, example filter usage.\"\"\"\n\n    # ===== Documentation =====\n    auto_sync: bool = True\n    \"\"\"Backend maintains referential integrity (always True for Stash).\"\"\"\n\n    notes: str = \"\"\n    \"\"\"Additional implementation notes or caveats.\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Set defaults after init.\"\"\"\n        # Default query_field to target_field if not provided\n        if self.query_field is None:\n            object.__setattr__(self, 'query_field', self.target_field.replace('_ids', 's').replace('_id', ''))\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#usage-in-entity-types","title":"Usage in Entity Types","text":""},{"location":"architecture/bidirectional-relationships/#example-1-scene-multiple-patterns","title":"Example 1: Scene (Multiple Patterns)","text":"<pre><code>class Scene(StashObject):\n    __type_name__ = \"Scene\"\n    __update_input_type__ = SceneUpdateInput\n\n    __relationships__ = {\n        # Pattern A: Direct field (many-to-many)\n        \"galleries\": RelationshipMetadata(\n            target_field=\"gallery_ids\",\n            is_list=True,\n            query_field=\"galleries\",\n            inverse_type=\"Gallery\",  # Forward ref to avoid circular import\n            inverse_query_field=\"scenes\",\n            query_strategy=\"direct_field\",\n            notes=\"Both scene.galleries and gallery.scenes auto-sync\"\n        ),\n\n        # Pattern A: Direct field (many-to-many)\n        \"performers\": RelationshipMetadata(\n            target_field=\"performer_ids\",\n            is_list=True,\n            query_field=\"performers\",\n            inverse_type=\"Performer\",\n            inverse_query_field=\"scenes\",\n            query_strategy=\"direct_field\",\n        ),\n\n        # Pattern B: Filter query (many-to-one)\n        \"studio\": RelationshipMetadata(\n            target_field=\"studio_id\",\n            is_list=False,\n            query_field=\"studio\",\n            inverse_type=\"Studio\",\n            inverse_query_field=None,  # No direct field on Studio\n            query_strategy=\"filter_query\",\n            filter_query_hint='findScenes(scene_filter={studios: {value: [studio_id]}})',\n            notes=\"Studio has scene_count and filter queries, not direct scenes field\"\n        ),\n\n        # Pattern A: Direct field (many-to-many)\n        \"tags\": RelationshipMetadata(\n            target_field=\"tag_ids\",\n            is_list=True,\n            query_field=\"tags\",\n            inverse_type=\"Tag\",\n            inverse_query_field=None,  # Tag has scene_count only\n            query_strategy=\"direct_field\",\n            notes=\"Tag has scene_count resolver, not scenes list\"\n        ),\n\n        # Complex: StashID requires transform\n        \"stash_ids\": RelationshipMetadata(\n            target_field=\"stash_ids\",\n            is_list=True,\n            transform=lambda s: StashIDInput(endpoint=s.endpoint, stash_id=s.stash_id),\n            query_field=\"stash_ids\",\n            notes=\"Requires transform to StashIDInput\"\n        ),\n    }\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#example-2-group-complex-objects","title":"Example 2: Group (Complex Objects)","text":"<pre><code>class Group(StashObject):\n    __type_name__ = \"Group\"\n    __update_input_type__ = GroupUpdateInput\n\n    __relationships__ = {\n        # Pattern C: Complex objects with metadata\n        \"sub_groups\": RelationshipMetadata(\n            target_field=\"sub_groups\",\n            is_list=True,\n            transform=lambda g: GroupDescriptionInput(\n                group_id=g.group.id if isinstance(g, GroupDescription) else g.id,\n                description=g.description if isinstance(g, GroupDescription) else None\n            ),\n            query_field=\"sub_groups\",\n            inverse_type=\"Group\",\n            inverse_query_field=\"containing_groups\",\n            query_strategy=\"complex_object\",\n            notes=\"Uses GroupDescription wrapper with nested group + description\"\n        ),\n\n        \"containing_groups\": RelationshipMetadata(\n            target_field=\"containing_groups\",\n            is_list=True,\n            transform=lambda g: GroupDescriptionInput(\n                group_id=g.group.id if isinstance(g, GroupDescription) else g.id,\n                description=g.description if isinstance(g, GroupDescription) else None\n            ),\n            query_field=\"containing_groups\",\n            inverse_type=\"Group\",\n            inverse_query_field=\"sub_groups\",\n            query_strategy=\"complex_object\",\n        ),\n    }\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#convenience-helper-methods","title":"Convenience Helper Methods","text":""},{"location":"architecture/bidirectional-relationships/#direct-field-helpers","title":"Direct Field Helpers","text":"<pre><code>class Scene(StashObject):\n    async def add_to_gallery(self, gallery: \"Gallery\") -&gt; None:\n        \"\"\"Add this scene to a gallery (auto-syncs both sides).\n\n        Backend automatically updates gallery.scenes - no second mutation needed.\n        \"\"\"\n        if gallery not in self.galleries:\n            self.galleries.append(gallery)\n            await self.save()\n\n    async def remove_from_gallery(self, gallery: \"Gallery\") -&gt; None:\n        \"\"\"Remove this scene from a gallery (auto-syncs both sides).\"\"\"\n        if gallery in self.galleries:\n            self.galleries.remove(gallery)\n            await self.save()\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#filter-query-helpers","title":"Filter Query Helpers","text":"<pre><code>class Studio(StashObject):\n    async def get_scenes(\n        self,\n        page: int = 1,\n        per_page: int = 40,\n        sort: str = \"date\",\n        direction: str = \"DESC\",\n        **additional_filters\n    ) -&gt; \"FindScenesResultType\":\n        \"\"\"Query all scenes for this studio using filter-based query.\n\n        This is more powerful than a direct field since it supports:\n        - Pagination\n        - Sorting\n        - Additional filters\n\n        Args:\n            page: Page number (1-indexed)\n            per_page: Results per page\n            sort: Sort field (date, title, rating, etc.)\n            direction: Sort direction (ASC/DESC)\n            **additional_filters: Additional scene filters\n\n        Returns:\n            FindScenesResultType with count and scenes\n        \"\"\"\n        from .client import StashClient  # Avoid circular import\n\n        client = self._get_client()\n        return await client.find_scenes(\n            filter={\"page\": page, \"per_page\": per_page, \"sort\": sort, \"direction\": direction},\n            scene_filter={\"studios\": {\"value\": [self.id], \"modifier\": \"INCLUDES\"}, **additional_filters}\n        )\n\n    async def get_scene_count(self) -&gt; int:\n        \"\"\"Get count of scenes for this studio (uses resolver field).\"\"\"\n        # If already loaded, return cached\n        if self.scene_count is not UNSET:\n            return self.scene_count\n\n        # Otherwise re-fetch with scene_count field\n        client = self._get_client()\n        fresh = await client.find_studio(self.id, fields=[\"scene_count\"])\n        return fresh.scene_count\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#complex-object-helpers","title":"Complex Object Helpers","text":"<p>Note: The Group convenience helpers shown below are planned for future implementation. Currently, manage group relationships using direct field assignment with <code>containing_groups</code> and <code>sub_groups</code> fields. See Quick Reference - Convenience Helpers for currently implemented helpers.</p> <pre><code>class Group(StashObject):\n    async def add_sub_group(\n        self,\n        sub_group: \"Group\",\n        description: str | None = None\n    ) -&gt; None:\n        \"\"\"Add a sub-group to this group (auto-syncs both sides).\n\n        Args:\n            sub_group: The group to add as a sub-group\n            description: Optional description of this relationship\n        \"\"\"\n        sub_group_desc = GroupDescriptionInput(\n            group_id=sub_group.id,\n            description=description\n        )\n\n        if not any(sg.group.id == sub_group.id for sg in self.sub_groups):\n            self.sub_groups.append(sub_group_desc)\n            await self.save()\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#migration-notes","title":"Migration Notes","text":""},{"location":"architecture/bidirectional-relationships/#before-old-pattern","title":"Before (Old Pattern)","text":"<pre><code>__relationships__ = {\n    \"studio\": (\"studio_id\", False, None),  # (target_field, is_list, transform)\n    \"performers\": (\"performer_ids\", True, None),\n    \"galleries\": (\"gallery_ids\", True, None),\n}\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#after-new-pattern","title":"After (New Pattern)","text":"<pre><code>__relationships__ = {\n    \"studio\": RelationshipMetadata(\n        target_field=\"studio_id\",\n        is_list=False,\n        inverse_type=\"Studio\",\n        query_strategy=\"filter_query\",\n        filter_query_hint='findScenes(scene_filter={studios: {value: [studio_id]}})',\n    ),\n    \"performers\": RelationshipMetadata(\n        target_field=\"performer_ids\",\n        is_list=True,\n        inverse_type=\"Performer\",\n        inverse_query_field=\"scenes\",\n    ),\n    \"galleries\": RelationshipMetadata(\n        target_field=\"gallery_ids\",\n        is_list=True,\n        inverse_type=\"Gallery\",\n        inverse_query_field=\"scenes\",\n    ),\n}\n</code></pre>"},{"location":"architecture/bidirectional-relationships/#backward-compatibility","title":"Backward Compatibility","text":"<p>The new <code>RelationshipMetadata</code> class is designed to be backward compatible with the existing tuple pattern during migration:</p> <ol> <li>Both patterns will coexist during transition</li> <li>Helper methods will check metadata type and handle both</li> <li>Gradual migration: update one entity type at a time</li> <li>Full backward compatibility maintained until all types migrated</li> </ol>"},{"location":"architecture/bidirectional-relationships/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>\u2705 All relationships auto-sync - Backend maintains referential integrity</li> <li>\u2705 No dual mutations needed - Single update syncs both sides</li> <li>\u2705 Three query patterns - Direct fields, filters, complex objects</li> <li>\u2705 Edge cases work - Removals and bulk updates both auto-sync</li> <li>\u2705 Metadata for documentation - Not for sync coordination</li> <li>\u2705 Convenience helpers - Simplify common operations</li> </ol>"},{"location":"architecture/bidirectional-relationships/#future-enhancements","title":"Future Enhancements","text":"<ul> <li> Auto-generate relationship metadata from GraphQL schema</li> <li> Add type hints for forward references (avoid circular imports)</li> <li> Generate convenience helpers automatically</li> <li> Add relationship validation (ensure IDs exist)</li> <li> Performance optimization for bulk relationship queries</li> </ul>"},{"location":"architecture/bidirectional-relationships/#see-also","title":"See Also","text":"<ul> <li>UNSET &amp; UUID4 Guide - Field management patterns used with relationships</li> <li>Usage Examples - Practical examples using relationship helpers</li> <li>Quick Reference - Quick lookup for core patterns</li> <li>StashEntityStore API - Identity map that powers bidirectional sync</li> </ul>"},{"location":"architecture/bidirectional-relationships/#references","title":"References","text":"<ul> <li>Verification Script: <code>verify_bidirectional_relationships.py</code></li> <li>Test Results: See \"Empirical Verification Results\" above</li> <li>Implementation PR: TBD</li> <li>Related Issues: TBD</li> </ul>"},{"location":"architecture/comparison/","title":"Library Comparisons","text":"<p>This document compares stash-graphql-client to alternative approaches and libraries to help you understand when and why to use it.</p>"},{"location":"architecture/comparison/#vs-raw-graphql-with-gql","title":"vs Raw GraphQL with gql","text":""},{"location":"architecture/comparison/#side-by-side-example","title":"Side-by-Side Example","text":"<p>Raw gql approach:</p> <pre><code>from gql import gql, Client\nfrom gql.transport.httpx import HTTPXAsyncTransport\n\n# Setup client\ntransport = HTTPXAsyncTransport(url=\"http://localhost:9999/graphql\")\nclient = Client(transport=transport)\n\n# Define query string (error-prone, no validation)\nquery = gql(\"\"\"\n    query FindScene($id: ID!) {\n        findScene(id: $id) {\n            id\n            title\n            rating100\n            studio { id name }\n            performers { id name }\n        }\n    }\n\"\"\")\n\n# Execute query\nresult = await client.execute(query, variable_values={\"id\": \"123\"})\n\n# Navigate dict (no type safety)\nscene_data = result[\"findScene\"]\ntitle = scene_data[\"title\"]  # Typo in key? Runtime error!\nrating = scene_data.get(\"rating100\")  # Optional chaining\n\n# Update requires manual mutation\nmutation = gql(\"\"\"\n    mutation UpdateScene($input: SceneUpdateInput!) {\n        sceneUpdate(input: $input) {\n            id\n            title\n            rating100\n        }\n    }\n\"\"\")\n\n# Build input dict (must include all fields or risk overwriting)\nupdate_result = await client.execute(mutation, variable_values={\n    \"input\": {\n        \"id\": \"123\",\n        \"title\": \"New Title\",\n        \"rating100\": 90,\n        # Did we forget any fields? Hope not!\n    }\n})\n</code></pre> <p>stash-graphql-client approach:</p> <pre><code>from stash_graphql_client import StashContext\nfrom stash_graphql_client.types import UNSET, is_set\n\n# Setup with context manager\nasync with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n    # Find scene (type-safe, IDE autocomplete)\n    scene = await client.find_scene(\"123\")\n\n    # Access properties (validated Pydantic models)\n    title = scene.title  # Type-checked, autocomplete works\n    rating = scene.rating100  # Optional fields handled automatically\n\n    # Related objects\n    if is_set(scene.studio):\n        print(f\"Studio: {scene.studio.name}\")\n\n    # Update (only changed fields sent)\n    scene.title = \"New Title\"\n    scene.rating100 = 90\n    scene.details = UNSET  # Don't touch this field\n    await scene.save(client)  # Mutation generated automatically\n</code></pre>"},{"location":"architecture/comparison/#feature-comparison","title":"Feature Comparison","text":"Feature Raw gql stash-graphql-client Query construction Manual string building Method calls (<code>client.find_scene()</code>) Type safety None (runtime dicts) Full Pydantic validation IDE autocomplete No Yes (all fields, methods) Response parsing Dict navigation Pydantic models Mutation building Manual GraphQL strings <code>.save()</code> / <code>.delete()</code> methods Partial updates Include all fields or manual tracking UNSET pattern (automatic) Object identity Manual tracking Automatic identity map Relationship handling Manual dict navigation Pydantic models with bidirectional sync Error detection Runtime (wrong keys, types) Development time (Pydantic validation) Code volume ~40-50 lines for basic CRUD ~5-10 lines for same operations"},{"location":"architecture/comparison/#when-to-use-raw-gql","title":"When to Use Raw gql","text":"<p>\u2705 Use raw gql when:</p> <ul> <li>Making a few simple queries</li> <li>Need maximum control over GraphQL</li> <li>Working with non-Stash GraphQL APIs</li> <li>Building a custom abstraction layer</li> </ul> <p>\u274c Avoid raw gql when:</p> <ul> <li>Building tools with complex entity relationships</li> <li>Need type safety and validation</li> <li>Making many queries for same entities</li> <li>Want ORM-like convenience</li> </ul>"},{"location":"architecture/comparison/#vs-apollo-client-javascript","title":"vs Apollo Client (JavaScript)","text":"<p>Apollo Client is the most popular GraphQL client for JavaScript/TypeScript. Here's how stash-graphql-client compares:</p>"},{"location":"architecture/comparison/#architecture-comparison","title":"Architecture Comparison","text":"Component Apollo Client stash-graphql-client Language JavaScript/TypeScript Python Type system TypeScript (compile-time) Pydantic (runtime validation) Caching InMemoryCache (separate layer) Wrap validators (integrated) Cache normalization Refs to normalized objects Direct object references Cache writes <code>cache.writeQuery()</code> Automatic in constructor Cache reads <code>cache.readQuery()</code> Automatic object reuse Optimistic updates Manual configuration Not built-in (manual for now) Subscriptions Via graphql-ws Via websockets transport"},{"location":"architecture/comparison/#cache-implementation","title":"Cache Implementation","text":"<p>Apollo Client:</p> <pre><code>// Separate cache layer\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Scene: {\n      keyFields: [\"id\"],\n      fields: {\n        studio: {\n          merge(existing, incoming) {\n            return incoming;\n          }\n        }\n      }\n    }\n  }\n});\n\n// Manual cache writes\ncache.writeQuery({\n  query: SCENE_QUERY,\n  data: { findScene: updatedScene }\n});\n\n// Manual cache reads\nconst scene = cache.readQuery({\n  query: SCENE_QUERY,\n  variables: { id: \"123\" }\n});\n</code></pre> <p>stash-graphql-client:</p> <pre><code># Caching built into model construction\nscene1 = Scene.from_dict({\"id\": \"123\", \"title\": \"Test\"})\nscene2 = Scene.from_dict({\"id\": \"123\", \"title\": \"Test\"})\nassert scene1 is scene2  # Automatic caching!\n\n# No manual cache API needed\n</code></pre>"},{"location":"architecture/comparison/#type-safety","title":"Type Safety","text":"<p>Apollo with TypeScript:</p> <pre><code>// Generated types from schema\ninterface Scene {\n  id: string;\n  title: string;\n  rating100?: number;\n}\n\n// Compile-time checking only\nconst scene: Scene = await client.query({...});\nscene.title = \"New\";  // \u2705 TypeScript happy\n// Runtime: No validation that server actually sent the right shape\n</code></pre> <p>stash-graphql-client:</p> <pre><code># Pydantic models with runtime validation\nscene = Scene(title=\"New\", rating100=150)  # \u274c Validation error at runtime!\n# rating100 must be 0-100\n\n# Runtime type coercion\nscene = Scene(title=\"New\", rating100=\"85\")  # \u2705 Converts str -&gt; int\nassert scene.rating100 == 85\n</code></pre>"},{"location":"architecture/comparison/#when-to-use-apollo-vs-stash-graphql-client","title":"When to Use Apollo vs stash-graphql-client","text":"<p>Use Apollo when:</p> <ul> <li>Building web applications in JavaScript/TypeScript</li> <li>Need React integration (React Query, hooks)</li> <li>Working with any GraphQL API</li> <li>Need optimistic UI updates</li> <li>Want community plugins/extensions</li> </ul> <p>Use stash-graphql-client when:</p> <ul> <li>Building Python tools/scripts</li> <li>Working specifically with Stash</li> <li>Need runtime type validation</li> <li>Want ORM-like entity management</li> <li>Prefer identity map over normalized cache</li> </ul>"},{"location":"architecture/comparison/#vs-sqlalchemy","title":"vs SQLAlchemy","text":"<p>SQLAlchemy is Python's most popular ORM for SQL databases. stash-graphql-client borrows patterns from SQLAlchemy but applies them to GraphQL.</p>"},{"location":"architecture/comparison/#conceptual-mapping","title":"Conceptual Mapping","text":"SQLAlchemy Concept stash-graphql-client Equivalent Session StashEntityStore Session.identity_map Wrap validator cache Model.query.filter() <code>store.find(Type, field__modifier=value)</code> relationship() RelationshipMetadata + auto-sync back_populates inverse_query_field Lazy loading Field-aware population session.add() Automatic in constructor session.commit() <code>.save(client)</code> session.flush() No direct equivalent (saves immediately)"},{"location":"architecture/comparison/#side-by-side-example_1","title":"Side-by-Side Example","text":"<p>SQLAlchemy:</p> <pre><code>from sqlalchemy import create_engine, Column, Integer, String, ForeignKey\nfrom sqlalchemy.orm import Session, relationship, declarative_base\n\nBase = declarative_base()\n\nclass Scene(Base):\n    __tablename__ = 'scenes'\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    rating100 = Column(Integer)\n    studio_id = Column(Integer, ForeignKey('studios.id'))\n\n    # Relationship with backref\n    studio = relationship(\"Studio\", back_populates=\"scenes\")\n\n# Usage\nengine = create_engine(\"sqlite:///stash.db\")\nsession = Session(engine)\n\n# Query\nscene = session.query(Scene).filter(Scene.id == 123).first()\ntop_rated = session.query(Scene).filter(Scene.rating100 &gt;= 80).all()\n\n# Update\nscene.title = \"Updated\"\nsession.commit()\n\n# Identity map\nscene1 = session.query(Scene).filter(Scene.id == 123).first()\nscene2 = session.query(Scene).filter(Scene.id == 123).first()\nassert scene1 is scene2  # True - same object!\n</code></pre> <p>stash-graphql-client:</p> <pre><code>from stash_graphql_client import StashContext, StashEntityStore\nfrom stash_graphql_client.types import Scene\n\nasync with StashContext(conn={...}) as client:\n    store = StashEntityStore(client)\n\n    # Query\n    scene = await store.get(Scene, \"123\")\n    top_rated = await store.find(Scene, rating100__gte=80)\n\n    # Update\n    scene.title = \"Updated\"\n    await scene.save(client)\n\n    # Identity map\n    scene1 = await store.get(Scene, \"123\")\n    scene2 = await store.get(Scene, \"123\")\n    assert scene1 is scene2  # True - same object!\n</code></pre>"},{"location":"architecture/comparison/#key-differences","title":"Key Differences","text":"Aspect SQLAlchemy stash-graphql-client Backend SQL databases (Postgres, MySQL, SQLite) GraphQL API (Stash) Query language SQLAlchemy expressions / SQL GraphQL / Django-style kwargs Identity map <code>Session.identity_map</code> dict Pydantic wrap validators Async <code>async_scoped_session</code> (extension) Native async throughout Type validation Optional (via type hints) Required (Pydantic runtime) Relationships Foreign keys + <code>relationship()</code> <code>RelationshipMetadata</code> + query strategies Lazy loading Database query when accessed Field-aware populate Transactions session.begin() / commit() / rollback() No transactions (GraphQL mutations) Schema changes Alembic migrations N/A (server handles schema)"},{"location":"architecture/comparison/#advantages-of-stash-graphql-client","title":"Advantages of stash-graphql-client","text":"<p>\u2705 Runtime type validation - Pydantic catches errors immediately \u2705 UNSET pattern - Distinguish unqueried from null (SQL can't do this) \u2705 Async-first - Not retrofitted like SQLAlchemy's async support \u2705 No ORM impedance mismatch - GraphQL already returns objects</p>"},{"location":"architecture/comparison/#advantages-of-sqlalchemy","title":"Advantages of SQLAlchemy","text":"<p>\u2705 Transactions - ACID guarantees, rollback support \u2705 Complex queries - Joins, subqueries, window functions \u2705 Database portability - Works with any SQL database \u2705 Mature ecosystem - 15+ years of development</p>"},{"location":"architecture/comparison/#vs-django-orm","title":"vs Django ORM","text":"<p>Django ORM is built into the Django web framework but can be used standalone.</p>"},{"location":"architecture/comparison/#filter-syntax-comparison","title":"Filter Syntax Comparison","text":"<p>Django ORM:</p> <pre><code>from myapp.models import Scene\n\n# Django double-underscore syntax\ntop_rated = Scene.objects.filter(rating100__gte=80)\nunrated = Scene.objects.filter(rating100__isnull=True)\nsearch = Scene.objects.filter(title__icontains=\"test\")\ndate_range = Scene.objects.filter(\n    date__range=(\"2024-01-01\", \"2024-12-31\")\n)\n\n# Chaining filters\nresults = Scene.objects.filter(\n    rating100__gte=80,\n    organized=True\n).exclude(title__startswith=\"OLD\")\n</code></pre> <p>stash-graphql-client:</p> <pre><code>from stash_graphql_client import StashEntityStore\nfrom stash_graphql_client.types import Scene\n\nstore = StashEntityStore(client)\n\n# Same double-underscore syntax!\ntop_rated = await store.find(Scene, rating100__gte=80)\nunrated = await store.find(Scene, rating100__null=True)\nsearch = await store.find(Scene, title__contains=\"test\")\ndate_range = await store.find(Scene, date__between=(\"2024-01-01\", \"2024-12-31\"))\n\n# Multiple filters (no exclude yet)\nresults = await store.find(\n    Scene,\n    rating100__gte=80,\n    organized=True\n)\n</code></pre>"},{"location":"architecture/comparison/#key-differences_1","title":"Key Differences","text":"Feature Django ORM stash-graphql-client Filter syntax <code>field__modifier</code> Same! <code>field__modifier</code> Query chaining <code>.filter().filter().exclude()</code> Single <code>find()</code> call Identity map Implicit (QuerySet caching) Explicit (StashEntityStore) Async support Limited (<code>sync_to_async</code>) Native async Type validation Model field types Pydantic runtime validation Partial updates <code>save(update_fields=[...])</code> UNSET pattern Relationships ForeignKey / ManyToMany RelationshipMetadata Database SQL (Postgres, MySQL, SQLite) GraphQL (Stash)"},{"location":"architecture/comparison/#when-to-use-django-orm-vs-stash-graphql-client","title":"When to Use Django ORM vs stash-graphql-client","text":"<p>Use Django ORM when:</p> <ul> <li>Building Django web applications</li> <li>Working with SQL databases</li> <li>Need transactions and complex joins</li> <li>Want admin interface for free</li> </ul> <p>Use stash-graphql-client when:</p> <ul> <li>Working specifically with Stash</li> <li>Building Python tools/scripts (not web apps)</li> <li>Want GraphQL flexibility</li> <li>Need UNSET pattern for sparse updates</li> </ul>"},{"location":"architecture/comparison/#when-to-use-this-library","title":"When to Use This Library","text":""},{"location":"architecture/comparison/#use-stash-graphql-client-when","title":"\u2705 Use stash-graphql-client when:","text":"<ol> <li>Building tools that interact with Stash</li> <li>Media organization scripts</li> <li>Batch processing tools</li> <li>Data migration utilities</li> <li> <p>Custom integrations</p> </li> <li> <p>You need type safety and validation</p> </li> <li>Catch errors at development time</li> <li>IDE autocomplete for all fields</li> <li> <p>Runtime validation of server responses</p> </li> <li> <p>You want ORM-like convenience</p> </li> <li><code>.save()</code> / <code>.delete()</code> methods</li> <li>Relationship helpers</li> <li> <p>Change tracking for partial updates</p> </li> <li> <p>Working with complex entity relationships</p> </li> <li>Scenes with performers, studios, tags</li> <li>Need bidirectional relationship sync</li> <li> <p>Want object identity across queries</p> </li> <li> <p>Making many queries for same entities</p> </li> <li>Identity map prevents duplicate objects</li> <li>Read-through caching reduces network requests</li> <li>Field-aware population loads only what's needed</li> </ol>"},{"location":"architecture/comparison/#dont-use-stash-graphql-client-when","title":"\u274c Don't use stash-graphql-client when:","text":"<ol> <li>Just need a few simple queries</li> <li>Use raw <code>gql</code> library directly</li> <li> <p>Simpler for one-off operations</p> </li> <li> <p>Not using Python</p> </li> <li>Use GraphQL client for your language</li> <li> <p>Apollo (JS), graphql-ruby (Ruby), etc.</p> </li> <li> <p>Need to work with multiple GraphQL APIs</p> </li> <li>This is specialized for Stash's schema</li> <li> <p>Use general-purpose GraphQL client</p> </li> <li> <p>Memory constrained environment</p> </li> <li>Identity map keeps objects in memory</li> <li> <p>May not be suitable for very large datasets</p> </li> <li> <p>Need optimistic updates / offline support</p> </li> <li>Not built-in (would need manual implementation)</li> <li>Apollo Client better for this use case</li> </ol>"},{"location":"architecture/comparison/#migration-guide","title":"Migration Guide","text":""},{"location":"architecture/comparison/#from-raw-gql","title":"From Raw gql","text":"<p>Before:</p> <pre><code>query = gql(\"query { findScene(id: $id) { ... } }\")\nresult = await client.execute(query, {\"id\": \"123\"})\nscene_data = result[\"findScene\"]\n</code></pre> <p>After:</p> <pre><code>scene = await client.find_scene(\"123\")\n</code></pre> <p>Effort: Low - mostly replacing string queries with method calls</p>"},{"location":"architecture/comparison/#from-apollo-client-js-python","title":"From Apollo Client (JS \u2192 Python)","text":"<p>Before (JavaScript):</p> <pre><code>const { data } = await client.query({\n  query: FIND_SCENE,\n  variables: { id: \"123\" }\n});\nconst scene = data.findScene;\n</code></pre> <p>After (Python):</p> <pre><code>scene = await client.find_scene(\"123\")\n</code></pre> <p>Effort: Medium - language switch + learning Pydantic patterns</p>"},{"location":"architecture/comparison/#from-sqlalchemy","title":"From SQLAlchemy","text":"<p>Before:</p> <pre><code>session = Session(engine)\nscene = session.query(Scene).filter(Scene.id == 123).first()\n</code></pre> <p>After:</p> <pre><code>store = StashEntityStore(client)\nscene = await store.get(Scene, \"123\")\n</code></pre> <p>Effort: Low - very similar patterns, main change is async</p>"},{"location":"architecture/comparison/#from-django-orm","title":"From Django ORM","text":"<p>Before:</p> <pre><code>from myapp.models import Scene\nscene = Scene.objects.get(id=123)\n</code></pre> <p>After:</p> <pre><code>from stash_graphql_client.types import Scene\nscene = await client.find_scene(\"123\")\n</code></pre> <p>Effort: Low - filter syntax nearly identical</p>"},{"location":"architecture/comparison/#summary","title":"Summary","text":"<p>stash-graphql-client combines the best patterns from:</p> <ul> <li>Apollo Client - GraphQL caching and query management</li> <li>SQLAlchemy - Identity map and session pattern</li> <li>Django ORM - Filter syntax and query building</li> <li>Pydantic - Runtime type validation and models</li> </ul> <p>It's specifically designed for:</p> <ul> <li>Python developers</li> <li>Building tools that interact with Stash</li> <li>Need type safety + ORM convenience + GraphQL flexibility</li> </ul> <p>It's NOT designed for:</p> <ul> <li>General-purpose GraphQL APIs</li> <li>Web applications (use Apollo + React)</li> <li>Maximum control over every GraphQL query</li> </ul>"},{"location":"architecture/comparison/#next-steps","title":"Next Steps","text":"<ul> <li>Overview Guide - Architecture and core concepts</li> <li>Identity Map Architecture - Deep dive on caching</li> <li>Usage Patterns - Common recipes</li> <li>API Reference - Complete method documentation</li> </ul>"},{"location":"architecture/identity-map/","title":"Identity Map Architecture","text":""},{"location":"architecture/identity-map/#what-is-an-identity-map","title":"What is an Identity Map?","text":"<p>An identity map is a design pattern that ensures only one instance of any given object exists in memory at a time. When you query for the same entity multiple times, you get the same Python object reference rather than different instances with the same ID.</p> <p>Without identity map:</p> <pre><code># Two separate queries return different objects\nscene1 = await client.find_scene(\"123\")\nscene2 = await client.find_scene(\"123\")\nassert scene1 is not scene2  # True - different objects!\n\n# Updating one doesn't affect the other\nscene1.title = \"Updated\"\nprint(scene2.title)  # Still the old title - stale data!\n</code></pre> <p>With identity map:</p> <pre><code># Two queries return the SAME object reference\nscene1 = await client.find_scene(\"123\")\nscene2 = await client.find_scene(\"123\")\nassert scene1 is scene2  # True - same object!\n\n# Updating one affects all references\nscene1.title = \"Updated\"\nprint(scene2.title)  # \"Updated\" - same object!\n</code></pre>"},{"location":"architecture/identity-map/#benefits","title":"Benefits","text":"<ol> <li>No stale data - All references to an entity stay synchronized</li> <li>Memory efficiency - One object in memory instead of many duplicates</li> <li>Relationship consistency - Related entities always point to cached instances</li> <li>Reduced network requests - Cached objects avoid redundant queries</li> </ol>"},{"location":"architecture/identity-map/#how-it-works-wrap-validator-flow","title":"How It Works: Wrap Validator Flow","text":"<pre><code>sequenceDiagram\n    participant Code as Developer Code\n    participant Constructor as Scene.from_dict()\n    participant Validator as @model_validator(mode='wrap')\n    participant Cache as Identity Map Cache\n    participant Pydantic as Pydantic Handler\n    participant Object as Scene Instance\n\n    Code-&gt;&gt;Constructor: Scene.from_dict({\"id\": \"123\", ...})\n    Constructor-&gt;&gt;Validator: Intercept construction\n\n    alt Cache Hit\n        Validator-&gt;&gt;Cache: Check cache[(type, id)]\n        Cache--&gt;&gt;Validator: Found cached instance\n        Validator-&gt;&gt;Object: Merge new fields\n        Validator--&gt;&gt;Code: Return cached instance\n    else Cache Miss\n        Validator-&gt;&gt;Cache: Not found\n        Validator-&gt;&gt;Validator: Process nested objects\n        Validator-&gt;&gt;Pydantic: handler(processed_data)\n        Pydantic-&gt;&gt;Object: Construct &amp; validate\n        Object--&gt;&gt;Validator: New instance\n        Validator-&gt;&gt;Cache: Store instance\n        Validator--&gt;&gt;Code: Return new instance\n    end\n\n    Note over Validator,Cache: Cache check happens&lt;br/&gt;BEFORE Pydantic validation</code></pre>"},{"location":"architecture/identity-map/#implementation-pydantic-wrap-validators","title":"Implementation: Pydantic Wrap Validators","text":"<p>Most libraries implement identity maps as a separate layer (like SQLAlchemy's <code>Session.identity_map</code> or Apollo's <code>InMemoryCache</code>). This library integrates caching directly into Pydantic model construction using wrap validators.</p>"},{"location":"architecture/identity-map/#why-wrap-validators","title":"Why Wrap Validators?","text":"<p>Pydantic v2 introduced <code>@model_validator(mode='wrap')</code>, which gives complete control over object construction. A wrap validator:</p> <ol> <li>Receives raw input data before Pydantic processes it</li> <li>Can return a cached instance instead of constructing a new one</li> <li>Can pre-process data before passing to Pydantic's default handler</li> <li>Executes before field validation - extremely efficient</li> </ol> <p>This means cache lookup happens before any validation or deserialization work.</p>"},{"location":"architecture/identity-map/#stashobject-base-class","title":"StashObject Base Class","text":"<p>All entity types inherit from <code>StashObject</code>, which implements the wrap validator:</p> <pre><code>from pydantic import BaseModel, model_validator\nfrom typing import Any, ClassVar, Self\n\nclass StashObject(BaseModel):\n    \"\"\"Base class for all Stash entity types with identity map support.\"\"\"\n\n    # Class-level store reference (shared across all instances)\n    _store: ClassVar[\"StashEntityStore | None\"] = None\n\n    # Type name for cache keys (e.g., \"Scene\", \"Performer\")\n    __type_name__: ClassVar[str] = \"\"\n\n    @model_validator(mode='wrap')\n    @classmethod\n    def _identity_map_validator(cls, data: Any, handler, info) -&gt; Self:\n        \"\"\"\n        Wrap validator that implements identity map pattern.\n\n        Execution order:\n        1. Check if data is dict with 'id' field\n        2. Check cache for existing instance\n        3. If found and not expired, return cached instance\n        4. If not found, pre-process nested objects\n        5. Let Pydantic construct new instance\n        6. Cache the new instance\n        7. Return instance\n        \"\"\"\n\n        # Skip caching if no store configured or data is not a dict\n        if not cls._store or not isinstance(data, dict):\n            return handler(data)\n\n        # Extract ID from data\n        entity_id = data.get('id')\n        if not entity_id:\n            # No ID means we can't cache yet (new object)\n            return handler(data)\n\n        # Build cache key\n        cache_key = (cls.__type_name__, entity_id)\n\n        # Step 1: Check cache BEFORE Pydantic processes data\n        with cls._store._lock:\n            if cache_key in cls._store._cache:\n                cached_entry = cls._store._cache[cache_key]\n\n                # Check if cache entry expired\n                if not cached_entry.is_expired():\n                    # Return cached instance - no construction needed!\n                    cached_instance = cached_entry.entity\n\n                    # Merge new fields from data into cached instance\n                    cls._merge_fields(cached_instance, data)\n\n                    return cached_instance\n                else:\n                    # Entry expired - evict it\n                    del cls._store._cache[cache_key]\n\n        # Step 2: Pre-process nested objects (replace dicts with cached instances)\n        processed_data = cls._process_nested_cache_lookups(data)\n\n        # Step 3: Let Pydantic validate and construct instance\n        instance = handler(processed_data)\n\n        # Step 4: Cache the new instance\n        if hasattr(instance, 'id') and instance.id:\n            cls._store._cache_entity(instance)\n\n        return instance\n</code></pre>"},{"location":"architecture/identity-map/#nested-cache-lookups","title":"Nested Cache Lookups","text":"<p>Before Pydantic validates data, the wrap validator processes nested objects to replace dictionaries with cached instances:</p> <pre><code>@classmethod\ndef _process_nested_cache_lookups(cls, data: dict) -&gt; dict:\n    \"\"\"\n    Replace nested object dicts with cached instances before Pydantic validation.\n\n    Example:\n        Input data:\n        {\n            \"id\": \"scene-123\",\n            \"title\": \"Test\",\n            \"studio\": {\"id\": \"studio-456\", \"name\": \"Acme\"}\n        }\n\n        After processing:\n        {\n            \"id\": \"scene-123\",\n            \"title\": \"Test\",\n            \"studio\": &lt;Studio object at 0x...&gt;  # Cached instance!\n        }\n    \"\"\"\n    if not cls._store or not isinstance(data, dict):\n        return data\n\n    processed = data.copy()\n\n    # Iterate through all fields\n    for field_name, field_info in cls.model_fields.items():\n        if field_name not in processed:\n            continue\n\n        value = processed[field_name]\n        if value is None or value is UNSET:\n            continue\n\n        # Get field type annotation\n        field_type = field_info.annotation\n\n        # Handle Union types (e.g., Studio | None | UnsetType)\n        if hasattr(field_type, '__origin__') and field_type.__origin__ is Union:\n            # Extract non-None, non-UnsetType types\n            actual_types = [\n                t for t in field_type.__args__\n                if t is not type(None) and t is not UnsetType\n            ]\n            if actual_types:\n                field_type = actual_types[0]\n\n        # Handle List[Type]\n        if hasattr(field_type, '__origin__') and field_type.__origin__ is list:\n            item_type = field_type.__args__[0]\n            if isinstance(value, list):\n                processed[field_name] = [\n                    cls._lookup_or_return(item, item_type)\n                    for item in value\n                ]\n\n        # Handle single object\n        elif isinstance(value, dict) and hasattr(field_type, '__type_name__'):\n            processed[field_name] = cls._lookup_or_return(value, field_type)\n\n    return processed\n\n\n@classmethod\ndef _lookup_or_return(cls, data: Any, target_type: type) -&gt; Any:\n    \"\"\"\n    Look up data in cache, or return as-is if not found.\n    \"\"\"\n    if not isinstance(data, dict) or 'id' not in data:\n        return data\n\n    if not cls._store:\n        return data\n\n    cache_key = (target_type.__type_name__, data['id'])\n\n    with cls._store._lock:\n        if cache_key in cls._store._cache:\n            entry = cls._store._cache[cache_key]\n            if not entry.is_expired():\n                return entry.entity\n\n    # Not in cache - return dict (Pydantic will construct it)\n    return data\n</code></pre> <p>Why this matters:</p> <pre><code># Without nested processing:\nscene_data = {\n    \"id\": \"123\",\n    \"studio\": {\"id\": \"456\", \"name\": \"Acme\"}\n}\nscene = Scene.from_dict(scene_data)\nstudio = await client.find_studio(\"456\")\nassert scene.studio is not studio  # \u274c Different objects!\n\n# With nested processing:\nscene_data = {\n    \"id\": \"123\",\n    \"studio\": {\"id\": \"456\", \"name\": \"Acme\"}\n}\nscene = Scene.from_dict(scene_data)\nstudio = await client.find_studio(\"456\")\nassert scene.studio is studio  # \u2705 Same cached instance!\n</code></pre>"},{"location":"architecture/identity-map/#field-merging-on-cache-hits","title":"Field Merging on Cache Hits","text":"<p>When returning a cached instance, the validator merges new fields from the GraphQL response:</p> <pre><code>@classmethod\ndef _merge_fields(cls, instance: Self, new_data: dict) -&gt; None:\n    \"\"\"\n    Merge fields from new_data into existing cached instance.\n\n    Only updates fields that:\n    1. Are present in new_data\n    2. Are not UNSET in new_data\n    3. Have different values than current instance\n    \"\"\"\n    for field_name, field_value in new_data.items():\n        # Skip UNSET fields\n        if isinstance(field_value, UnsetType):\n            continue\n\n        # Skip if same value\n        current_value = getattr(instance, field_name, UNSET)\n        if current_value == field_value:\n            continue\n\n        # Update field\n        setattr(instance, field_name, field_value)\n\n        # Track that we received this field\n        if hasattr(instance, '_received_fields'):\n            instance._received_fields.add(field_name)\n</code></pre> <p>Why field merging?</p> <pre><code># First query loads basic fields\nscene = await client.find_scene(\"123\")  # Query: id, title\nprint(scene.title)  # \"Test\"\nprint(scene.performers)  # UNSET (not queried)\n\n# Second query loads different fields\nscene2 = await client.find_scene(\"123\")  # Query: id, title, performers\n# Returns cached scene, but merges 'performers' field\nprint(scene.performers)  # Now loaded! (merged from second query)\n</code></pre>"},{"location":"architecture/identity-map/#stashentitystore-implementation","title":"StashEntityStore Implementation","text":"<p>The <code>StashEntityStore</code> class manages the actual cache storage:</p>"},{"location":"architecture/identity-map/#cache-structure","title":"Cache Structure","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Generic, TypeVar\nimport time\n\nT = TypeVar('T', bound=StashObject)\n\n@dataclass\nclass CacheEntry(Generic[T]):\n    \"\"\"Entry in the identity map cache.\"\"\"\n    entity: T                      # The cached entity instance\n    cached_at: float              # time.monotonic() when cached\n    ttl_seconds: float | None     # Optional TTL (None = never expire)\n\n    def is_expired(self) -&gt; bool:\n        \"\"\"Check if cache entry has expired.\"\"\"\n        if self.ttl_seconds is None:\n            return False\n        return (time.monotonic() - self.cached_at) &gt; self.ttl_seconds\n\n\nclass StashEntityStore:\n    \"\"\"\n    Identity map and caching layer for Stash entities.\n    \"\"\"\n\n    def __init__(self, client: StashClient, ttl_seconds: float | None = None):\n        self._client = client\n        self._ttl_seconds = ttl_seconds\n\n        # Cache: (type_name, entity_id) -&gt; CacheEntry\n        self._cache: dict[tuple[str, str], CacheEntry] = {}\n\n        # Thread safety\n        self._lock = RLock()\n\n        # Wire up store to StashObject\n        StashObject._store = self\n</code></pre> <p>Key design decisions:</p> <ol> <li>Cache key format: <code>(type_name, entity_id)</code> tuples</li> <li>Avoids collisions between different types</li> <li> <p>Simple and fast lookup</p> </li> <li> <p>TTL using <code>time.monotonic()</code>:</p> </li> <li>Immune to system clock changes</li> <li>Optional (None = never expire)</li> <li> <p>Per-store configuration (not per-entry)</p> </li> <li> <p>Thread-safe with <code>RLock</code>:</p> </li> <li>Allows recursive locking (same thread can acquire multiple times)</li> <li>Protects cache dict modifications</li> <li>Lock released before calling user code</li> </ol>"},{"location":"architecture/identity-map/#cache-operations","title":"Cache Operations","text":"<pre><code>def _cache_entity(self, entity: StashObject) -&gt; None:\n    \"\"\"Add or update entity in cache.\"\"\"\n    if not hasattr(entity, 'id') or not entity.id:\n        return\n\n    cache_key = (entity.__type_name__, entity.id)\n\n    with self._lock:\n        self._cache[cache_key] = CacheEntry(\n            entity=entity,\n            cached_at=time.monotonic(),\n            ttl_seconds=self._ttl_seconds\n        )\n\n\ndef get_cached(self, entity_type: type[T], entity_id: str) -&gt; T | None:\n    \"\"\"Get entity from cache without querying server.\"\"\"\n    cache_key = (entity_type.__type_name__, entity_id)\n\n    with self._lock:\n        if cache_key not in self._cache:\n            return None\n\n        entry = self._cache[cache_key]\n        if entry.is_expired():\n            del self._cache[cache_key]\n            return None\n\n        return entry.entity\n\n\nasync def get(self, entity_type: type[T], entity_id: str) -&gt; T | None:\n    \"\"\"\n    Get entity from cache or query server (read-through caching).\n    \"\"\"\n    # Try cache first (without lock contention)\n    cached = self.get_cached(entity_type, entity_id)\n    if cached is not None:\n        return cached\n\n    # Cache miss - query server\n    entity = await entity_type.find_by_id(self._client, entity_id)\n\n    # Cache the result (if found)\n    if entity:\n        self._cache_entity(entity)\n\n    return entity\n\n\ndef invalidate(self, entity: StashObject) -&gt; None:\n    \"\"\"Remove entity from cache.\"\"\"\n    if not hasattr(entity, 'id') or not entity.id:\n        return\n\n    cache_key = (entity.__type_name__, entity.id)\n\n    with self._lock:\n        if cache_key in self._cache:\n            del self._cache[cache_key]\n\n\ndef clear_type(self, entity_type: type[StashObject]) -&gt; None:\n    \"\"\"Clear all cached entities of a specific type.\"\"\"\n    type_name = entity_type.__type_name__\n\n    with self._lock:\n        keys_to_delete = [\n            key for key in self._cache.keys()\n            if key[0] == type_name\n        ]\n        for key in keys_to_delete:\n            del self._cache[key]\n</code></pre>"},{"location":"architecture/identity-map/#comparison-to-other-implementations","title":"Comparison to Other Implementations","text":""},{"location":"architecture/identity-map/#vs-sqlalchemy-session","title":"vs SQLAlchemy Session","text":"Aspect SQLAlchemy stash-graphql-client Cache lookup <code>Session.identity_map[key]</code> dict Pydantic wrap validator When cached After query execution Before Pydantic validation Cache key <code>(class, primary_key)</code> <code>(type_name, id)</code> Nested objects Lazy load via relationships Pre-processed before validation Expiration Manual <code>expire()</code> / <code>flush()</code> TTL-based with monotonic time Thread safety Session per thread pattern RLock on cache dict Integration Separate session object Class-level store reference"},{"location":"architecture/identity-map/#vs-apollo-client-inmemorycache","title":"vs Apollo Client InMemoryCache","text":"Aspect Apollo Client stash-graphql-client Cache structure Normalized cache with refs Identity map with objects Cache writes <code>cache.writeQuery()</code> Automatic in wrap validator Cache reads <code>cache.readQuery()</code> Automatic object reuse Nested objects Normalization + refs Direct object references Field merging Merge incoming data Merge in validator Invalidation Manual evict/modify TTL or manual invalidate"},{"location":"architecture/identity-map/#advantages-of-wrap-validator-approach","title":"Advantages of Wrap Validator Approach","text":"<ol> <li>Earlier caching - Before any validation work</li> <li>Transparent - No separate cache API to learn</li> <li>Nested objects - Automatically use cached instances</li> <li>Type-safe - Still full Pydantic validation when needed</li> <li>Simple - Just use <code>.from_dict()</code>, caching happens automatically</li> </ol>"},{"location":"architecture/identity-map/#trade-offs","title":"Trade-offs","text":"<ol> <li>Class-level store - All instances share one store (not session-per-context)</li> <li>No partial object merging - Can't merge at field level (only full fields)</li> <li>Python-specific - Wrap validators are Pydantic v2 feature</li> <li>Memory usage - Keeps objects in memory (no weak references)</li> </ol>"},{"location":"architecture/identity-map/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/identity-map/#cache-hit-path","title":"Cache Hit Path","text":"<pre><code># Fast path: Cache hit\ndata = {\"id\": \"123\", \"title\": \"Test\"}\n\n# Steps:\n# 1. Extract ID: O(1)\n# 2. Build cache key: O(1)\n# 3. Dict lookup: O(1)\n# 4. Expiration check: O(1)\n# 5. Merge fields: O(fields_in_data)\n# 6. Return cached instance\n\n# Total: O(fields) - very fast!\n</code></pre>"},{"location":"architecture/identity-map/#cache-miss-path","title":"Cache Miss Path","text":"<pre><code># Slow path: Cache miss\ndata = {\"id\": \"123\", \"title\": \"Test\", \"studio\": {\"id\": \"456\"}}\n\n# Steps:\n# 1-4. Same as cache hit\n# 5. Cache miss\n# 6. Process nested objects: O(fields * nesting_depth)\n# 7. Pydantic validation: O(fields)\n# 8. Cache new instance: O(1)\n# 9. Return instance\n\n# Total: O(fields * nesting_depth) - only happens once per entity\n</code></pre>"},{"location":"architecture/identity-map/#memory-usage","title":"Memory Usage","text":"<ul> <li>Per cached entity: Size of Python object + CacheEntry overhead (~100 bytes)</li> <li>Per cache entry: Tuple key (48 bytes) + CacheEntry (48 bytes) = ~96 bytes</li> <li>Total: Object size + ~200 bytes overhead per cached entity</li> </ul> <p>Example: 1000 cached scenes with 20 fields each \u2248 1-2 MB</p>"},{"location":"architecture/identity-map/#best-practices","title":"Best Practices","text":""},{"location":"architecture/identity-map/#when-to-use-identity-map","title":"When to Use Identity Map","text":"<p>\u2705 Use identity map when:</p> <ul> <li>Making multiple queries for the same entities</li> <li>Working with entity relationships</li> <li>Need consistency across references</li> <li>Building long-running applications</li> </ul> <p>\u274c Skip identity map when:</p> <ul> <li>One-off queries (just use client directly)</li> <li>Short-lived scripts</li> <li>Memory constrained environments</li> <li>Need isolation between operations</li> </ul>"},{"location":"architecture/identity-map/#ttl-configuration","title":"TTL Configuration","text":"<pre><code># No TTL - cache forever (use for reference data)\nstore = StashEntityStore(client, ttl_seconds=None)\n\n# Short TTL - frequently changing data\nstore = StashEntityStore(client, ttl_seconds=60)  # 1 minute\n\n# Long TTL - mostly static data\nstore = StashEntityStore(client, ttl_seconds=3600)  # 1 hour\n</code></pre>"},{"location":"architecture/identity-map/#manual-cache-management","title":"Manual Cache Management","text":"<pre><code># Invalidate specific entity after update\nawait scene.save(client)\nstore.invalidate(scene)  # Force reload next time\n\n# Clear all scenes after bulk update\nawait bulk_update_scenes()\nstore.clear_type(Scene)\n\n# Force refetch with populate\nawait store.populate(scene, fields=[\"title\"], force_refetch=True)\n</code></pre>"},{"location":"architecture/identity-map/#implementation-files","title":"Implementation Files","text":"<ul> <li><code>stash_graphql_client/types/base.py</code> - StashObject with wrap validator (lines 809-904)</li> <li><code>stash_graphql_client/store.py</code> - StashEntityStore implementation (lines 58-142)</li> <li><code>stash_graphql_client/types/unset.py</code> - UnsetType for three-state fields</li> </ul>"},{"location":"architecture/identity-map/#next-steps","title":"Next Steps","text":"<ul> <li>Library Comparisons - Detailed comparison with alternatives</li> <li>Bidirectional Relationships - How relationships work</li> <li>Usage Patterns - Practical examples</li> <li>API Reference - Complete StashEntityStore API</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This document provides a detailed technical overview of stash-graphql-client's architecture.</p>"},{"location":"architecture/overview/#three-layer-architecture-diagram","title":"Three-Layer Architecture Diagram","text":"<pre><code>graph TB\n    User[Developer Code] --&gt; Client[Layer 1: StashClient]\n    User --&gt; Types[Layer 2: Pydantic Types]\n    User --&gt; Store[Layer 3: StashEntityStore]\n\n    Client --&gt;|executes| GraphQL[GraphQL API]\n    Client --&gt;|returns| Types\n\n    Types --&gt;|validates| Pydantic[Pydantic v2]\n    Types --&gt;|wrap validator| IdentityMap[Identity Map]\n\n    Store --&gt;|uses| Client\n    Store --&gt;|manages| IdentityMap\n    Store --&gt;|caches| Types\n\n    GraphQL --&gt;|responses| Client\n\n    style Client fill:#2E86AB,color:#fff\n    style Types fill:#F77F00,color:#fff\n    style Store fill:#8338EC,color:#fff\n    style IdentityMap fill:#06A77D,color:#fff</code></pre>"},{"location":"architecture/overview/#architecture-layers","title":"Architecture Layers","text":"<p>This library follows a three-layer architecture:</p>"},{"location":"architecture/overview/#layer-1-stashclient-graphql-transport","title":"Layer 1: StashClient (GraphQL Transport)","text":"<p>Located in <code>stash_graphql_client/client/</code>, the client provides direct access to Stash's GraphQL API through typed mixin methods.</p> <p>Responsibilities:</p> <ul> <li>Execute GraphQL queries and mutations</li> <li>Handle HTTP/WebSocket transports</li> <li>Manage retries and connection pooling</li> <li>Deserialize responses to Pydantic models</li> </ul> <p>Example usage:</p> <pre><code>from stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    # Direct GraphQL operations\n    scenes = await client.find_scenes()\n    performer = await client.create_performer(Performer(name=\"Alice\"))\n    job_id = await client.metadata_scan()\n</code></pre> <p>Mixin architecture: Client composed of 20+ mixins, one per entity type (SceneClientMixin, PerformerClientMixin, etc.). This provides clear separation of concerns and makes the codebase maintainable.</p>"},{"location":"architecture/overview/#layer-2-pydantic-types-schemaorm-layer","title":"Layer 2: Pydantic Types (Schema/ORM Layer)","text":"<p>Located in <code>stash_graphql_client/types/</code>, all Stash entities are Pydantic v2 models with:</p> <p>Features:</p> <ul> <li>UNSET Pattern - Three-state fields distinguish \"set to value\", \"set to null\", and \"never touched\"</li> <li>UUID4 Auto-generation - New objects get temporary IDs replaced with server IDs on save</li> <li>Bidirectional Relationships - Automatic sync between related entities</li> <li>Tracked Fields - <code>__tracked_fields__</code> and <code>__field_conversions__</code> for change detection</li> <li>Relationship Metadata - <code>__relationships__</code> documents query strategies and inverse fields</li> </ul> <p>Example usage:</p> <pre><code>from stash_graphql_client.types import Scene, UNSET\n\n# Create with partial data - UUID4 auto-generated\nscene = Scene(title=\"My Scene\", rating100=85)\nprint(f\"New object ID: {scene.id}\")  # UUID4 hex string (32 chars)\nprint(f\"Is new: {scene.is_new()}\")   # True\n\n# Save sends only non-UNSET fields\nawait scene.save(client)\nprint(f\"Server ID: {scene.id}\")      # Server-assigned ID\nprint(f\"Is new: {scene.is_new()}\")   # False\n\n# Update tracks changes\nscene.rating100 = 90\nchanged = scene.get_changed_fields()  # {\"rating100\": 90}\nawait scene.save(client)  # Only sends changed fields\n</code></pre>"},{"location":"architecture/overview/#layer-3-stashentitystore-identity-map-caching","title":"Layer 3: StashEntityStore (Identity Map &amp; Caching)","text":"<p>Located in <code>stash_graphql_client/store.py</code>, provides SQLAlchemy/ActiveRecord-style data access with:</p> <p>Features:</p> <ul> <li>Identity Map - Same entity ID \u2192 same object reference</li> <li>Read-Through Caching - Fetch from cache or query on miss</li> <li>TTL Support - Optional cache expiration</li> <li>Field-Aware Population - Load missing fields on demand</li> <li>Django-Style Filtering - <code>field__modifier</code> kwargs</li> <li>Lazy Iteration - Paginate large result sets efficiently</li> <li>Thread-Safe - Uses <code>RLock</code> for concurrent access</li> </ul> <p>Example usage:</p> <pre><code>from stash_graphql_client import StashEntityStore\nfrom stash_graphql_client.types import Scene, Performer\n\nstore = StashEntityStore(client, ttl_seconds=300)\n\n# Read-through caching\nperformer = await store.get(Performer, \"123\")\n\n# Django-style filtering\ntop_rated = await store.find(Scene, rating100__gte=80)\nunrated = await store.find(Scene, rating100__null=True)\n\n# Field-aware population\nawait store.populate(performer, fields=[\"scenes\", \"images\"])\n\n# Get-or-create pattern\ntag = await store.get_or_create(Tag, name=\"Action\")\n</code></pre>"},{"location":"architecture/overview/#when-to-use-each-layer","title":"When to Use Each Layer","text":""},{"location":"architecture/overview/#use-stashclient-when","title":"Use StashClient when:","text":"<ul> <li>\u2705 Making one-off queries</li> <li>\u2705 Need direct control over GraphQL queries</li> <li>\u2705 Working with entity types that don't need caching</li> <li>\u2705 Executing mutations that return complex results</li> </ul>"},{"location":"architecture/overview/#use-pydantic-types-when","title":"Use Pydantic Types when:","text":"<ul> <li>\u2705 Creating new entities with validation</li> <li>\u2705 Need ORM-like <code>.save()</code> / <code>.delete()</code> methods</li> <li>\u2705 Working with entity relationships</li> <li>\u2705 Need change tracking for partial updates</li> </ul>"},{"location":"architecture/overview/#use-stashentitystore-when","title":"Use StashEntityStore when:","text":"<ul> <li>\u2705 Need object identity across queries</li> <li>\u2705 Making repeated queries for same entities</li> <li>\u2705 Using Django-style filtering</li> <li>\u2705 Need field-aware population</li> <li>\u2705 Processing large result sets with pagination</li> </ul>"},{"location":"architecture/overview/#related-documentation","title":"Related Documentation","text":"<ul> <li>Identity Map Architecture - Deep dive on wrap validators and caching</li> <li>Library Comparisons - How this compares to alternatives</li> <li>Bidirectional Relationships - Relationship sync implementation</li> <li>Overview Guide - General overview and design philosophy</li> </ul>"},{"location":"guide/advanced-filtering/","title":"Advanced Filtering with Field-Aware Repository","text":"<p>The <code>StashEntityStore</code> provides advanced filtering methods that combine local caching with smart field-level population. These methods enable high-performance queries by minimizing network traffic while ensuring data completeness.</p>"},{"location":"guide/advanced-filtering/#overview","title":"Overview","text":"<p>The advanced filtering system builds on the UNSET Pattern and Identity Map to provide:</p> <ul> <li>Field-level granularity: Track which fields are loaded vs unqueried</li> <li>Smart population: Automatically fetch only missing fields</li> <li>Local filtering: Query cached data without network calls</li> <li>Fail-fast validation: Ensure required fields are present before filtering</li> </ul>"},{"location":"guide/advanced-filtering/#method-comparison","title":"Method Comparison","text":"Method Network Calls Returns Use Case <code>filter()</code> Never <code>list[T]</code> Fast local query (existing) <code>filter_strict()</code> Never <code>list[T]</code> Fail-fast if fields missing <code>filter_and_populate()</code> Only for missing fields <code>list[T]</code> Smart hybrid (main workhorse) <code>filter_and_populate_with_stats()</code> Only for missing fields <code>(list[T], dict)</code> Performance debugging <code>populated_filter_iter()</code> Only for missing fields <code>AsyncIterator[T]</code> Large datasets, early exit <code>find()</code> Always <code>list[T]</code> Fresh data from server (existing)"},{"location":"guide/advanced-filtering/#filter_strict-fail-fast-filtering","title":"<code>filter_strict()</code> - Fail-Fast Filtering","text":"<p>Filters cached objects, raising an error if any required fields are missing. Useful when you MUST have complete data.</p>"},{"location":"guide/advanced-filtering/#signature","title":"Signature","text":"<pre><code>def filter_strict(\n    self,\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n) -&gt; list[T]:\n</code></pre>"},{"location":"guide/advanced-filtering/#example","title":"Example","text":"<pre><code>from stash_graphql_client import StashContext, Performer\n\nasync with StashContext(conn=conn) as context:\n    store = context.store\n\n    # Pre-populate cache with find()\n    await store.find(Performer, favorite=True)\n\n    # Strict filtering - raises if any performer missing rating100\n    try:\n        high_rated = store.filter_strict(\n            Performer,\n            required_fields=['rating100', 'favorite'],\n            predicate=lambda p: p.rating100 &gt;= 80 and p.favorite\n        )\n        print(f\"Found {len(high_rated)} high-rated favorites\")\n    except ValueError as e:\n        # \"Performer 123 is missing required fields: {'rating100'}\"\n        print(f\"Cache incomplete: {e}\")\n        # Fix: warm cache with missing fields\n        await store.find(Performer, favorite=True)  # Re-fetch with all fields\n</code></pre>"},{"location":"guide/advanced-filtering/#when-to-use","title":"When to Use","text":"<ul> <li>Data validation: Ensure cache is complete before processing</li> <li>Debugging: Identify incomplete cache population</li> <li>Critical operations: Operations that require guaranteed field presence</li> </ul>"},{"location":"guide/advanced-filtering/#filter_and_populate-smart-hybrid-filtering","title":"<code>filter_and_populate()</code> - Smart Hybrid Filtering","text":"<p>The main workhorse method. Filters cached objects, automatically fetching missing fields as needed. Much faster than <code>find()</code> when most data is cached.</p>"},{"location":"guide/advanced-filtering/#signature_1","title":"Signature","text":"<pre><code>async def filter_and_populate(\n    self,\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n    batch_size: int = 50,\n) -&gt; list[T]:\n</code></pre>"},{"location":"guide/advanced-filtering/#example_1","title":"Example","text":"<pre><code>from stash_graphql_client import StashContext, Performer\n\nasync with StashContext(conn=conn) as context:\n    store = context.store\n\n    # Day 1: User browses performers (basic info only)\n    async for performer in store.find_iter(Performer, query_batch=100):\n        # Cache now has 5000 performers with: id, name, gender\n        # But rating100, favorite, scenes are UNSET\n        display_in_ui(performer)\n\n    # Day 2: User wants to filter by rating (cache is partial)\n    high_rated = await store.filter_and_populate(\n        Performer,\n        required_fields=['rating100', 'favorite'],\n        predicate=lambda p: p.rating100 &gt;= 80 and p.favorite\n    )\n    # \u2713 Only fetches rating100+favorite for the 5000 performers\n    # \u2713 Much smaller payload than re-fetching full performer data\n    # \u2713 Results: All matching performers with complete data\n</code></pre>"},{"location":"guide/advanced-filtering/#performance-benefits","title":"Performance Benefits","text":"<p>Scenario: Cache has 1000 performers with basic info, need to filter by <code>rating100</code></p> Approach Network Payload Time Description <code>find()</code> ~500KB ~500ms Re-fetch all 1000 \u00d7 full data <code>filter_and_populate()</code> ~50KB ~50ms Fetch 1000 \u00d7 1 field only Speedup 10x smaller 10x faster Field-level fetching wins"},{"location":"guide/advanced-filtering/#batch-size-parameter","title":"Batch Size Parameter","text":"<p>Controls how many entities are populated concurrently:</p> <pre><code># Default: 50 concurrent populates\nresults = await store.filter_and_populate(\n    Performer,\n    required_fields=['rating100'],\n    predicate=lambda p: p.rating100 &gt;= 80\n)\n\n# Smaller batches (gentler on server)\nresults = await store.filter_and_populate(\n    Performer,\n    required_fields=['rating100'],\n    predicate=lambda p: p.rating100 &gt;= 80,\n    batch_size=10  # Only 10 concurrent requests\n)\n</code></pre>"},{"location":"guide/advanced-filtering/#filter_and_populate_with_stats-debug-variant","title":"<code>filter_and_populate_with_stats()</code> - Debug Variant","text":"<p>Same as <code>filter_and_populate()</code> but returns detailed statistics. Useful for performance optimization.</p>"},{"location":"guide/advanced-filtering/#signature_2","title":"Signature","text":"<pre><code>async def filter_and_populate_with_stats(\n    self,\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n    batch_size: int = 50,\n) -&gt; tuple[list[T], dict[str, Any]]:\n</code></pre>"},{"location":"guide/advanced-filtering/#example_2","title":"Example","text":"<pre><code>from stash_graphql_client import StashContext, Performer\n\nasync with StashContext(conn=conn) as context:\n    store = context.store\n\n    # Filter with statistics\n    results, stats = await store.filter_and_populate_with_stats(\n        Performer,\n        required_fields=['rating100', 'favorite'],\n        predicate=lambda p: p.rating100 &gt;= 80 and p.favorite\n    )\n\n    # Analyze cache performance\n    print(f\"Total cached: {stats['total_cached']}\")\n    print(f\"Needed population: {stats['needed_population']}\")\n    print(f\"Cache hit rate: {stats['cache_hit_rate']:.1%}\")\n    print(f\"Found matches: {stats['matches']}\")\n\n    # Example output:\n    # Total cached: 1000\n    # Needed population: 500\n    # Cache hit rate: 50.0%\n    # Found matches: 237\n</code></pre>"},{"location":"guide/advanced-filtering/#statistics-dictionary","title":"Statistics Dictionary","text":"<pre><code>{\n    \"total_cached\": 1000,           # Total objects in cache\n    \"needed_population\": 500,       # How many needed fields fetched\n    \"populated_fields\": [\"rating100\", \"favorite\"],  # Which fields\n    \"matches\": 237,                 # How many matched predicate\n    \"cache_hit_rate\": 0.5           # 50% had complete data\n}\n</code></pre>"},{"location":"guide/advanced-filtering/#when-to-use_1","title":"When to Use","text":"<ul> <li>Performance analysis: Identify cache inefficiencies</li> <li>Optimization: Determine if cache warming is needed</li> <li>Debugging: Understand why queries are slow</li> </ul>"},{"location":"guide/advanced-filtering/#populated_filter_iter-lazy-async-iterator","title":"<code>populated_filter_iter()</code> - Lazy Async Iterator","text":"<p>Lazy version of <code>filter_and_populate()</code> that yields results incrementally. Great for large datasets where you want to start processing immediately or can short-circuit early.</p>"},{"location":"guide/advanced-filtering/#signature_3","title":"Signature","text":"<pre><code>async def populated_filter_iter(\n    self,\n    entity_type: type[T],\n    required_fields: set[str] | list[str],\n    predicate: Callable[[T], bool],\n    populate_batch: int = 50,\n    yield_batch: int = 10,\n) -&gt; AsyncIterator[T]:\n</code></pre>"},{"location":"guide/advanced-filtering/#example-early-exit","title":"Example: Early Exit","text":"<pre><code>from stash_graphql_client import StashContext, Performer\n\nasync with StashContext(conn=conn) as context:\n    store = context.store\n\n    # Find first 10 high-rated performers from 10,000 cached\n    count = 0\n    async for performer in store.populated_filter_iter(\n        Performer,\n        required_fields=['rating100', 'scenes'],\n        predicate=lambda p: p.rating100 &gt;= 90 and len(p.scenes) &gt; 100,\n        populate_batch=50,   # Fetch 50 at a time\n        yield_batch=10       # Yield after processing each 10\n    ):\n        # Start processing immediately as matches are found\n        await expensive_operation(performer)\n        count += 1\n\n        # Early exit - don't process all 10,000\n        if count &gt;= 10:\n            break  # Only processed ~100-200 performers\n</code></pre>"},{"location":"guide/advanced-filtering/#example-incremental-processing","title":"Example: Incremental Processing","text":"<pre><code>from stash_graphql_client import StashContext, Scene\n\nasync with StashContext(conn=conn) as context:\n    store = context.store\n\n    # Process large dataset incrementally\n    processed = 0\n    async for scene in store.populated_filter_iter(\n        Scene,\n        required_fields=['file', 'performers'],\n        predicate=lambda s: s.file.size &gt; 1_000_000_000,  # &gt; 1GB\n        populate_batch=50,\n        yield_batch=10\n    ):\n        # Yields results as they're ready (doesn't wait for all)\n        await process_large_scene(scene)\n        processed += 1\n\n        # Update progress bar\n        if processed % 10 == 0:\n            print(f\"Processed {processed} large scenes...\")\n</code></pre>"},{"location":"guide/advanced-filtering/#batch-parameters","title":"Batch Parameters","text":"<pre><code>async for item in store.populated_filter_iter(\n    Performer,\n    required_fields=['rating100'],\n    predicate=lambda p: p.rating100 &gt;= 80,\n    populate_batch=50,  # Concurrent populates per sub-batch\n    yield_batch=10      # Process 10 entities before yielding matches\n):\n    process(item)\n</code></pre> <ul> <li><code>populate_batch</code>: How many to populate concurrently (default: 50)</li> <li><code>yield_batch</code>: How many to process before yielding (default: 10)</li> </ul>"},{"location":"guide/advanced-filtering/#when-to-use_2","title":"When to Use","text":"<ul> <li>Large datasets: Process 10,000+ entities incrementally</li> <li>Early exit: Stop processing when you find enough matches</li> <li>Memory efficiency: Don't load all results into memory</li> <li>Progress reporting: Update UI as results stream in</li> </ul>"},{"location":"guide/advanced-filtering/#real-world-workflow-example","title":"Real-World Workflow Example","text":"<pre><code>from stash_graphql_client import StashContext, Performer\n\nasync with StashContext(conn=conn) as context:\n    store = context.store\n\n    # Step 1: Initial cache population (lightweight)\n    print(\"Loading performers...\")\n    async for performer in store.find_iter(Performer, query_batch=100):\n        # Loads: id, name, gender (minimal fields)\n        cache_performer(performer)\n    print(f\"Cached {len(store.all_cached(Performer))} performers\")\n\n    # Step 2: User filters by rating (partial data in cache)\n    print(\"\\nFinding high-rated performers...\")\n    results, stats = await store.filter_and_populate_with_stats(\n        Performer,\n        required_fields=['rating100', 'favorite'],\n        predicate=lambda p: p.rating100 &gt;= 80 and p.favorite\n    )\n\n    print(f\"Cache hit rate: {stats['cache_hit_rate']:.1%}\")\n    print(f\"Fetched fields for: {stats['needed_population']} performers\")\n    print(f\"Found: {len(results)} matches\")\n\n    # Step 3: Verify cache before expensive operation\n    try:\n        verified = store.filter_strict(\n            Performer,\n            required_fields=['rating100', 'favorite', 'scenes'],\n            predicate=lambda p: p in results\n        )\n        # All performers now guaranteed to have scenes field\n        for performer in verified:\n            process_with_scenes(performer)\n    except ValueError:\n        # Some performers missing 'scenes' field - populate it\n        for performer in results:\n            if not store.has_fields(performer, 'scenes'):\n                await store.populate(performer, fields=['scenes'])\n</code></pre>"},{"location":"guide/advanced-filtering/#best-practices","title":"Best Practices","text":""},{"location":"guide/advanced-filtering/#1-choose-the-right-method","title":"1. Choose the Right Method","text":"<pre><code># \u2713 Fast local query, data already complete\nresults = store.filter(Performer, lambda p: p.rating100 &gt;= 80)\n\n# \u2713 Smart hybrid, auto-populate missing fields\nresults = await store.filter_and_populate(\n    Performer,\n    required_fields=['rating100'],\n    predicate=lambda p: p.rating100 &gt;= 80\n)\n\n# \u2713 Fail-fast validation before critical operation\nresults = store.filter_strict(\n    Performer,\n    required_fields=['rating100', 'scenes'],\n    predicate=lambda p: p.rating100 &gt;= 80\n)\n\n# \u2713 Large dataset with early exit\nasync for item in store.populated_filter_iter(\n    Performer,\n    required_fields=['rating100'],\n    predicate=lambda p: p.rating100 &gt;= 95\n):\n    if found_enough():\n        break\n</code></pre>"},{"location":"guide/advanced-filtering/#2-cache-warming-strategy","title":"2. Cache Warming Strategy","text":"<pre><code># Strategy 1: Minimal initial load\nasync for performer in store.find_iter(Performer):\n    # Loads minimal fields\n    pass\n\n# Later: Populate on-demand\nresults = await store.filter_and_populate(\n    Performer,\n    required_fields=['rating100'],\n    predicate=lambda p: p.rating100 &gt;= 80\n)\n\n# Strategy 2: Pre-load common fields\nawait store.find(\n    Performer,\n    # Specify fields in GraphQL query (if supported by client method)\n)\n</code></pre>"},{"location":"guide/advanced-filtering/#3-performance-monitoring","title":"3. Performance Monitoring","text":"<pre><code># Use stats variant to optimize\nfor _ in range(10):\n    results, stats = await store.filter_and_populate_with_stats(\n        Performer,\n        required_fields=['rating100'],\n        predicate=lambda p: p.rating100 &gt;= 80\n    )\n\n    if stats['cache_hit_rate'] &lt; 0.5:\n        print(f\"Warning: Low cache hit rate ({stats['cache_hit_rate']:.1%})\")\n        print(\"Consider cache warming or adjusting TTL\")\n</code></pre>"},{"location":"guide/advanced-filtering/#4-field-dependencies","title":"4. Field Dependencies","text":"<pre><code># If predicate needs multiple fields, list them all\nresults = await store.filter_and_populate(\n    Scene,\n    required_fields=['rating100', 'performers', 'tags', 'studio'],\n    predicate=lambda s: (\n        s.rating100 &gt;= 80 and\n        len(s.performers) &gt; 2 and\n        any(t.name == \"Action\" for t in s.tags) and\n        s.studio.name == \"Acme Studios\"\n    )\n)\n</code></pre>"},{"location":"guide/advanced-filtering/#integration-with-unset-pattern","title":"Integration with UNSET Pattern","text":"<p>The advanced filter methods work seamlessly with the UNSET Pattern:</p> <pre><code>from stash_graphql_client.types.unset import UNSET\n\n# Manual check for UNSET fields\nif performer.rating100 is UNSET:\n    # Field not queried - use filter_and_populate\n    results = await store.filter_and_populate(\n        Performer,\n        required_fields=['rating100'],\n        predicate=lambda p: p.id == performer.id\n    )\nelse:\n    # Field is loaded (None or value) - safe to use\n    if performer.rating100 and performer.rating100 &gt;= 80:\n        process(performer)\n\n# Or use filter_strict to enforce\ntry:\n    results = store.filter_strict(\n        Performer,\n        required_fields=['rating100'],\n        predicate=lambda p: p.rating100 &gt;= 80\n    )\nexcept ValueError:\n    # Some performers have rating100=UNSET\n    results = await store.filter_and_populate(\n        Performer,\n        required_fields=['rating100'],\n        predicate=lambda p: p.rating100 &gt;= 80\n    )\n</code></pre>"},{"location":"guide/advanced-filtering/#see-also","title":"See Also","text":"<ul> <li>UNSET Pattern: Understanding unqueried vs null fields</li> <li>Identity Map: Object caching and identity</li> <li>Entity Store API: Full API reference</li> <li>Usage Patterns: Common usage scenarios</li> </ul>"},{"location":"guide/fuzzy-dates/","title":"Fuzzy Dates","text":"<p>Stash v0.30.0+ introduced support for partial dates (fuzzy dates), allowing you to store dates with varying levels of precision. This guide explains how to work with fuzzy dates in the client library.</p>"},{"location":"guide/fuzzy-dates/#what-are-fuzzy-dates","title":"What Are Fuzzy Dates?","text":"<p>Fuzzy dates allow you to express dates when you don't know the complete information:</p> <ul> <li>Year only: <code>\"2024\"</code> - You know the year but not the month/day</li> <li>Year-Month: <code>\"2024-03\"</code> - You know the year and month but not the day</li> <li>Full date: <code>\"2024-03-15\"</code> - Complete date information</li> </ul> <p>This is particularly useful for:</p> <ul> <li>Performer birthdates when exact date is unknown</li> <li>Scene release dates with only year/month known</li> <li>Historical events with approximate dates</li> </ul>"},{"location":"guide/fuzzy-dates/#date-precision-levels","title":"Date Precision Levels","text":"<p>The library defines three precision levels:</p> <pre><code>from stash_graphql_client.types import DatePrecision\n\nDatePrecision.YEAR   # \"YYYY\" format (e.g., \"2024\")\nDatePrecision.MONTH  # \"YYYY-MM\" format (e.g., \"2024-03\")\nDatePrecision.DAY    # \"YYYY-MM-DD\" format (e.g., \"2024-03-15\")\n</code></pre>"},{"location":"guide/fuzzy-dates/#working-with-fuzzy-dates","title":"Working with Fuzzy Dates","text":""},{"location":"guide/fuzzy-dates/#creating-fuzzy-dates","title":"Creating Fuzzy Dates","text":"<pre><code>from stash_graphql_client.types import FuzzyDate\n\n# Year precision\nyear_date = FuzzyDate(\"2024\")\nprint(year_date.precision)  # DatePrecision.YEAR\nprint(year_date.value)      # \"2024\"\n\n# Month precision\nmonth_date = FuzzyDate(\"2024-03\")\nprint(month_date.precision)  # DatePrecision.MONTH\nprint(month_date.value)      # \"2024-03\"\n\n# Day precision (full date)\nday_date = FuzzyDate(\"2024-03-15\")\nprint(day_date.precision)  # DatePrecision.DAY\nprint(day_date.value)      # \"2024-03-15\"\n</code></pre>"},{"location":"guide/fuzzy-dates/#validating-date-strings","title":"Validating Date Strings","text":"<p>Use the validation utility to check if a date string is valid:</p> <pre><code>from stash_graphql_client.types import validate_fuzzy_date\n\n# Valid formats\nvalidate_fuzzy_date(\"2024\")         # True\nvalidate_fuzzy_date(\"2024-03\")      # True\nvalidate_fuzzy_date(\"2024-03-15\")   # True\n\n# Invalid formats\nvalidate_fuzzy_date(\"2024-3\")       # False - month must be zero-padded\nvalidate_fuzzy_date(\"2024-03-5\")    # False - day must be zero-padded\nvalidate_fuzzy_date(\"24\")           # False - year must be 4 digits\nvalidate_fuzzy_date(\"2024/03/15\")   # False - wrong separator\n</code></pre>"},{"location":"guide/fuzzy-dates/#converting-to-python-datetime","title":"Converting to Python datetime","text":"<p>Convert fuzzy dates to Python datetime objects:</p> <pre><code>from stash_graphql_client.types import FuzzyDate\n\n# Year precision - defaults to January 1st\nyear_date = FuzzyDate(\"2024\")\ndt = year_date.to_datetime()  # datetime(2024, 1, 1)\n\n# Month precision - defaults to 1st of month\nmonth_date = FuzzyDate(\"2024-03\")\ndt = month_date.to_datetime()  # datetime(2024, 3, 1)\n\n# Day precision - exact date\nday_date = FuzzyDate(\"2024-03-15\")\ndt = day_date.to_datetime()  # datetime(2024, 3, 15)\n</code></pre>"},{"location":"guide/fuzzy-dates/#normalizing-dates","title":"Normalizing Dates","text":"<p>Convert between different precision levels:</p> <pre><code>from stash_graphql_client.types import normalize_date\n\nfull_date = \"2024-03-15\"\n\n# Reduce precision\nnormalize_date(full_date, \"year\")   # \"2024\"\nnormalize_date(full_date, \"month\")  # \"2024-03\"\nnormalize_date(full_date, \"day\")    # \"2024-03-15\" (unchanged)\n\n# Increase precision (adds defaults)\nyear_only = \"2024\"\nnormalize_date(year_only, \"month\")  # \"2024-01\"\nnormalize_date(year_only, \"day\")    # \"2024-01-01\"\n\nmonth_only = \"2024-03\"\nnormalize_date(month_only, \"day\")   # \"2024-03-01\"\n</code></pre>"},{"location":"guide/fuzzy-dates/#using-fuzzy-dates-with-stash","title":"Using Fuzzy Dates with Stash","text":""},{"location":"guide/fuzzy-dates/#performer-birthdates","title":"Performer Birthdates","text":"<pre><code>from stash_graphql_client.types import Performer\n\nasync with StashContext(conn=conn) as client:\n    # Exact birthdate known\n    performer1 = await client.create_performer(\n        Performer(name=\"Jane Doe\", birthdate=\"1990-05-15\")\n    )\n\n    # Only birth year known\n    performer2 = await client.create_performer(\n        Performer(name=\"John Smith\", birthdate=\"1985\")\n    )\n\n    # Birth year and month known\n    performer3 = await client.create_performer(\n        Performer(name=\"Alice Johnson\", birthdate=\"1992-07\")\n    )\n</code></pre>"},{"location":"guide/fuzzy-dates/#scene-dates","title":"Scene Dates","text":"<pre><code>from stash_graphql_client.types import Scene\n\nasync with StashContext(conn=conn) as client:\n    # Exact date\n    scene1 = await client.update_scene(\n        Scene(id=\"scene-id-1\", date=\"2024-03-15\")\n    )\n\n    # Month precision\n    scene2 = await client.update_scene(\n        Scene(id=\"scene-id-2\", date=\"2024-03\")\n    )\n\n    # Year only\n    scene3 = await client.update_scene(\n        Scene(id=\"scene-id-3\", date=\"2024\")\n    )\n</code></pre>"},{"location":"guide/fuzzy-dates/#comparing-fuzzy-dates","title":"Comparing Fuzzy Dates","text":"<pre><code>from stash_graphql_client.types import FuzzyDate\n\ndate1 = FuzzyDate(\"2024\")\ndate2 = FuzzyDate(\"2024-03\")\ndate3 = FuzzyDate(\"2024-03-15\")\n\n# Compare precision\nprint(date1.precision == DatePrecision.YEAR)   # True\nprint(date2.precision == DatePrecision.MONTH)  # True\nprint(date3.precision == DatePrecision.DAY)    # True\n\n# Compare values\nprint(date1.value)  # \"2024\"\nprint(date2.value)  # \"2024-03\"\nprint(date3.value)  # \"2024-03-15\"\n\n# Compare as datetime (all convert to first day)\ndt1 = date1.to_datetime()  # 2024-01-01\ndt2 = date2.to_datetime()  # 2024-03-01\ndt3 = date3.to_datetime()  # 2024-03-15\n\nprint(dt1 &lt; dt2 &lt; dt3)  # True\n</code></pre>"},{"location":"guide/fuzzy-dates/#handling-unknown-dates","title":"Handling Unknown Dates","text":"<p>When dates are completely unknown, use <code>None</code>:</p> <pre><code>from stash_graphql_client.types import Performer\n\nasync with StashContext(conn=conn) as client:\n    # Birthdate unknown\n    performer = await client.create_performer(\n        Performer(name=\"Unknown Birthdate\", birthdate=None)\n    )\n\n    # Check if birthdate is set\n    if performer.birthdate is None:\n        print(\"Birthdate unknown\")\n    elif performer.birthdate is not UNSET:\n        print(f\"Birthdate: {performer.birthdate}\")\n</code></pre>"},{"location":"guide/fuzzy-dates/#best-practices","title":"Best Practices","text":""},{"location":"guide/fuzzy-dates/#1-use-the-most-specific-precision-available","title":"1. Use the Most Specific Precision Available","text":"<pre><code># \u2705 Good - Use what you know\nbirthdate = \"1990-07\"  # Year and month known\n\n# \u274c Bad - Guessing the day\nbirthdate = \"1990-07-01\"  # Day unknown, shouldn't guess\n</code></pre>"},{"location":"guide/fuzzy-dates/#2-validate-before-saving","title":"2. Validate Before Saving","text":"<pre><code>from stash_graphql_client.types import validate_fuzzy_date, Performer\n\nuser_input = \"2024-3\"  # From user\n\n# \u2705 Good - Validate first\nif validate_fuzzy_date(user_input):\n    await client.create_performer(Performer(name=\"Name\", birthdate=user_input))\nelse:\n    # Normalize or fix the input\n    normalized = user_input if len(user_input.split('-')[1]) == 2 else f\"2024-03\"\n</code></pre>"},{"location":"guide/fuzzy-dates/#3-handle-all-precision-levels","title":"3. Handle All Precision Levels","text":"<pre><code># \u2705 Good - Handle all cases\ndate = FuzzyDate(performer.birthdate)\n\nif date.precision == DatePrecision.DAY:\n    print(f\"Born on {date.value}\")\nelif date.precision == DatePrecision.MONTH:\n    print(f\"Born in {date.value}\")\nelse:\n    print(f\"Born in {date.value}\")\n\n# \u274c Bad - Assuming full date\nprint(f\"Born on {performer.birthdate}\")  # Might be \"1990\"!\n</code></pre>"},{"location":"guide/fuzzy-dates/#4-use-normalization-for-consistency","title":"4. Use Normalization for Consistency","text":"<pre><code>from stash_graphql_client.types import normalize_date\n\n# \u2705 Good - Normalize for comparison\ndates = [\"2024\", \"2024-03\", \"2024-03-15\"]\nnormalized = [normalize_date(d, \"day\") for d in dates]\n# All normalized to full dates for comparison\n\n# Sort by normalized dates\nsorted_dates = sorted(dates, key=lambda d: normalize_date(d, \"day\"))\n</code></pre>"},{"location":"guide/fuzzy-dates/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/fuzzy-dates/#age-calculation-with-fuzzy-dates","title":"Age Calculation with Fuzzy Dates","text":"<pre><code>from datetime import datetime\nfrom stash_graphql_client.types import FuzzyDate\n\ndef calculate_age(birthdate_str: str) -&gt; int:\n    \"\"\"Calculate age from fuzzy birthdate.\"\"\"\n    fuzzy_date = FuzzyDate(birthdate_str)\n    birth_dt = fuzzy_date.to_datetime()\n    today = datetime.now()\n\n    age = today.year - birth_dt.year\n\n    # Adjust if birthday hasn't occurred this year yet\n    # (Only accurate for full dates)\n    if fuzzy_date.precision == DatePrecision.DAY:\n        if (today.month, today.day) &lt; (birth_dt.month, birth_dt.day):\n            age -= 1\n\n    return age\n\n# Usage\nage = calculate_age(\"1990-05-15\")  # Exact\napprox_age = calculate_age(\"1990\")  # Approximate\n</code></pre>"},{"location":"guide/fuzzy-dates/#display-formatting","title":"Display Formatting","text":"<pre><code>from stash_graphql_client.types import FuzzyDate, DatePrecision\n\ndef format_date(date_str: str) -&gt; str:\n    \"\"\"Format fuzzy date for display.\"\"\"\n    date = FuzzyDate(date_str)\n\n    if date.precision == DatePrecision.YEAR:\n        return date.value\n    elif date.precision == DatePrecision.MONTH:\n        # Convert to \"March 2024\"\n        dt = date.to_datetime()\n        return dt.strftime(\"%B %Y\")\n    else:\n        # Convert to \"March 15, 2024\"\n        dt = date.to_datetime()\n        return dt.strftime(\"%B %d, %Y\")\n\n# Usage\nprint(format_date(\"2024\"))         # \"2024\"\nprint(format_date(\"2024-03\"))      # \"March 2024\"\nprint(format_date(\"2024-03-15\"))   # \"March 15, 2024\"\n</code></pre>"},{"location":"guide/fuzzy-dates/#next-steps","title":"Next Steps","text":"<ul> <li>UNSET Pattern - Distinguish unset from null values</li> <li>API Reference - Explore type definitions</li> <li>Client API - Explore client methods</li> </ul>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>This guide will walk you through installing and using stash-graphql-client for the first time.</p>"},{"location":"guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher</li> <li>Stash server running and accessible (tested with v0.25.0+)</li> <li>Poetry (optional, for development)</li> </ul>"},{"location":"guide/getting-started/#installation","title":"Installation","text":""},{"location":"guide/getting-started/#option-1-install-from-pypi-recommended","title":"Option 1: Install from PyPI (Recommended)","text":"<pre><code>pip install stash-graphql-client\n</code></pre>"},{"location":"guide/getting-started/#option-2-install-with-poetry","title":"Option 2: Install with Poetry","text":"<pre><code>poetry add stash-graphql-client\n</code></pre>"},{"location":"guide/getting-started/#option-3-install-from-source","title":"Option 3: Install from Source","text":"<pre><code>git clone https://github.com/Jakan-Kink/stash-graphql-client.git\ncd stash-graphql-client\npoetry install\n</code></pre>"},{"location":"guide/getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code>import stash_graphql_client\nprint(stash_graphql_client.__version__)\n</code></pre>"},{"location":"guide/getting-started/#configuration","title":"Configuration","text":""},{"location":"guide/getting-started/#connection-settings","title":"Connection Settings","text":"<p>Create a connection dictionary with your Stash server details:</p> <pre><code>conn = {\n    \"Scheme\": \"http\",       # or \"https\"\n    \"Host\": \"localhost\",    # Stash server hostname\n    \"Port\": 9999,           # Stash server port\n    \"ApiKey\": \"...\",        # Optional API key\n}\n</code></pre>"},{"location":"guide/getting-started/#api-key-optional","title":"API Key (Optional)","text":"<p>If your Stash instance requires authentication:</p> <ol> <li>Open Stash web interface</li> <li>Go to Settings \u2192 Security</li> <li>Generate an API Key</li> <li>Add it to your connection config</li> </ol> <pre><code>conn = {\n    \"Host\": \"localhost\",\n    \"Port\": 9999,\n    \"ApiKey\": \"your-api-key-here\",  # From Stash settings\n}\n</code></pre>"},{"location":"guide/getting-started/#your-first-script","title":"Your First Script","text":""},{"location":"guide/getting-started/#example-1-list-all-studios","title":"Example 1: List All Studios","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\n\nasync def main():\n    # Connect using context manager (recommended)\n    async with StashContext(conn={\n        \"Host\": \"localhost\",\n        \"Port\": 9999,\n    }) as client:\n        # Find all studios\n        result = await client.find_studios()\n\n        print(f\"Found {result.count} studios:\")\n        for studio in result.studios:\n            print(f\"  - {studio.name} (ID: {studio.id})\")\n\n# Run the async function\nasyncio.run(main())\n</code></pre> <p>Output:</p> <pre><code>Found 25 studios:\n  - Acme Productions (ID: 1)\n  - Studio B (ID: 2)\n  - Example Corp (ID: 3)\n  ...\n</code></pre>"},{"location":"guide/getting-started/#example-2-create-a-new-tag","title":"Example 2: Create a New Tag","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\nfrom stash_graphql_client.types import Tag\n\nasync def main():\n    async with StashContext(conn={\n        \"Host\": \"localhost\",\n        \"Port\": 9999,\n    }) as client:\n        # Create a new tag\n        tag = Tag(\n            name=\"Documentary\",\n            description=\"Documentary-style content\"\n        )\n\n        # Save to server\n        saved_tag = await tag.save(client)\n\n        print(f\"Created tag: {saved_tag.name}\")\n        print(f\"Server assigned ID: {saved_tag.id}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#example-3-find-and-update-a-scene","title":"Example 3: Find and Update a Scene","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\nfrom stash_graphql_client.types import UNSET\n\nasync def main():\n    async with StashContext(conn={\n        \"Host\": \"localhost\",\n        \"Port\": 9999,\n    }) as client:\n        # Find a scene by ID\n        scene = await client.find_scene(\"123\")\n\n        if scene is None:\n            print(\"Scene not found\")\n            return\n\n        print(f\"Found scene: {scene.title}\")\n        print(f\"Current rating: {scene.rating100}\")\n\n        # Update the rating\n        scene.rating100 = 95\n        scene.details = UNSET  # Don't touch this field\n\n        # Save changes\n        await scene.save(client)\n\n        print(f\"Updated rating to: {scene.rating100}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#core-workflows","title":"Core Workflows","text":""},{"location":"guide/getting-started/#workflow-1-find-and-update-entity","title":"Workflow 1: Find and Update Entity","text":"<p>This is the most common pattern for working with existing entities.</p> <pre><code>import asyncio\nfrom stash_graphql_client import StashContext\n\nasync def update_performer_birthdate():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        # 1. Find the entity\n        performer = await client.find_performer(\"456\")\n\n        if performer is None:\n            print(\"Performer not found\")\n            return\n\n        # 2. Modify fields\n        performer.birthdate = \"1990-05-15\"\n        performer.gender = \"FEMALE\"\n\n        # 3. Save changes\n        await performer.save(client)\n\n        print(f\"Updated {performer.name}\")\n\nasyncio.run(update_performer_birthdate())\n</code></pre>"},{"location":"guide/getting-started/#workflow-2-create-and-link-entities","title":"Workflow 2: Create and Link Entities","text":"<p>Create new entities and establish relationships.</p> <pre><code>import asyncio\nfrom stash_graphql_client import StashContext\nfrom stash_graphql_client.types import Scene, Tag\n\nasync def create_scene_with_tags():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        # 1. Create or find tags\n        tag1 = Tag(name=\"Action\")\n        await tag1.save(client)\n\n        tag2 = Tag(name=\"Adventure\")\n        await tag2.save(client)\n\n        # 2. Create scene\n        scene = Scene(title=\"Epic Battle\", rating100=90)\n        await scene.save(client)\n\n        # 3. Link tags to scene\n        await scene.add_tag(tag1)\n        await scene.add_tag(tag2)\n\n        print(f\"Created scene '{scene.title}' with {len(scene.tags)} tags\")\n\nasyncio.run(create_scene_with_tags())\n</code></pre>"},{"location":"guide/getting-started/#workflow-3-bulk-processing-with-filters","title":"Workflow 3: Bulk Processing with Filters","text":"<p>Process multiple entities matching specific criteria.</p> <pre><code>import asyncio\nfrom stash_graphql_client import StashContext, StashEntityStore\nfrom stash_graphql_client.types import Scene\n\nasync def organize_unrated_scenes():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        store = StashEntityStore(client)\n\n        # Find all unrated scenes\n        unrated = await store.find(Scene, rating100__null=True, organized=False)\n\n        print(f\"Found {len(unrated)} unrated scenes\")\n\n        # Process each scene\n        for scene in unrated:\n            # Apply default rating\n            scene.rating100 = 50\n            scene.organized = True\n            await scene.save(client)\n\n            print(f\"  - Organized: {scene.title}\")\n\n        print(\"Done!\")\n\nasyncio.run(organize_unrated_scenes())\n</code></pre>"},{"location":"guide/getting-started/#using-the-entity-store","title":"Using the Entity Store","text":"<p>The <code>StashEntityStore</code> provides additional features like caching, Django-style filtering, and field-aware population.</p>"},{"location":"guide/getting-started/#basic-store-usage","title":"Basic Store Usage","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext, StashEntityStore\nfrom stash_graphql_client.types import Performer\n\nasync def main():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        # Create store with 5-minute cache TTL\n        store = StashEntityStore(client, ttl_seconds=300)\n\n        # Read-through caching (fetches if not cached)\n        performer1 = await store.get(Performer, \"123\")\n        performer2 = await store.get(Performer, \"123\")\n\n        # Both references point to same object\n        assert performer1 is performer2\n\n        print(f\"Performer: {performer1.name}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#django-style-filtering","title":"Django-Style Filtering","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext, StashEntityStore\nfrom stash_graphql_client.types import Scene\n\nasync def main():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        store = StashEntityStore(client)\n\n        # Find highly-rated scenes\n        top_rated = await store.find(Scene, rating100__gte=90)\n\n        print(f\"Found {len(top_rated)} highly-rated scenes:\")\n        for scene in top_rated:\n            print(f\"  - {scene.title}: {scene.rating100}/100\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#understanding-unset","title":"Understanding UNSET","text":"<p>The UNSET pattern is one of the library's key features for precise partial updates.</p>"},{"location":"guide/getting-started/#three-field-states","title":"Three Field States","text":"<pre><code>from stash_graphql_client.types import Scene, UNSET\n\nscene = Scene(title=\"Test\")\n\n# Three possible states for any field:\nscene.title = \"Example\"     # State 1: Set to value\nscene.rating100 = None      # State 2: Explicitly null\nscene.details = UNSET       # State 3: Never touched\n</code></pre>"},{"location":"guide/getting-started/#why-unset-matters","title":"Why UNSET Matters","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\nfrom stash_graphql_client.types import UNSET\n\nasync def main():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        # Load a scene\n        scene = await client.find_scene(\"123\")\n\n        # Only update rating, leave everything else unchanged\n        scene.rating100 = 95\n        # scene.title stays UNSET - won't be included in mutation\n        # scene.details stays UNSET - server keeps existing value\n\n        # Save only sends rating100 field\n        await scene.save(client)\n\n        print(\"Updated only the rating!\")\n\nasyncio.run(main())\n</code></pre> <p>See UNSET Pattern Guide for comprehensive examples.</p>"},{"location":"guide/getting-started/#working-with-relationships","title":"Working with Relationships","text":""},{"location":"guide/getting-started/#accessing-related-entities","title":"Accessing Related Entities","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\nfrom stash_graphql_client.types import is_set\n\nasync def main():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        scene = await client.find_scene(\"123\")\n\n        # Always check for UNSET before accessing relationships\n        if is_set(scene.studio):\n            print(f\"Studio: {scene.studio.name}\")\n\n        if is_set(scene.performers):\n            print(f\"Performers: {len(scene.performers)}\")\n            for performer in scene.performers:\n                print(f\"  - {performer.name}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#setting-relationships","title":"Setting Relationships","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\n\nasync def main():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        scene = await client.find_scene(\"123\")\n        studio = await client.find_studio(\"456\")\n\n        # Set the relationship\n        scene.studio = studio\n        await scene.save(client)\n\n        print(f\"Set studio to: {studio.name}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#using-relationship-helpers","title":"Using Relationship Helpers","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\n\nasync def main():\n    async with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n        scene = await client.find_scene(\"123\")\n        performer = await client.find_performer(\"789\")\n\n        # Add to many-to-many relationship\n        await scene.add_performer(performer)\n\n        print(f\"Added {performer.name} to scene\")\n\n        # Remove from relationship\n        await scene.remove_performer(performer)\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#error-handling","title":"Error Handling","text":""},{"location":"guide/getting-started/#handling-common-errors","title":"Handling Common Errors","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\nfrom stash_graphql_client.types import Scene\nfrom pydantic import ValidationError\nfrom gql.transport.exceptions import TransportQueryError\nfrom httpx import ConnectError\n\nasync def main():\n    try:\n        async with StashContext(conn={\n            \"Host\": \"localhost\",\n            \"Port\": 9999,\n        }) as client:\n            # Validation error example\n            try:\n                scene = Scene(rating100=150)  # Invalid: must be 0-100\n            except ValidationError as e:\n                print(\"Validation error:\")\n                for error in e.errors():\n                    print(f\"  {error['loc']}: {error['msg']}\")\n\n            # GraphQL query error\n            scene = await client.find_scene(\"invalid-id\")\n            if scene is None:\n                print(\"Scene not found\")\n\n    except ConnectError:\n        print(\"Cannot connect to Stash server - is it running?\")\n    except TransportQueryError as e:\n        print(f\"GraphQL error: {e}\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"guide/getting-started/#best-practices","title":"Best Practices","text":""},{"location":"guide/getting-started/#1-use-context-manager","title":"1. Use Context Manager","text":"<p>Always use <code>StashContext</code> as a context manager to ensure proper cleanup:</p> <pre><code># \u2705 Good\nasync with StashContext(conn={...}) as client:\n    await client.find_scenes()\n\n# \u274c Avoid\ncontext = StashContext(conn={...})\nclient = await context.get_client()\n# ... might forget to close\n</code></pre>"},{"location":"guide/getting-started/#2-check-for-unset-before-accessing","title":"2. Check for UNSET Before Accessing","text":"<p>Always check if a field is UNSET before using it:</p> <pre><code>from stash_graphql_client.types import is_set\n\n# \u2705 Good - using helper method\nif is_set(scene.studio):\n    print(scene.studio.name)\n\n# \u2705 Good - manual check\nif scene.studio is not UNSET and scene.studio is not None:\n    print(scene.studio.name)\n\n# \u274c Avoid\nprint(scene.studio.name)  # Might fail if UNSET\n</code></pre>"},{"location":"guide/getting-started/#3-use-unset-for-partial-updates","title":"3. Use UNSET for Partial Updates","text":"<p>When updating only specific fields, leave others as UNSET:</p> <pre><code># \u2705 Good\nscene.rating100 = 90\n# Other fields stay UNSET\nawait scene.save(client)\n\n# \u274c Avoid\nscene.rating100 = 90\nscene.title = scene.title  # Unnecessary\nscene.details = scene.details  # Unnecessary\nawait scene.save(client)\n</code></pre>"},{"location":"guide/getting-started/#4-use-store-for-repeated-queries","title":"4. Use Store for Repeated Queries","text":"<p>If querying the same entities multiple times, use StashEntityStore:</p> <pre><code># \u2705 Good\nstore = StashEntityStore(client)\nperformer1 = await store.get(Performer, \"123\")  # Fetches from server\nperformer2 = await store.get(Performer, \"123\")  # Returns cached\n\n# \u274c Less efficient\nperformer1 = await client.find_performer(\"123\")  # Fetches\nperformer2 = await client.find_performer(\"123\")  # Fetches again\n</code></pre>"},{"location":"guide/getting-started/#5-handle-none-responses","title":"5. Handle None Responses","text":"<p>Always check if entities exist before using them:</p> <pre><code># \u2705 Good\nscene = await client.find_scene(\"123\")\nif scene is None:\n    print(\"Scene not found\")\n    return\n\nprint(scene.title)\n\n# \u274c Avoid\nscene = await client.find_scene(\"123\")\nprint(scene.title)  # Might crash if scene is None\n</code></pre>"},{"location":"guide/getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/getting-started/#pattern-get-or-create","title":"Pattern: Get or Create","text":"<pre><code>async def get_or_create_tag(client, name):\n    # Try to find existing tag\n    tags_result = await client.find_tags(\n        tag_filter={\"name\": {\"value\": name, \"modifier\": \"EQUALS\"}}\n    )\n\n    if tags_result.tags:\n        return tags_result.tags[0]\n\n    # Create if not found\n    tag = Tag(name=name)\n    return await tag.save(client)\n</code></pre>"},{"location":"guide/getting-started/#pattern-batch-processing-with-progress","title":"Pattern: Batch Processing with Progress","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext, StashEntityStore\n\nasync def process_all_scenes():\n    async with StashContext(conn={...}) as client:\n        store = StashEntityStore(client)\n\n        processed = 0\n        async for scene in store.find_iter(Scene, organized=False):\n            await process_scene(scene)\n            processed += 1\n\n            if processed % 10 == 0:\n                print(f\"Processed {processed} scenes\")\n\n        print(f\"Total: {processed} scenes\")\n\nasyncio.run(process_all_scenes())\n</code></pre>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've completed the getting started guide, explore these topics:</p> <ul> <li>Usage Patterns - Common recipes and best practices</li> <li>UNSET Pattern Guide - Deep dive on partial updates</li> <li>Overview - Architecture and core concepts</li> <li>API Reference - Complete method documentation</li> </ul>"},{"location":"guide/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/getting-started/#connection-issues","title":"Connection Issues","text":"<p>Problem: <code>ConnectError: Cannot connect to server</code></p> <p>Solution: - Verify Stash is running - Check host and port in connection config - Try accessing Stash web interface manually</p>"},{"location":"guide/getting-started/#import-errors","title":"Import Errors","text":"<p>Problem: <code>ModuleNotFoundError: No module named 'stash_graphql_client'</code></p> <p>Solution: <pre><code>pip install stash-graphql-client\n# or\npoetry add stash-graphql-client\n</code></pre></p>"},{"location":"guide/getting-started/#type-errors","title":"Type Errors","text":"<p>Problem: IDE shows type errors for entity fields</p> <p>Solution: - Ensure Python 3.12+ is being used - Check that Pydantic v2 is installed - May need to restart IDE/language server</p>"},{"location":"guide/getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://jakan-kink.github.io/stash-graphql-client/</li> <li>GitHub Issues: https://github.com/Jakan-Kink/stash-graphql-client/issues</li> <li>Stash Community: https://discord.gg/stash</li> </ul>"},{"location":"guide/overview/","title":"Overview","text":""},{"location":"guide/overview/#why-this-library-exists","title":"Why This Library Exists","text":"<p>Interacting with GraphQL APIs typically requires:</p> <ul> <li>Manually constructing query and mutation strings - Error-prone string building with no compile-time validation</li> <li>Building complex nested filter objects - GraphQL filter syntax can be verbose and difficult to construct</li> <li>Tracking which fields have been fetched - No automatic way to know which fields are available vs which need to be queried</li> <li>Managing object identity across responses - The same entity ID may appear in different responses as different object instances, leading to stale data</li> <li>Implementing change tracking - No built-in way to avoid overwriting unmodified fields in mutations</li> </ul> <p>stash-graphql-client provides an ORM-like abstraction layer over Stash's GraphQL API, implementing patterns from:</p> <ul> <li>SQLAlchemy - Identity map pattern, session management, relationship tracking</li> <li>Django ORM - Filter syntax (<code>field__modifier</code>), model validation, query building</li> <li>Rails ActiveRecord - Entity-centric CRUD operations (<code>.save()</code>, <code>.delete()</code>), relationship helpers</li> </ul> <p>This allows developers to work with typed Python objects and high-level operations rather than raw GraphQL primitives.</p>"},{"location":"guide/overview/#core-architectural-patterns","title":"Core Architectural Patterns","text":""},{"location":"guide/overview/#identity-map-pattern","title":"Identity Map Pattern","text":"<p>Same entity ID always returns the same Python object reference across your entire application. This prevents stale data and eliminates the need for manual cache synchronization.</p> <pre><code>from stash_graphql_client import StashEntityStore\nfrom stash_graphql_client.types import Scene\n\nstore = StashEntityStore(client)\n\n# First query loads a scene\nscene1 = await store.get(Scene, \"123\")\n\n# Later query for same ID returns same object\nscene2 = await store.get(Scene, \"123\")\n\nassert scene1 is scene2  # True - same Python object!\n\n# Update in one place, visible everywhere\nscene1.title = \"Updated Title\"\nprint(scene2.title)  # \"Updated Title\" - same reference\n</code></pre> <p>Implementation: Uses Pydantic v2 wrap validators that check the cache before model construction. See Identity Map Architecture for details.</p>"},{"location":"guide/overview/#unset-sentinel-pattern","title":"UNSET Sentinel Pattern","text":"<p>Three-state field system distinguishes between:</p> <ol> <li>Value - Field has been set to an actual value</li> <li>None - Field has been explicitly set to null</li> <li>UNSET - Field has never been queried or touched</li> </ol> <p>This enables precise partial updates where only modified fields are sent in mutations.</p> <pre><code>from stash_graphql_client.types import Scene, UNSET\n\n# Load a scene\nscene = await client.find_scene(\"123\")\n\n# Three distinct states\nscene.title = \"New Title\"    # State 1: Set to value\nscene.rating100 = None       # State 2: Explicitly null\nscene.details = UNSET        # State 3: Never touched\n\n# Save sends only non-UNSET fields\nawait scene.save(client)\n# GraphQL mutation: { id: \"123\", title: \"New Title\", rating100: null }\n# Note: \"details\" field NOT included - server preserves existing value\n</code></pre> <p>Use cases:</p> <ul> <li>Partial queries - Load only needed fields, leave rest as UNSET</li> <li>Partial updates - Modify specific fields without affecting others</li> <li>Avoiding race conditions - Update one field without overwriting concurrent changes to other fields</li> <li>Sparse field selection - Match GraphQL's sparse field semantics in Python objects</li> </ul> <p>See UNSET Pattern Guide for comprehensive examples.</p>"},{"location":"guide/overview/#architecture","title":"Architecture","text":"<p>This library follows a three-layer architecture. For a detailed technical overview, see the Architecture Overview.</p> <p>Quick summary:</p> <ul> <li>Layer 1: StashClient - GraphQL transport layer with HTTP/WebSocket support</li> <li>Layer 2: Pydantic Types - Schema/ORM layer with validation and change tracking</li> <li>Layer 3: StashEntityStore - Identity map and caching layer</li> </ul>"},{"location":"guide/overview/#type-safety-with-pydantic-v2","title":"Type Safety with Pydantic v2","text":"<p>All GraphQL types are Pydantic <code>BaseModel</code> subclasses with full runtime validation:</p> <pre><code>from stash_graphql_client.types import Scene, Performer\nfrom pydantic import ValidationError\n\n# Field validation catches errors before GraphQL requests\ntry:\n    scene = Scene(rating100=150)  # Invalid: must be 0-100\nexcept ValidationError as e:\n    print(e.errors())\n    # [{'loc': ('rating100',), 'msg': 'Input should be less than or equal to 100'}]\n\n# Type coercion where appropriate\nscene = Scene(rating100=\"85\")  # str -&gt; int coercion\nassert scene.rating100 == 85\n\n# Nested model validation\nperformer = Performer(\n    name=\"Jane Doe\",\n    stash_ids=[{\"endpoint\": \"example.com\", \"stash_id\": \"123\"}]\n)\n# StashID objects validated recursively\n</code></pre> <p>Benefits:</p> <ul> <li>Catch errors at development time (not runtime)</li> <li>IDE autocomplete for all fields</li> <li>Runtime validation ensures data integrity</li> <li>Alias mapping handles GraphQL naming conventions (camelCase \u2194 snake_case)</li> </ul>"},{"location":"guide/overview/#relationship-metadata","title":"Relationship Metadata","text":"<p>Relationships are documented via <code>RelationshipMetadata</code> objects that specify:</p> <ul> <li>target_field - Field name in mutation input (e.g., <code>\"studio_id\"</code>)</li> <li>query_field - Field name in query response (e.g., <code>\"studio\"</code>)</li> <li>inverse_type - Related entity type name</li> <li>inverse_query_field - Inverse field name for bidirectional sync</li> <li>query_strategy - How to query the relationship (<code>\"direct_field\"</code>, <code>\"filter_query\"</code>, or <code>\"complex_object\"</code>)</li> </ul> <pre><code>from stash_graphql_client.types import Scene, Studio\n\n# Set a relationship\nscene.studio = studio_obj\n\n# Inverse relationship automatically updated\nassert scene in studio_obj.scenes  # True - bidirectional sync!\n\n# Helper methods\nawait scene.add_performer(performer)    # Updates both sides\nawait scene.remove_tag(tag)             # Syncs inverse\n</code></pre> <p>See Bidirectional Relationships for implementation details.</p>"},{"location":"guide/overview/#field-aware-population","title":"Field-Aware Population","text":"<p>Track which fields have been fetched and load missing fields on demand:</p> <pre><code>from stash_graphql_client import StashEntityStore\n\nstore = StashEntityStore(client)\n\n# Initial query fetches only specified fields\nperformer = await client.find_performer(\"123\")\nprint(performer._received_fields)  # {\"id\", \"name\", \"birthdate\"}\n\n# Check which fields are missing\nmissing = store.missing_fields(performer, \"scenes\", \"images\", \"tags\")\n# Returns: {\"scenes\", \"images\", \"tags\"}\n\n# Populate only missing fields\nawait store.populate(performer, fields=[\"scenes\", \"images\"])\nprint(performer._received_fields)  # {\"id\", \"name\", \"birthdate\", \"scenes\", \"images\"}\n</code></pre> <p>Benefits:</p> <ul> <li>Load expensive fields (large lists) only when needed</li> <li>Avoid re-fetching data already in memory</li> <li>Progressive data loading</li> <li>Optimize network usage for large result sets</li> </ul>"},{"location":"guide/overview/#when-to-use-each-layer","title":"When to Use Each Layer","text":""},{"location":"guide/overview/#use-stashclient-when","title":"Use StashClient when:","text":"<ul> <li>\u2705 Making one-off queries</li> <li>\u2705 Need direct control over GraphQL queries</li> <li>\u2705 Working with entity types that don't need caching</li> <li>\u2705 Executing mutations that return complex results</li> </ul>"},{"location":"guide/overview/#use-pydantic-types-when","title":"Use Pydantic Types when:","text":"<ul> <li>\u2705 Creating new entities with validation</li> <li>\u2705 Need ORM-like <code>.save()</code> / <code>.delete()</code> methods</li> <li>\u2705 Working with entity relationships</li> <li>\u2705 Need change tracking for partial updates</li> </ul>"},{"location":"guide/overview/#use-stashentitystore-when","title":"Use StashEntityStore when:","text":"<ul> <li>\u2705 Need object identity across queries</li> <li>\u2705 Making repeated queries for same entities</li> <li>\u2705 Using Django-style filtering</li> <li>\u2705 Need field-aware population</li> <li>\u2705 Processing large result sets with pagination</li> </ul>"},{"location":"guide/overview/#design-philosophy","title":"Design Philosophy","text":""},{"location":"guide/overview/#principle-1-explicit-over-implicit","title":"Principle 1: Explicit Over Implicit","text":"<p>Operations like <code>.save()</code> and <code>.delete()</code> require passing the client explicitly:</p> <pre><code>await scene.save(client)  # Explicit client reference\n</code></pre> <p>This makes it clear where network operations occur and avoids hidden global state.</p>"},{"location":"guide/overview/#principle-2-type-safety-by-default","title":"Principle 2: Type Safety by Default","text":"<p>All GraphQL types are Pydantic models with runtime validation. Field typos and type mismatches are caught immediately:</p> <pre><code>scene.ratting100 = 85  # \u274c IDE/mypy catches typo\nscene.rating100 = \"invalid\"  # \u274c Pydantic validation error\n</code></pre>"},{"location":"guide/overview/#principle-3-progressive-enhancement","title":"Principle 3: Progressive Enhancement","text":"<p>Start with simple client methods, add caching when needed, use advanced features as required:</p> <pre><code># Simple: Direct client usage\nscene = await client.find_scene(\"123\")\n\n# Enhanced: Add identity map\nstore = StashEntityStore(client)\nscene = await store.get(Scene, \"123\")\n\n# Advanced: Field-aware population + filtering\nawait store.populate(scene, fields=[\"performers\"])\ntop_rated = await store.find(Scene, rating100__gte=90)\n</code></pre>"},{"location":"guide/overview/#principle-4-match-graphql-semantics","title":"Principle 4: Match GraphQL Semantics","text":"<p>The UNSET pattern matches GraphQL's sparse field selection. Partial updates work exactly like GraphQL input objects:</p> <pre><code># Only include fields you want to update\nscene.title = \"New\"\nscene.details = UNSET  # GraphQL mutation won't include this field\n</code></pre>"},{"location":"guide/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide - Step-by-step tutorials</li> <li>Usage Patterns - Common recipes and best practices</li> <li>Identity Map Architecture - Implementation deep dive</li> <li>Library Comparisons - How this compares to alternatives</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guide/unset-pattern/","title":"UNSET Sentinel and UUID4 Auto-Generation Patterns","text":"<p>This document describes the architectural patterns for field tracking, dirty detection, and identity management in the StashObject base class.</p>"},{"location":"guide/unset-pattern/#overview","title":"Overview","text":"<p>Four critical architectural patterns are implemented in the <code>StashObject</code> base class:</p> <ol> <li>UUID4 Auto-Generation: New objects receive a temporary UUID4 identifier that is replaced with the server-assigned ID after save operations</li> <li>UNSET Sentinel Pattern: Three-level field system to distinguish between \"set to value\", \"set to null\", and \"never touched\"</li> <li>Field Tracking (_received_fields): Tracks which fields were actually loaded from GraphQL responses</li> <li>Dirty Tracking (_snapshot): Snapshot-based change detection for minimal update payloads</li> </ol> <p>These patterns work together to enable:</p> <ul> <li>Partial GraphQL fragments: Load only needed fields, track what was loaded</li> <li>Minimal mutations: Send only changed fields to server</li> <li>Null vs unset distinction: Explicitly set null vs never touched</li> <li>Identity management: Track new vs existing objects with UUID transition</li> </ul>"},{"location":"guide/unset-pattern/#uuid4-auto-generation-for-new-objects","title":"UUID4 Auto-Generation for New Objects","text":""},{"location":"guide/unset-pattern/#the-problem-before","title":"The Problem (Before)","text":"<p>Previously, new objects used the magic string <code>\"new\"</code> as a marker:</p> <pre><code># OLD PATTERN - DO NOT USE\nscene = Scene(id=\"new\", title=\"Test Scene\")\n</code></pre> <p>This had several issues:</p> <ul> <li>Not type-safe (any string could be an ID)</li> <li>Required explicit <code>id=\"new\"</code> in every new object creation</li> <li>Unclear intention (is \"new\" a valid ID or a marker?)</li> </ul>"},{"location":"guide/unset-pattern/#the-solution-after","title":"The Solution (After)","text":"<p>New objects automatically receive a UUID4 hex string (32 characters) when created without an ID:</p> <pre><code># NEW PATTERN - RECOMMENDED\nfrom stash_graphql_client.types import Scene\n\n# Create new object - UUID4 auto-generated\nscene = Scene(title=\"Test Scene\")\nprint(scene.id)  # \"a1b2c3d4e5f6789012345678901234ab\"\nprint(scene.is_new())  # True\n\n# After save, server assigns real ID\nawait scene.save(client)\nprint(scene.id)  # \"123\" (server-assigned)\nprint(scene.is_new())  # False\n</code></pre>"},{"location":"guide/unset-pattern/#uuid4-methods","title":"UUID4 Methods","text":""},{"location":"guide/unset-pattern/#is_new-bool","title":"<code>is_new() -&gt; bool</code>","text":"<p>Check if an object has a temporary UUID (not yet saved to server):</p> <pre><code>scene = Scene(title=\"Example\")\nscene.is_new()  # True - has UUID4\n\nscene.id = \"123\"  # Manually assign server ID\nscene.is_new()  # False - numeric ID from server\n</code></pre> <p>Detection Logic:</p> <ul> <li>Returns <code>True</code> if ID is 32 hex characters (UUID4) and not all digits</li> <li>Returns <code>True</code> if ID is the legacy <code>\"new\"</code> marker</li> <li>Returns <code>False</code> for numeric IDs (typical server IDs)</li> </ul>"},{"location":"guide/unset-pattern/#update_idserver_id-str-none","title":"<code>update_id(server_id: str) -&gt; None</code>","text":"<p>Replace temporary UUID with server-assigned ID:</p> <pre><code>scene = Scene(title=\"Example\")\nold_id = scene.id  # UUID4 hex string\n\n# Manually update after server returns ID\nscene.update_id(\"456\")\nprint(scene.id)  # \"456\"\n</code></pre> <p>Note: The <code>save()</code> method automatically calls <code>update_id()</code> after successful create operations.</p>"},{"location":"guide/unset-pattern/#auto-generation-behavior","title":"Auto-Generation Behavior","text":"<p>The UUID4 is generated in <code>StashObject.__init__()</code>:</p> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    # Auto-generate UUID4 for new objects without an ID\n    if \"id\" not in data or data.get(\"id\") is None:\n        data[\"id\"] = uuid.uuid4().hex\n        log.debug(\n            f\"Auto-generated UUID4 for new {self.__class__.__name__}: {data['id']}\"\n        )\n    super().__init__(**data)\n</code></pre> <p>When UUID4 is Generated:</p> <ul> <li>\u2705 No <code>id</code> parameter provided: <code>Scene(title=\"Test\")</code></li> <li>\u2705 <code>id=None</code> explicitly passed: <code>Scene(id=None, title=\"Test\")</code></li> <li>\u274c <code>id</code> with any string value: <code>Scene(id=\"123\", title=\"Test\")</code></li> </ul>"},{"location":"guide/unset-pattern/#unset-sentinel-pattern-three-level-field-system","title":"UNSET Sentinel Pattern (Three-Level Field System)","text":""},{"location":"guide/unset-pattern/#the-problem-before_1","title":"The Problem (Before)","text":"<p>Traditional two-level field systems only have:</p> <ol> <li>Set to a value: <code>field = \"value\"</code></li> <li>Set to null: <code>field = None</code></li> </ol> <p>This makes partial updates impossible without sending all fields:</p> <pre><code># TWO-LEVEL SYSTEM PROBLEM\nscene.title = \"Updated Title\"\nscene.rating100 = None  # Want to set to null\n# scene.details = ??? How to say \"don't touch this field\"?\n\n# to_input() has to include ALL fields to be safe\nawait scene.save(client)  # Overwrites details even though we didn't touch it!\n</code></pre>"},{"location":"guide/unset-pattern/#the-solution-after_1","title":"The Solution (After)","text":"<p>The UNSET sentinel provides a third state for \"never touched\":</p> <pre><code>from stash_graphql_client.types import Scene, UNSET\n\n# Three possible states for each field:\nscene.title = \"Updated Title\"  # 1. Set to value\nscene.rating100 = None          # 2. Set to null\nscene.details = UNSET           # 3. Never touched (don't include in input)\n\n# to_input() only includes fields that are NOT UNSET\ninput_dict = await scene.to_input()\n# {\"id\": \"123\", \"title\": \"Updated Title\", \"rating100\": null}\n# \"details\" is excluded because it's UNSET\n</code></pre>"},{"location":"guide/unset-pattern/#unset-sentinel-implementation","title":"UNSET Sentinel Implementation","text":"<p>The <code>UNSET</code> sentinel is a singleton instance defined in <code>types/unset.py</code>:</p> <pre><code>class UnsetType:\n    \"\"\"Sentinel value representing an unset field.\"\"\"\n\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __repr__(self) -&gt; str:\n        return \"UNSET\"\n\n    def __bool__(self) -&gt; bool:\n        return False  # UNSET is always falsy\n\n    def __eq__(self, other) -&gt; bool:\n        return isinstance(other, UnsetType)\n\n    def __hash__(self) -&gt; int:\n        return hash(\"UNSET\")\n\n# Singleton instance - use this throughout the codebase\nUNSET = UnsetType()\n</code></pre>"},{"location":"guide/unset-pattern/#field-definition-pattern","title":"Field Definition Pattern","text":"<p>Entity types should define fields with UNSET as the default:</p> <pre><code>from pydantic import BaseModel\nfrom stash_graphql_client.types.unset import UNSET, UnsetType\n\nclass Scene(StashObject):\n    \"\"\"Scene entity with UNSET sentinel support.\"\"\"\n\n    # Required in schema, but UNSET if not in GraphQL fragment\n    title: str | UnsetType = UNSET\n\n    # Optional in schema, can be null, value, or UNSET\n    rating100: int | None | UnsetType = UNSET\n    details: str | None | UnsetType = UNSET\n\n    # Required fields without defaults (always provided)\n    id: str\n</code></pre> <p>Type Annotation Pattern:</p> <ul> <li>For required fields: <code>field: Type | UnsetType = UNSET</code></li> <li>For optional fields: <code>field: Type | None | UnsetType = UNSET</code></li> <li>For always-required fields: <code>field: Type</code> (no default)</li> </ul>"},{"location":"guide/unset-pattern/#using-unset-in-to_input-methods","title":"Using UNSET in to_input() Methods","text":"<p>When converting to GraphQL input types, exclude UNSET fields:</p> <pre><code>async def to_input(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to GraphQL input, excluding UNSET fields.\"\"\"\n    input_dict = {}\n\n    # Only include fields that are NOT UNSET\n    if self.title is not UNSET:\n        input_dict[\"title\"] = self.title\n\n    if self.rating100 is not UNSET:\n        input_dict[\"rating100\"] = self.rating100  # Could be None or a value\n\n    if self.details is not UNSET:\n        input_dict[\"details\"] = self.details  # Could be None or a value\n\n    return input_dict\n</code></pre> <p>Note: The base <code>StashObject.to_input()</code> method handles this automatically when using Pydantic's <code>exclude_none=True</code>. For full UNSET support, entity types need custom serialization logic.</p>"},{"location":"guide/unset-pattern/#checking-for-unset","title":"Checking for UNSET","text":"<p>Use identity comparison (<code>is</code>) to check for UNSET:</p> <pre><code># \u2705 CORRECT - use identity comparison\nif scene.title is UNSET:\n    print(\"Title was never set\")\n\nif scene.title is not UNSET:\n    print(f\"Title is: {scene.title}\")  # Could be value or None\n\n# \u274c WRONG - don't use equality comparison\nif scene.title == UNSET:  # This works but 'is' is preferred for singletons\n    print(\"Title was never set\")\n\n# \u274c WRONG - don't use boolean check\nif not scene.title:  # This is True for UNSET, None, and empty string!\n    print(\"Ambiguous - could be UNSET, None, or empty\")\n</code></pre>"},{"location":"guide/unset-pattern/#field-tracking-with-_received_fields","title":"Field Tracking with _received_fields","text":""},{"location":"guide/unset-pattern/#the-problem","title":"The Problem","text":"<p>When loading partial GraphQL fragments, we need to know which fields were actually included in the response:</p> <pre><code># Partial fragment - only loaded id and title\nscene_data = {\"id\": \"123\", \"title\": \"Test Scene\"}\nscene = Scene.from_graphql(scene_data)\n\n# How do we know that rating100 wasn't loaded vs was loaded as null?\nprint(scene.rating100)  # UNSET or None?\n</code></pre>"},{"location":"guide/unset-pattern/#the-solution","title":"The Solution","text":"<p>The <code>_received_fields</code> attribute tracks which fields were actually present in the GraphQL response:</p> <pre><code>from stash_graphql_client.types import Scene\n\n# Load from GraphQL with partial data\nscene = Scene.from_graphql({\n    \"id\": \"123\",\n    \"title\": \"Test Scene\",\n    \"rating100\": None  # Explicitly null in response\n})\n\nprint(scene._received_fields)  # {\"id\", \"title\", \"rating100\"}\nprint(scene.title)  # \"Test Scene\"\nprint(scene.rating100)  # None (was in response)\nprint(scene.details)  # UNSET (not in response)\n</code></pre>"},{"location":"guide/unset-pattern/#how-_received_fields-works","title":"How _received_fields Works","text":"<ol> <li>Set during from_graphql(): When data comes from GraphQL, the <code>_identity_map_validator</code> tracks field names</li> <li>Merged on cache hits: If cached object receives new fields, they're merged into existing <code>_received_fields</code></li> <li>Empty for manual construction: Objects created with constructors have empty <code>_received_fields</code></li> </ol> <pre><code># From GraphQL - tracks received fields\nscene1 = Scene.from_graphql({\"id\": \"123\", \"title\": \"Test\"})\nprint(scene1._received_fields)  # {\"id\", \"title\"}\n\n# Direct construction - no tracking\nscene2 = Scene(id=\"456\", title=\"Test\")\nprint(scene2._received_fields)  # set() - empty\n</code></pre>"},{"location":"guide/unset-pattern/#use-cases-for-_received_fields","title":"Use Cases for _received_fields","text":"<p>1. Detecting partial loads:</p> <pre><code>if \"rating100\" not in scene._received_fields:\n    print(\"Rating was not loaded - fetch it if needed\")\n    await scene.populate(client, [\"rating100\"])\n</code></pre> <p>2. Merging partial fragments:</p> <pre><code># First query loads basic fields\nscene = await client.find_scene(\"123\")  # id, title\nprint(scene._received_fields)  # {\"id\", \"title\", ...}\n\n# Second query loads additional fields\ndetailed = await client.find_scene_with_files(\"123\")  # id, title, files\n# Identity map merges: same object, more fields\nprint(scene._received_fields)  # {\"id\", \"title\", \"files\", ...}\nassert scene is detailed  # Same cached object!\n</code></pre> <p>3. Debugging GraphQL queries:</p> <pre><code>def validate_fields(obj: StashObject, required: set[str]):\n    \"\"\"Ensure all required fields were loaded.\"\"\"\n    missing = required - obj._received_fields\n    if missing:\n        raise ValueError(f\"Missing required fields: {missing}\")\n</code></pre>"},{"location":"guide/unset-pattern/#dirty-tracking-with-_snapshot","title":"Dirty Tracking with _snapshot","text":""},{"location":"guide/unset-pattern/#the-problem_1","title":"The Problem","text":"<p>When updating existing objects, we only want to send changed fields to avoid overwriting server data:</p> <pre><code>scene = await client.find_scene(\"123\")\nscene.title = \"Updated Title\"  # Changed\nscene.rating100 = scene.rating100  # Not changed (same value)\n\n# How do we know which fields actually changed?\n# We need to compare current state to original state\n</code></pre>"},{"location":"guide/unset-pattern/#the-solution_1","title":"The Solution","text":"<p>The <code>_snapshot</code> attribute stores the original state after object construction. Dirty tracking methods compare current state to snapshot:</p> <pre><code>from stash_graphql_client.types import Scene\n\n# Load from server\nscene = await client.find_scene(\"123\")\n# _snapshot is automatically created with original values\n\nprint(scene.is_dirty())  # False - no changes yet\n\nscene.title = \"Updated Title\"\nprint(scene.is_dirty())  # True - title changed\n\ndirty_fields = scene.get_changed_fields()\nprint(dirty_fields)  # {\"title\": \"Updated Title\"}\n</code></pre>"},{"location":"guide/unset-pattern/#dirty-tracking-methods","title":"Dirty Tracking Methods","text":""},{"location":"guide/unset-pattern/#is_dirty-bool","title":"<code>is_dirty() -&gt; bool</code>","text":"<p>Check if object has unsaved changes:</p> <pre><code>scene = await client.find_scene(\"123\")\nprint(scene.is_dirty())  # False\n\nscene.title = \"New Title\"\nprint(scene.is_dirty())  # True\n\nawait scene.save(client)\nprint(scene.is_dirty())  # False - save() calls mark_clean()\n</code></pre>"},{"location":"guide/unset-pattern/#get_changed_fields-dictstr-any","title":"<code>get_changed_fields() -&gt; dict[str, Any]</code>","text":"<p>Get dictionary of changed fields and their current values:</p> <pre><code>scene.title = \"Updated Title\"\nscene.rating100 = 90\n\nchanged = scene.get_changed_fields()\nprint(changed)  # {\"title\": \"Updated Title\", \"rating100\": 90}\n</code></pre> <p>Note: Only fields in <code>__tracked_fields__</code> are included in change detection.</p>"},{"location":"guide/unset-pattern/#mark_clean-none","title":"<code>mark_clean() -&gt; None</code>","text":"<p>Mark object as clean (no unsaved changes). Updates snapshot to current state:</p> <pre><code>scene.title = \"Updated\"\nprint(scene.is_dirty())  # True\n\nscene.mark_clean()  # Update snapshot\nprint(scene.is_dirty())  # False\nprint(scene.get_changed_fields())  # {}\n</code></pre>"},{"location":"guide/unset-pattern/#mark_dirty-none","title":"<code>mark_dirty() -&gt; None</code>","text":"<p>Force object to be considered dirty by clearing the snapshot:</p> <pre><code>scene = await client.find_scene(\"123\")\nprint(scene.is_dirty())  # False\n\nscene.mark_dirty()  # Clear snapshot\nprint(scene.is_dirty())  # True\nprint(scene.get_changed_fields())  # All tracked fields\n</code></pre>"},{"location":"guide/unset-pattern/#how-_snapshot-works","title":"How _snapshot Works","text":"<ol> <li>Created in model_post_init(): After Pydantic initializes all fields, snapshot is taken</li> <li>Uses model_dump(): Leverages Pydantic's serialization for accurate state capture</li> <li>Updated on mark_clean(): Save operations call <code>mark_clean()</code> to update snapshot</li> <li>Compared by get_changed_fields(): Compares current <code>model_dump()</code> to <code>_snapshot</code></li> </ol> <pre><code>class StashObject(BaseModel):\n    def model_post_init(self, _context: Any) -&gt; None:\n        \"\"\"Called after Pydantic initialization.\"\"\"\n        # Capture initial state\n        self._snapshot = self.model_dump()\n\n    def is_dirty(self) -&gt; bool:\n        \"\"\"Compare current state to snapshot.\"\"\"\n        return self.model_dump() != self._snapshot\n\n    def get_changed_fields(self) -&gt; dict[str, Any]:\n        \"\"\"Find fields that differ from snapshot.\"\"\"\n        current = self.model_dump()\n        changed = {}\n        for field in self.__tracked_fields__:\n            if current.get(field) != self._snapshot.get(field):\n                changed[field] = current[field]\n        return changed\n</code></pre>"},{"location":"guide/unset-pattern/#how-to_input-uses-unset-_received_fields-and-_snapshot","title":"How to_input() Uses UNSET, _received_fields, and _snapshot","text":""},{"location":"guide/unset-pattern/#the-complete-flow","title":"The Complete Flow","text":"<p>The <code>to_input()</code> method combines all three tracking mechanisms to generate minimal GraphQL mutation inputs:</p> <pre><code>async def to_input(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to GraphQL input type.\n\n    For new objects: Uses _to_input_all() - all non-UNSET fields\n    For existing objects: Uses _to_input_dirty() - only changed fields\n    \"\"\"\n    input_obj = (\n        await self._to_input_all()   # New object path\n        if self.is_new()\n        else await self._to_input_dirty()  # Existing object path\n    )\n\n    return input_obj.model_dump(exclude_none=True)\n</code></pre>"},{"location":"guide/unset-pattern/#new-objects-_to_input_all","title":"New Objects: _to_input_all()","text":"<p>For new objects (UUID id, <code>_is_new=True</code>), include all fields that are not UNSET:</p> <pre><code>scene = Scene.new(\n    title=\"New Scene\",\n    rating100=85,\n    # details left as UNSET\n)\n\ninput_dict = await scene.to_input()\n# {\n#   \"title\": \"New Scene\",\n#   \"rating100\": 85\n#   # \"details\" excluded (UNSET)\n# }\n</code></pre> <p>Behavior:</p> <ul> <li>Processes all <code>__field_conversions__</code> fields</li> <li>Processes all <code>__relationships__</code> fields</li> <li>Excludes UNSET fields (never set)</li> <li>Includes None fields (explicitly set to null)</li> <li>Uses <code>__create_input_type__</code> for validation</li> </ul>"},{"location":"guide/unset-pattern/#existing-objects-_to_input_dirty","title":"Existing Objects: _to_input_dirty()","text":"<p>For existing objects, only include changed fields based on snapshot comparison:</p> <pre><code>scene = await client.find_scene(\"123\")\n# _snapshot = {\"id\": \"123\", \"title\": \"Original\", \"rating100\": 70, ...}\n\nscene.title = \"Updated Title\"  # Changed\n# scene.rating100 unchanged\n\ninput_dict = await scene.to_input()\n# {\n#   \"id\": \"123\",\n#   \"title\": \"Updated Title\"\n#   # rating100 NOT included (not dirty)\n# }\n</code></pre> <p>Behavior:</p> <ol> <li>Get changed fields: <code>dirty_fields = set(self.get_changed_fields().keys())</code></li> <li>Process only dirty fields from <code>__field_conversions__</code></li> <li>Process only dirty relationships from <code>__relationships__</code></li> <li>Always include ID (required for updates)</li> <li>Exclude UNSET fields (unchanged or never loaded)</li> <li>Include None fields if dirty (changed to null)</li> <li>Uses <code>__update_input_type__</code> for validation</li> </ol>"},{"location":"guide/unset-pattern/#example-all-three-systems-together","title":"Example: All Three Systems Together","text":"<pre><code># 1. Load from GraphQL (sets _received_fields and _snapshot)\nscene = Scene.from_graphql({\n    \"id\": \"123\",\n    \"title\": \"Original Title\",\n    \"rating100\": 70,\n    \"details\": None  # Explicitly null\n    # \"url\" not in fragment\n})\n\nprint(scene._received_fields)  # {\"id\", \"title\", \"rating100\", \"details\"}\nprint(scene._snapshot)  # {\"id\": \"123\", \"title\": \"Original Title\", ...}\nprint(scene.url)  # UNSET (not loaded)\nprint(scene.details)  # None (was null in response)\n\n# 2. Make changes\nscene.title = \"Updated Title\"  # Change tracked field\nscene.rating100 = None  # Change to null\nscene.url = UNSET  # Explicitly keep as UNSET (don't send)\n# scene.details unchanged (still None)\n\n# 3. Check dirty state\nprint(scene.is_dirty())  # True\nprint(scene.get_changed_fields())  # {\"title\": \"Updated Title\", \"rating100\": None}\n\n# 4. Generate minimal input (only dirty fields)\ninput_dict = await scene.to_input()\nprint(input_dict)\n# {\n#   \"id\": \"123\",\n#   \"title\": \"Updated Title\",  # Changed\n#   \"rating100\": None          # Changed to null - INCLUDED\n#   # details NOT included (unchanged)\n#   # url NOT included (UNSET)\n# }\n\n# 5. Save and mark clean\nawait scene.save(client)\nprint(scene.is_dirty())  # False\n</code></pre>"},{"location":"guide/unset-pattern/#decision-matrix-for-to_input","title":"Decision Matrix for to_input()","text":"Field State New Object Existing Object Sent to Server? Set to value \u2705 Included Only if dirty Yes Set to None \u2705 Included Only if dirty Yes (null) UNSET \u274c Excluded \u274c Excluded No Unchanged value \u2705 Included \u274c Excluded Depends Not in _received_fields N/A \u274c Excluded No <p>Key insight: UNSET exclusion happens at field processing level, dirty detection happens at change tracking level.</p>"},{"location":"guide/unset-pattern/#practical-examples","title":"Practical Examples","text":""},{"location":"guide/unset-pattern/#example-1-creating-a-new-scene","title":"Example 1: Creating a New Scene","text":"<pre><code>from stash_graphql_client import StashClient\nfrom stash_graphql_client.types import Scene, UNSET\n\n# Create new scene - UUID4 auto-generated\nscene = Scene(\n    title=\"My New Scene\",\n    rating100=85,\n    # details left as UNSET - will be excluded from create input\n)\n\nprint(scene.id)        # \"a1b2c3d4...\" (UUID4)\nprint(scene.is_new())  # True\nprint(scene.title)     # \"My New Scene\"\nprint(scene.details)   # UNSET\n\n# Save to server\nawait scene.save(client)\n\nprint(scene.id)        # \"123\" (server-assigned)\nprint(scene.is_new())  # False\n</code></pre>"},{"location":"guide/unset-pattern/#example-2-partial-update-only-changed-fields","title":"Example 2: Partial Update (Only Changed Fields)","text":"<pre><code># Fetch existing scene from server\nscene = await client.find_scene(\"123\")\n\nprint(scene.title)     # \"Original Title\"\nprint(scene.rating100) # 70\nprint(scene.details)   # \"Original details\"\n\n# Update only one field\nscene.title = \"Updated Title\"\n\n# to_input() only includes changed field + ID\ninput_dict = await scene.to_input()\n# {\"id\": \"123\", \"title\": \"Updated Title\"}\n# rating100 and details are NOT included (not dirty)\n\n# Save sends only the changed field\nawait scene.save(client)\n</code></pre>"},{"location":"guide/unset-pattern/#example-3-setting-field-to-null-vs-unsetting","title":"Example 3: Setting Field to Null vs Unsetting","text":"<pre><code>scene = await client.find_scene(\"123\")\n\n# Set field to null (explicit null in GraphQL)\nscene.rating100 = None\ninput_dict = await scene.to_input()\n# {\"id\": \"123\", \"rating100\": null}\n# Server will set rating100 to null\n\n# vs. leaving field UNSET (omit from GraphQL input)\nscene.details = UNSET\ninput_dict = await scene.to_input()\n# {\"id\": \"123\"}\n# Server keeps existing details value unchanged\n</code></pre>"},{"location":"guide/unset-pattern/#example-4-checking-field-state","title":"Example 4: Checking Field State","text":"<pre><code>scene = Scene(title=\"Test\")\n\n# Check the three states\nif scene.title is not UNSET:\n    if scene.title is None:\n        print(\"Title is explicitly null\")\n    else:\n        print(f\"Title is set to: {scene.title}\")\nelse:\n    print(\"Title was never touched\")\n\n# Using a helper function\ndef describe_field(field_value):\n    if field_value is UNSET:\n        return \"UNSET (never touched)\"\n    elif field_value is None:\n        return \"NULL (explicitly set to null)\"\n    else:\n        return f\"VALUE: {field_value}\"\n\nprint(describe_field(scene.title))     # \"VALUE: Test\"\nprint(describe_field(scene.rating100)) # \"UNSET (never touched)\"\n</code></pre>"},{"location":"guide/unset-pattern/#migration-guide-for-entity-types","title":"Migration Guide for Entity Types","text":"<p>When migrating entity types to use the UNSET pattern:</p>"},{"location":"guide/unset-pattern/#step-1-import-unset","title":"Step 1: Import UNSET","text":"<pre><code>from stash_graphql_client.types.unset import UNSET, UnsetType\n</code></pre>"},{"location":"guide/unset-pattern/#step-2-update-field-definitions","title":"Step 2: Update Field Definitions","text":"<p>Before:</p> <pre><code>class Scene(StashObject):\n    title: str | None = None\n    rating100: int | None = None\n</code></pre> <p>After:</p> <pre><code>class Scene(StashObject):\n    title: str | UnsetType = UNSET\n    rating100: int | None | UnsetType = UNSET\n</code></pre>"},{"location":"guide/unset-pattern/#step-3-update-to_input-method","title":"Step 3: Update to_input() Method","text":"<p>Add UNSET checks when converting to input:</p> <pre><code>async def to_input(self) -&gt; dict[str, Any]:\n    data = {\"id\": self.id}\n\n    # Only include non-UNSET fields\n    if self.title is not UNSET:\n        data[\"title\"] = self.title\n\n    if self.rating100 is not UNSET:\n        data[\"rating100\"] = self.rating100\n\n    return data\n</code></pre>"},{"location":"guide/unset-pattern/#step-4-update-tests","title":"Step 4: Update Tests","text":"<p>Test all three states:</p> <pre><code>def test_unset_field_not_in_input():\n    \"\"\"UNSET fields should be excluded from input.\"\"\"\n    scene = Scene(id=\"123\", title=\"Test\")\n    scene.rating100 = UNSET  # Explicitly UNSET\n\n    input_dict = await scene.to_input()\n\n    assert \"title\" in input_dict\n    assert \"rating100\" not in input_dict  # UNSET fields excluded\n\ndef test_null_field_in_input():\n    \"\"\"None fields should be included in input.\"\"\"\n    scene = Scene(id=\"123\", title=\"Test\")\n    scene.rating100 = None  # Explicitly null\n\n    input_dict = await scene.to_input()\n\n    assert \"title\" in input_dict\n    assert \"rating100\" in input_dict\n    assert input_dict[\"rating100\"] is None\n</code></pre>"},{"location":"guide/unset-pattern/#implementation-notes","title":"Implementation Notes","text":""},{"location":"guide/unset-pattern/#identity-map-compatibility","title":"Identity Map Compatibility","text":"<p>The UNSET pattern is compatible with the identity map (entity cache):</p> <pre><code># Cached objects preserve UNSET state\nscene1 = await store.get(Scene, \"123\")  # Fetched with partial fragment\nprint(scene1.details)  # UNSET (not in fragment)\n\n# Same object from cache\nscene2 = await store.get(Scene, \"123\")\nassert scene1 is scene2  # Same reference\nprint(scene2.details)  # Still UNSET\n\n# populate() can fetch missing fields\nawait store.populate(scene1, [\"details\"])\nprint(scene1.details)  # \"Details from server\" (no longer UNSET)\n</code></pre>"},{"location":"guide/unset-pattern/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>UUID4 generation: Minimal overhead (~0.1\u03bcs per object)</li> <li>UNSET checks: Identity comparison (<code>is</code>) is O(1)</li> <li>Memory: UNSET is a singleton, so only one instance exists in memory</li> </ul>"},{"location":"guide/unset-pattern/#type-checking-with-mypy","title":"Type Checking with mypy","text":"<p>The UNSET pattern is fully type-safe with mypy:</p> <pre><code>scene = Scene(title=\"Test\")\n\n# mypy knows title could be str or UnsetType\nif scene.title is not UNSET:\n    # In this block, mypy narrows type to just str\n    print(scene.title.upper())  # \u2705 OK - mypy knows it's str\n\n# mypy error if you don't check first\nprint(scene.title.upper())  # \u274c Error - UnsetType has no attribute 'upper'\n</code></pre>"},{"location":"guide/unset-pattern/#testing-patterns","title":"Testing Patterns","text":""},{"location":"guide/unset-pattern/#test-uuid4-generation","title":"Test UUID4 Generation","text":"<pre><code>def test_new_object_gets_uuid():\n    \"\"\"New objects should auto-generate UUID4.\"\"\"\n    scene = Scene(title=\"Test\")\n\n    assert scene.id is not None\n    assert len(scene.id) == 32  # UUID4 hex is 32 chars\n    assert scene.is_new() is True\n\ndef test_existing_object_no_uuid():\n    \"\"\"Objects with server IDs should not be marked as new.\"\"\"\n    scene = Scene(id=\"123\", title=\"Test\")\n\n    assert scene.id == \"123\"\n    assert scene.is_new() is False\n\ndef test_update_id_after_save(respx_mock, stash_client):\n    \"\"\"save() should update UUID with server ID.\"\"\"\n    scene = Scene(title=\"Test\")\n    original_id = scene.id  # UUID4\n\n    # Mock GraphQL response\n    respx.post(\"http://localhost:9999/graphql\").mock(\n        return_value=httpx.Response(\n            200, json={\"data\": {\"sceneCreate\": {\"id\": \"456\"}}}\n        )\n    )\n\n    await scene.save(stash_client)\n\n    assert scene.id == \"456\"\n    assert scene.id != original_id\n    assert scene.is_new() is False\n</code></pre>"},{"location":"guide/unset-pattern/#test-unset-pattern","title":"Test UNSET Pattern","text":"<pre><code>def test_unset_field_excluded():\n    \"\"\"UNSET fields should be excluded from to_input().\"\"\"\n    scene = Scene(id=\"123\", title=\"Test\")\n    scene.rating100 = UNSET\n\n    input_dict = await scene.to_input()\n\n    assert \"rating100\" not in input_dict\n\ndef test_null_field_included():\n    \"\"\"None fields should be included in to_input().\"\"\"\n    scene = Scene(id=\"123\", title=\"Test\")\n    scene.rating100 = None\n\n    input_dict = await scene.to_input()\n\n    assert \"rating100\" in input_dict\n    assert input_dict[\"rating100\"] is None\n\ndef test_value_field_included():\n    \"\"\"Value fields should be included in to_input().\"\"\"\n    scene = Scene(id=\"123\", title=\"Test\")\n    scene.rating100 = 85\n\n    input_dict = await scene.to_input()\n\n    assert \"rating100\" in input_dict\n    assert input_dict[\"rating100\"] == 85\n</code></pre>"},{"location":"guide/unset-pattern/#future-enhancements","title":"Future Enhancements","text":""},{"location":"guide/unset-pattern/#pydantic-v2-serialization","title":"Pydantic v2 Serialization","text":"<p>When fully migrated to Pydantic v2, we can use custom serializers:</p> <pre><code>from pydantic import field_serializer\n\nclass Scene(StashObject):\n    title: str | UnsetType = UNSET\n\n    @field_serializer(\"title\", when_used=\"json\")\n    def serialize_title(self, value):\n        if value is UNSET:\n            raise ValueError(\"UNSET should be excluded\")\n        return value\n</code></pre>"},{"location":"guide/unset-pattern/#msgspec-migration","title":"msgspec Migration","text":"<p>For msgspec migration, UNSET integrates with <code>dec_hook</code>:</p> <pre><code>import msgspec\n\ndef dec_hook(type, obj):\n    \"\"\"Custom decoder hook for msgspec.\"\"\"\n    if isinstance(obj, dict) and \"id\" in obj:\n        # Check cache, return cached instance or construct new\n        # UNSET is preserved for fields not in response\n        pass\n</code></pre>"},{"location":"guide/unset-pattern/#summary","title":"Summary","text":""},{"location":"guide/unset-pattern/#uuid4-auto-generation","title":"UUID4 Auto-Generation","text":"<ul> <li>\u2705 New objects get UUID4 automatically</li> <li>\u2705 <code>is_new()</code> checks if object has temporary ID</li> <li>\u2705 <code>update_id()</code> replaces UUID with server ID</li> <li>\u2705 <code>save()</code> handles ID updates automatically</li> <li>\u2705 <code>_is_new</code> attribute tracks new vs existing objects</li> </ul>"},{"location":"guide/unset-pattern/#unset-sentinel-pattern","title":"UNSET Sentinel Pattern","text":"<ul> <li>\u2705 Three-level field system: value, null, UNSET</li> <li>\u2705 Partial updates only send changed fields</li> <li>\u2705 Type-safe with mypy</li> <li>\u2705 Compatible with identity map caching</li> <li>\u2705 Minimal performance overhead</li> <li>\u2705 Distinguishes \"not set\" from \"set to null\"</li> </ul>"},{"location":"guide/unset-pattern/#field-tracking-with-_received_fields_1","title":"Field Tracking with _received_fields","text":"<ul> <li>\u2705 Tracks which fields came from GraphQL responses</li> <li>\u2705 Set automatically by <code>from_graphql()</code></li> <li>\u2705 Merged on identity map cache hits</li> <li>\u2705 Empty for manually constructed objects</li> <li>\u2705 Enables partial fragment detection</li> <li>\u2705 Supports progressive field loading</li> </ul>"},{"location":"guide/unset-pattern/#dirty-tracking-with-_snapshot_1","title":"Dirty Tracking with _snapshot","text":"<ul> <li>\u2705 Stores original state after construction</li> <li>\u2705 <code>is_dirty()</code> detects any unsaved changes</li> <li>\u2705 <code>get_changed_fields()</code> returns modified fields</li> <li>\u2705 <code>mark_clean()</code> updates snapshot after save</li> <li>\u2705 <code>mark_dirty()</code> forces dirty state</li> <li>\u2705 Enables minimal update payloads</li> </ul>"},{"location":"guide/unset-pattern/#to_input-integration","title":"to_input() Integration","text":"<ul> <li>\u2705 <code>_to_input_all()</code> for new objects (all non-UNSET fields)</li> <li>\u2705 <code>_to_input_dirty()</code> for existing objects (only changed fields)</li> <li>\u2705 Combines UNSET filtering with dirty detection</li> <li>\u2705 Always includes ID for updates</li> <li>\u2705 Respects both snapshot changes and UNSET exclusions</li> </ul>"},{"location":"guide/unset-pattern/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>is</code> for UNSET checks: <code>if field is UNSET:</code></li> <li>Set UNSET as default: <code>field: Type | UnsetType = UNSET</code></li> <li>Use from_graphql() for GraphQL data: Enables <code>_received_fields</code> tracking</li> <li>Check is_dirty() before save: Avoid unnecessary mutations</li> <li>Use get_changed_fields() for debugging: See exactly what changed</li> <li>Let UUID4 auto-generate: Don't manually set for new objects</li> <li>Test all three field states: value, None, UNSET</li> <li>Trust the snapshot: <code>mark_clean()</code> called automatically by <code>save()</code></li> </ol>"},{"location":"guide/unset-pattern/#see-also","title":"See Also","text":"<ul> <li>Quick Reference - One-page cheat sheet for UNSET &amp; UUID4 patterns</li> <li>Usage Examples - Practical examples with ID mapping and convenience methods</li> <li>Bidirectional Relationships - How entity relationships work</li> <li>StashEntityStore API - Identity map and caching documentation</li> </ul>"},{"location":"guide/usage-examples/","title":"Usage Examples","text":"<p>\u23fa Usage Examples for New Convenience Methods</p> <ol> <li>Entity ID Mapping - Simplified Workflows</li> </ol> <p>Before (without convenience methods):</p>"},{"location":"guide/usage-examples/#old-way-lots-of-boilerplate","title":"Old way - lots of boilerplate","text":"<p>async def create_scene_with_tags(client, scene_data): tag_ids = [] for tag_name in [\"Action\", \"Drama\", \"Thriller\"]: results = await client.find_tags( tag_filter={\"name\": {\"value\": tag_name, \"modifier\": \"EQUALS\"}} ) if results.count &gt; 0: tag_ids.append(results.tags[0].id) else: # Create missing tag new_tag = await client.create_tag(Tag(name=tag_name)) tag_ids.append(new_tag.id)</p> <pre><code>  scene = Scene(title=\"My Scene\", tag_ids=tag_ids)\n  return await client.create_scene(scene)\n</code></pre> <p>After (with map_tag_ids()):</p>"},{"location":"guide/usage-examples/#new-way-clean-and-simple","title":"New way - clean and simple","text":"<p>async def create_scene_with_tags(client, scene_data): tag_ids = await client.map_tag_ids( [\"Action\", \"Drama\", \"Thriller\"], create=True # Auto-create missing tags )</p> <pre><code>  scene = Scene(title=\"My Scene\", tag_ids=tag_ids)\n  return await client.create_scene(scene)\n</code></pre> <ol> <li>Studio Hierarchy Navigation</li> </ol> <p>Finding Root Studios:</p>"},{"location":"guide/usage-examples/#scenario-you-have-a-child-studio-and-want-to-find-the-root-parent","title":"Scenario: You have a child studio and want to find the root parent","text":"<p>studio_id = \"child-studio-123\"</p>"},{"location":"guide/usage-examples/#get-the-full-hierarchy-root-to-child","title":"Get the full hierarchy (root to child)","text":"<p>hierarchy = await client.find_studio_hierarchy(studio_id)</p>"},{"location":"guide/usage-examples/#returns","title":"Returns: [, , ] <p>print(f\"Root: {hierarchy[0].name}\") print(f\"Direct parent: {hierarchy[-2].name}\") print(f\"Current: {hierarchy[-1].name}\")</p>","text":""},{"location":"guide/usage-examples/#or-just-get-the-root-directly","title":"Or just get the root directly <p>root = await client.find_studio_root(studio_id) print(f\"Root studio: {root.name}\")</p> <p>Practical Use Case - Organizing by Root Studio:</p>","text":""},{"location":"guide/usage-examples/#group-all-scenes-by-their-root-studio","title":"Group all scenes by their root studio <p>async def group_scenes_by_root_studio(client, scene_ids): root_groups = {}</p> <pre><code>  for scene_id in scene_ids:\n      scene = await client.find_scene(scene_id)\n      if scene.studio:\n          root = await client.find_studio_root(scene.studio.id)\n          root_name = root.name if root else \"Unknown\"\n\n          if root_name not in root_groups:\n              root_groups[root_name] = []\n          root_groups[root_name].append(scene)\n\n  return root_groups\n</code></pre>  <ol> <li>Performer Mapping with Alias Support</li> </ol> <p>Basic Performer Mapping:</p>","text":""},{"location":"guide/usage-examples/#map-performer-names-to-ids-includes-alias-search","title":"Map performer names to IDs (includes alias search) <p>performer_ids = await client.map_performer_ids( [\"Jane Doe\", \"John Smith\", \"AliasName\"], create=True )</p>","text":""},{"location":"guide/usage-examples/#use-in-scene-creation","title":"Use in scene creation <p>scene = Scene( title=\"Scene Title\", performer_ids=performer_ids ) await client.create_scene(scene)</p> <p>Handling Multiple Matches:</p> <p>from stash_graphql_client.types import OnMultipleMatch</p>","text":""},{"location":"guide/usage-examples/#skip-ambiguous-matches","title":"Skip ambiguous matches <p>performer_ids = await client.map_performer_ids( [\"Common Name\"], # Might match multiple performers on_multiple=OnMultipleMatch.RETURN_NONE # Skip if ambiguous )</p>","text":""},{"location":"guide/usage-examples/#or-return-first-match-with-warning","title":"Or return first match with warning <p>performer_ids = await client.map_performer_ids( [\"Common Name\"], on_multiple=OnMultipleMatch.RETURN_FIRST # Use first match (default) )</p>  <ol> <li>Batch Scene Creation with Mixed Entity Types</li> </ol> <p>Complex Real-World Example:</p> <p>async def create_scene_from_metadata(client, metadata): \"\"\"Create a scene from scraped metadata with automatic entity resolution.\"\"\"</p> <pre><code>  # Map all entity names to IDs in parallel\n  tag_ids = await client.map_tag_ids(\n      metadata.get(\"tags\", []),\n      create=True\n  )\n\n  performer_ids = await client.map_performer_ids(\n      metadata.get(\"performers\", []),\n      create=True,\n      on_multiple=OnMultipleMatch.RETURN_FIRST\n  )\n\n  studio_ids = await client.map_studio_ids(\n      [metadata.get(\"studio\")],\n      create=True\n  )\n\n  # Create scene with all relationships resolved\n  scene = Scene(\n      title=metadata[\"title\"],\n      details=metadata.get(\"details\"),\n      date=metadata.get(\"date\"),\n      tag_ids=tag_ids,\n      performer_ids=performer_ids,\n      studio_id=studio_ids[0] if studio_ids else None\n  )\n\n  return await client.create_scene(scene)\n</code></pre>  <ol> <li>Studio Hierarchy Analysis</li> </ol> <p>Find All Root Studios:</p> <p>async def find_all_root_studios(client): \"\"\"Find all root studios in the database.\"\"\" all_studios = await client.find_studios() root_studios = []</p> <pre><code>  for studio in all_studios.studios:\n      hierarchy = await client.find_studio_hierarchy(studio.id)\n      root = hierarchy[0] if hierarchy else None\n      if root and root.id == studio.id:  # This studio is a root\n          root_studios.append(studio)\n\n  return root_studios\n</code></pre> <p>Build Studio Tree:</p> <p>async def get_studio_tree_depth(client, studio_id): \"\"\"Get the depth of a studio in the hierarchy.\"\"\" hierarchy = await client.find_studio_hierarchy(studio_id) return len(hierarchy) - 1 # 0 = root, 1 = child, 2 = grandchild, etc.</p>","text":""},{"location":"guide/usage-examples/#example-usage","title":"Example usage <p>depth = await get_studio_tree_depth(client, \"studio-123\") print(f\"Studio is {depth} levels deep in the hierarchy\")</p>  <ol> <li>Bulk Operations with Auto-Creation</li> </ol> <p>Importing from External Source:</p> <p>async def import_scenes_from_csv(client, csv_data): \"\"\"Import scenes from CSV with automatic entity creation.\"\"\" created_scenes = []</p> <pre><code>  for row in csv_data:\n      # Parse CSV row\n      tag_names = row[\"tags\"].split(\",\")\n      performer_names = row[\"performers\"].split(\",\")\n      studio_name = row[\"studio\"]\n\n      # Map everything with auto-creation\n      tag_ids = await client.map_tag_ids(tag_names, create=True)\n      performer_ids = await client.map_performer_ids(performer_names, create=True)\n      studio_ids = await client.map_studio_ids([studio_name], create=True)\n\n      # Create scene\n      scene = Scene(\n          title=row[\"title\"],\n          tag_ids=tag_ids,\n          performer_ids=performer_ids,\n          studio_id=studio_ids[0] if studio_ids else None\n      )\n\n      created_scene = await client.create_scene(scene)\n      created_scenes.append(created_scene)\n\n  return created_scenes\n</code></pre>","text":""},{"location":"guide/usage-examples/#see-also","title":"See Also","text":"<ul> <li>UNSET &amp; UUID4 Guide - Core patterns for field management and new objects</li> <li>Quick Reference - Cheat sheet for common patterns</li> <li>Bidirectional Relationships - Entity relationship architecture</li> <li>Fuzzy Dates Guide - Working with partial date formats (v0.30.0+)</li> <li>StashEntityStore API - Identity map documentation</li> </ul>"},{"location":"guide/usage-patterns/","title":"Common Usage Patterns","text":"<p>This guide shows common patterns for working with stash-graphql-client. These patterns are designed to be clear for both human developers and LLM agents reading the documentation.</p>"},{"location":"guide/usage-patterns/#pattern-1-basic-crud-operations","title":"Pattern 1: Basic CRUD Operations","text":""},{"location":"guide/usage-patterns/#creating-entities","title":"Creating Entities","text":"<pre><code>from stash_graphql_client import StashContext\nfrom stash_graphql_client.types import Scene, Performer, Tag\n\nasync with StashContext(conn={\"Host\": \"localhost\", \"Port\": 9999}) as client:\n    # Create a new scene\n    scene = Scene(title=\"My Scene\", rating100=85)\n    await scene.save(client)\n    print(f\"Created scene with ID: {scene.id}\")\n\n    # Create a performer\n    performer = Performer(\n        name=\"Jane Doe\",\n        birthdate=\"1990-05-15\",\n        gender=\"FEMALE\"\n    )\n    await performer.save(client)\n\n    # Create a tag\n    tag = Tag(name=\"Action\", description=\"Action scenes\")\n    await tag.save(client)\n</code></pre> <p>Key points:</p> <ul> <li>New entities get automatic UUID4 IDs (32-char hex strings)</li> <li><code>.save(client)</code> executes the appropriate GraphQL mutation</li> <li>Server-assigned ID replaces the UUID4 after save</li> <li>Use <code>entity.is_new()</code> to check if entity has been saved</li> </ul>"},{"location":"guide/usage-patterns/#readingquerying-entities","title":"Reading/Querying Entities","text":"<pre><code>from stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    # Find by ID\n    scene = await client.find_scene(\"123\")\n    performer = await client.find_performer(\"456\")\n\n    # Find with filters\n    scenes_result = await client.find_scenes(\n        scene_filter={\"rating100\": {\"value\": 80, \"modifier\": \"GREATER_THAN\"}}\n    )\n    print(f\"Found {scenes_result.count} scenes\")\n    for scene in scenes_result.scenes:\n        print(f\"  {scene.title}: {scene.rating100}\")\n\n    # Find all (with pagination)\n    studios_result = await client.find_studios()\n    for studio in studios_result.studios:\n        print(studio.name)\n</code></pre> <p>Key points:</p> <ul> <li><code>find_X(id)</code> methods return single entity or None</li> <li><code>find_Xs(filter)</code> methods return result objects with count and items</li> <li>Result objects have entity-specific list names (e.g., <code>scenes</code>, <code>performers</code>)</li> <li>Pagination handled via <code>page</code> and <code>per_page</code> parameters</li> </ul>"},{"location":"guide/usage-patterns/#updating-entities","title":"Updating Entities","text":"<pre><code>from stash_graphql_client.types import UNSET\n\nasync with StashContext(conn={...}) as client:\n    # Load entity\n    scene = await client.find_scene(\"123\")\n\n    # Modify fields\n    scene.title = \"Updated Title\"\n    scene.rating100 = 90\n    scene.details = UNSET  # Don't touch this field\n\n    # Save only sends changed fields\n    await scene.save(client)\n\n    # Check what changed\n    changed = scene.get_changed_fields()\n    print(f\"Changed fields: {changed}\")\n</code></pre> <p>Key points:</p> <ul> <li>Only modified fields are sent in update mutations</li> <li>Use <code>UNSET</code> to explicitly not modify a field</li> <li><code>get_changed_fields()</code> shows what will be sent</li> <li>Entity <code>.save()</code> automatically chooses create vs update mutation</li> </ul>"},{"location":"guide/usage-patterns/#deleting-entities","title":"Deleting Entities","text":"<pre><code>async with StashContext(conn={...}) as client:\n    scene = await client.find_scene(\"123\")\n\n    # Delete entity\n    await scene.delete(client)\n\n    # Or use client method directly\n    await client.destroy_scene(\"456\")\n</code></pre> <p>Key points:</p> <ul> <li><code>.delete(client)</code> method available on all entity types</li> <li>Client also has <code>destroy_X(id)</code> methods</li> <li>Deletion is permanent - no undo</li> </ul>"},{"location":"guide/usage-patterns/#pattern-2-working-with-relationships","title":"Pattern 2: Working with Relationships","text":""},{"location":"guide/usage-patterns/#setting-single-relationships-many-to-one","title":"Setting Single Relationships (Many-to-One)","text":"<pre><code>from stash_graphql_client.types import Scene, Studio, is_set\n\nasync with StashContext(conn={...}) as client:\n    scene = await client.find_scene(\"123\")\n    studio = await client.find_studio(\"456\")\n\n    # Set the relationship\n    scene.studio = studio\n\n    # Save to persist\n    await scene.save(client)\n\n    # Inverse relationship automatically updated\n    if is_set(studio.scenes):\n        assert scene in studio.scenes  # True!\n</code></pre> <p>Key points:</p> <ul> <li>Set relationship by assigning entity object</li> <li>Bidirectional sync happens automatically</li> <li>Save the entity to persist the relationship</li> <li>Inverse field only synced if it was loaded</li> </ul>"},{"location":"guide/usage-patterns/#setting-many-to-many-relationships","title":"Setting Many-to-Many Relationships","text":"<pre><code>from stash_graphql_client.types import Scene, Performer, Tag\n\nasync with StashContext(conn={...}) as client:\n    scene = await client.find_scene(\"123\")\n\n    # Load related entities\n    performer1 = await client.find_performer(\"p1\")\n    performer2 = await client.find_performer(\"p2\")\n\n    # Set entire list\n    scene.performers = [performer1, performer2]\n    await scene.save(client)\n\n    # Or use helper methods\n    performer3 = await client.find_performer(\"p3\")\n    await scene.add_performer(performer3)  # Adds to list\n\n    # Remove from list\n    await scene.remove_performer(performer1)\n</code></pre> <p>Key points:</p> <ul> <li>Many-to-many relationships are lists</li> <li>Can assign entire list or use <code>add_X()</code> / <code>remove_X()</code> helpers</li> <li>Helper methods automatically sync inverse relationships</li> <li>Changes persist only after <code>.save(client)</code></li> </ul>"},{"location":"guide/usage-patterns/#querying-related-entities","title":"Querying Related Entities","text":"<pre><code>from stash_graphql_client.types import is_set\n\nasync with StashContext(conn={...}) as client:\n    # Get scene with related entities loaded\n    scene = await client.find_scene(\"123\")\n\n    # Access related entities\n    if is_set(scene.studio):\n        print(f\"Studio: {scene.studio.name}\")\n\n    if is_set(scene.performers):\n        for performer in scene.performers:\n            print(f\"Performer: {performer.name}\")\n\n    # Note: Related entities use same identity map\n    if is_set(scene.studio):\n        studio = await client.find_studio(scene.studio.id)\n        assert studio is scene.studio  # Same object reference!\n</code></pre> <p>Key points:</p> <ul> <li>Always check for UNSET before accessing relationships using <code>is_set()</code></li> <li>Related entities automatically cached in identity map</li> <li>Same entity ID = same object reference everywhere</li> </ul>"},{"location":"guide/usage-patterns/#pattern-3-using-the-entity-store","title":"Pattern 3: Using the Entity Store","text":""},{"location":"guide/usage-patterns/#basic-store-operations","title":"Basic Store Operations","text":"<pre><code>from stash_graphql_client import StashContext, StashEntityStore\nfrom stash_graphql_client.types import Scene, Performer\n\nasync with StashContext(conn={...}) as client:\n    store = StashEntityStore(client, ttl_seconds=300)\n\n    # Read-through caching (fetches if not cached)\n    scene = await store.get(Scene, \"123\")\n\n    # Get without fetch (returns None if not cached)\n    cached_scene = store.get_cached(Scene, \"123\")\n\n    # Save entity through store\n    scene.title = \"Updated\"\n    await store.save(scene)\n\n    # Delete through store\n    await store.delete(scene)\n</code></pre> <p>Key points:</p> <ul> <li><code>get()</code> fetches from server if not in cache</li> <li><code>get_cached()</code> only checks cache, never queries</li> <li>Store methods wrap client methods with caching</li> <li>TTL optional (None = never expire)</li> </ul>"},{"location":"guide/usage-patterns/#django-style-filtering","title":"Django-Style Filtering","text":"<pre><code>from stash_graphql_client import StashEntityStore\nfrom stash_graphql_client.types import Scene, Performer\n\nstore = StashEntityStore(client)\n\n# Comparison operators\ntop_rated = await store.find(Scene, rating100__gte=80)\nlow_rated = await store.find(Scene, rating100__lt=50)\n\n# Null checks\nunrated = await store.find(Scene, rating100__null=True)\nrated = await store.find(Scene, rating100__null=False)\n\n# String matching\nsearch = await store.find(Performer, name__contains=\"Jane\")\nexact = await store.find(Performer, name__exact=\"Jane Doe\")\n\n# Range queries\ndate_range = await store.find(Scene, date__between=(\"2024-01-01\", \"2024-12-31\"))\n\n# Combine multiple filters\nresults = await store.find(\n    Scene,\n    rating100__gte=80,\n    organized=True,\n    title__contains=\"test\"\n)\n</code></pre> <p>Supported modifiers:</p> <ul> <li><code>__exact</code> - Exact match</li> <li><code>__contains</code> - String contains</li> <li><code>__regex</code> - Regular expression match</li> <li><code>__gte</code>, <code>__gt</code> - Greater than (or equal)</li> <li><code>__lte</code>, <code>__lt</code> - Less than (or equal)</li> <li><code>__between</code> - Range (tuple of min/max)</li> <li><code>__null</code> - Null check (boolean)</li> <li><code>__in</code> - List membership</li> </ul>"},{"location":"guide/usage-patterns/#field-aware-population","title":"Field-Aware Population","text":"<pre><code>from stash_graphql_client import StashEntityStore\nfrom stash_graphql_client.types import Performer\n\nstore = StashEntityStore(client)\n\n# Initial query fetches basic fields\nperformer = await client.find_performer(\"123\")\nprint(performer._received_fields)  # {\"id\", \"name\", \"birthdate\"}\n\n# Check what's missing\nmissing = store.missing_fields(performer, \"scenes\", \"images\", \"tags\")\nprint(f\"Missing fields: {missing}\")  # {\"scenes\", \"images\", \"tags\"}\n\n# Populate only missing fields\nawait store.populate(performer, fields=[\"scenes\", \"images\"])\nprint(performer._received_fields)  # {\"id\", \"name\", \"birthdate\", \"scenes\", \"images\"}\n\n# Force refetch (invalidate cache)\nawait store.populate(performer, fields=[\"name\"], force_refetch=True)\n</code></pre> <p>Key points:</p> <ul> <li><code>_received_fields</code> tracks which fields were loaded</li> <li><code>missing_fields()</code> returns set of fields not yet loaded</li> <li><code>populate()</code> fetches only missing fields</li> <li>Use <code>force_refetch=True</code> to invalidate cache and reload</li> </ul>"},{"location":"guide/usage-patterns/#lazy-iteration-for-large-result-sets","title":"Lazy Iteration for Large Result Sets","text":"<pre><code>from stash_graphql_client import StashEntityStore\nfrom stash_graphql_client.types import Scene\n\nstore = StashEntityStore(client)\n\n# Lazy iteration - fetches pages on demand\nasync for scene in store.find_iter(Scene, organized=False, query_batch=50):\n    await organize_scene(scene)\n\n    # Can break early - remaining pages never fetched\n    if done_condition:\n        break\n\n# Compare to find() which loads all results\nall_scenes = await store.find(Scene, organized=False)  # Loads everything!\n</code></pre> <p>Key points:</p> <ul> <li><code>find_iter()</code> yields items one at a time</li> <li>Pages fetched on demand (not all upfront)</li> <li>Can break early to save network requests</li> <li><code>query_batch</code> controls page size (default 40)</li> </ul>"},{"location":"guide/usage-patterns/#pattern-4-advanced-queries","title":"Pattern 4: Advanced Queries","text":""},{"location":"guide/usage-patterns/#using-raw-graphql-filters","title":"Using Raw GraphQL Filters","text":"<pre><code>async with StashContext(conn={...}) as client:\n    # Complex filter with nested conditions\n    scenes = await client.find_scenes(\n        scene_filter={\n            \"performers\": {\n                \"value\": [\"performer-id-1\", \"performer-id-2\"],\n                \"modifier\": \"INCLUDES_ALL\"  # Must have ALL performers\n            },\n            \"rating100\": {\n                \"value\": 80,\n                \"modifier\": \"GREATER_THAN\"\n            },\n            \"tags\": {\n                \"value\": [\"tag-id-1\"],\n                \"modifier\": \"INCLUDES\"  # Has at least one tag\n            }\n        }\n    )\n</code></pre> <p>Key points:</p> <ul> <li>Raw filters give full control over GraphQL query</li> <li>Use when Django-style syntax is insufficient</li> <li>Filter structure matches Stash's GraphQL schema</li> <li>See API reference for available modifiers</li> </ul>"},{"location":"guide/usage-patterns/#pagination","title":"Pagination","text":"<pre><code>async with StashContext(conn={...}) as client:\n    page = 1\n    per_page = 100\n\n    while True:\n        result = await client.find_scenes(\n            scene_filter={...},\n            page=page,\n            per_page=per_page\n        )\n\n        print(f\"Processing page {page}: {len(result.scenes)} scenes\")\n\n        for scene in result.scenes:\n            await process_scene(scene)\n\n        # Stop if we got fewer results than requested\n        if len(result.scenes) &lt; per_page:\n            break\n\n        page += 1\n</code></pre> <p>Key points:</p> <ul> <li><code>page</code> is 1-indexed (first page = 1)</li> <li><code>per_page</code> defaults to 40 (max typically 1000)</li> <li>Check <code>len(result.items) &lt; per_page</code> to detect last page</li> <li>Result object includes <code>.count</code> for total items</li> </ul>"},{"location":"guide/usage-patterns/#pattern-5-bulk-operations","title":"Pattern 5: Bulk Operations","text":""},{"location":"guide/usage-patterns/#concurrent-fetches","title":"Concurrent Fetches","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    # Fetch multiple entities concurrently\n    scenes, performers, studios = await asyncio.gather(\n        client.find_scenes(),\n        client.find_performers(),\n        client.find_studios(),\n    )\n\n    # Process results\n    print(f\"Found {scenes.count} scenes\")\n    print(f\"Found {performers.count} performers\")\n    print(f\"Found {studios.count} studios\")\n</code></pre>"},{"location":"guide/usage-patterns/#concurrent-updates","title":"Concurrent Updates","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    # Load scenes\n    scenes = await client.find_scenes(\n        scene_filter={\"organized\": {\"value\": False, \"modifier\": \"EQUALS\"}}\n    )\n\n    # Update all concurrently\n    for scene in scenes.scenes[:10]:  # First 10\n        scene.organized = True\n\n    await asyncio.gather(*[\n        scene.save(client) for scene in scenes.scenes[:10]\n    ])\n</code></pre> <p>Key points:</p> <ul> <li>Use <code>asyncio.gather()</code> for concurrent operations</li> <li>Be mindful of rate limits (don't send 1000 concurrent requests)</li> <li>Consider batching (process 10-50 at a time)</li> </ul>"},{"location":"guide/usage-patterns/#batch-processing-with-progress-tracking","title":"Batch Processing with Progress Tracking","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext, StashEntityStore\nfrom stash_graphql_client.types import Scene\n\nasync with StashContext(conn={...}) as client:\n    store = StashEntityStore(client)\n\n    # Process in batches\n    batch_size = 25\n    processed = 0\n\n    async for scene in store.find_iter(Scene, organized=False):\n        await process_scene(scene)\n        processed += 1\n\n        # Progress update every batch\n        if processed % batch_size == 0:\n            print(f\"Processed {processed} scenes\")\n\n    print(f\"Total processed: {processed}\")\n</code></pre>"},{"location":"guide/usage-patterns/#pattern-6-job-management","title":"Pattern 6: Job Management","text":""},{"location":"guide/usage-patterns/#starting-and-monitoring-jobs","title":"Starting and Monitoring Jobs","text":"<pre><code>from stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    # Start a metadata scan job\n    job_id = await client.metadata_scan(\n        paths=[\"/media/videos\"],\n        options={\n            \"scanGeneratePreviews\": False,\n            \"scanGenerateImagePreviews\": False,\n            \"scanGenerateSprites\": False,\n        }\n    )\n\n    print(f\"Started job {job_id}\")\n\n    # Wait for completion (blocking)\n    result = await client.wait_for_job(job_id, timeout=300)  # 5 min timeout\n    print(f\"Job finished with status: {result.status}\")\n</code></pre>"},{"location":"guide/usage-patterns/#polling-job-status","title":"Polling Job Status","text":"<pre><code>import asyncio\nfrom stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    job_id = await client.metadata_scan(paths=[\"/media\"])\n\n    # Poll until complete\n    while True:\n        job = await client.find_job(job_id)\n\n        if job is None:\n            print(\"Job not found\")\n            break\n\n        print(f\"Status: {job.status}, Progress: {job.progress}%\")\n\n        if job.status in [\"FINISHED\", \"FAILED\", \"CANCELLED\"]:\n            break\n\n        await asyncio.sleep(5)  # Check every 5 seconds\n</code></pre>"},{"location":"guide/usage-patterns/#using-subscriptions-for-real-time-updates","title":"Using Subscriptions for Real-Time Updates","text":"<pre><code>from stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    # Subscribe to job updates\n    async for update in client.subscribe_job_updates():\n        job = update.job\n        print(f\"Job {job.id}: {job.status} - {job.progress}%\")\n\n        if job.status == \"FINISHED\":\n            print(f\"Job {job.id} completed!\")\n            break\n</code></pre> <p>Key points:</p> <ul> <li><code>metadata_scan()</code>, <code>metadata_generate()</code> return job IDs</li> <li><code>wait_for_job()</code> blocks until completion (with timeout)</li> <li>Manual polling gives more control over progress updates</li> <li>Subscriptions provide real-time updates via WebSocket</li> </ul>"},{"location":"guide/usage-patterns/#pattern-7-id-mapping-and-utilities","title":"Pattern 7: ID Mapping and Utilities","text":""},{"location":"guide/usage-patterns/#converting-names-to-ids-with-auto-create","title":"Converting Names to IDs (with Auto-Create)","text":"<pre><code>from stash_graphql_client import StashContext\nfrom stash_graphql_client.types import Performer\n\nasync with StashContext(conn={...}) as client:\n    # Convert performer names to IDs, creating if they don't exist\n    performer_names = [\"Jane Doe\", \"John Smith\", \"Alice Wonder\"]\n    performer_ids = await client.map_performer_ids(performer_names, create=True)\n\n    print(f\"Mapped {len(performer_names)} names to {len(performer_ids)} IDs\")\n\n    # Use IDs in scene update\n    scene = await client.find_scene(\"123\")\n    scene.performer_ids = performer_ids\n    await scene.save(client)\n</code></pre> <p>Available mapping methods:</p> <ul> <li><code>map_performer_ids(items, create=False)</code></li> <li><code>map_studio_ids(items, create=False)</code></li> <li><code>map_tag_ids(items, create=False)</code></li> </ul> <p>Key points:</p> <ul> <li>Pass list of strings (names) or entity objects</li> <li><code>create=True</code> creates missing entities</li> <li>Returns list of IDs in same order as input</li> <li>Mixed types supported (strings and objects)</li> </ul>"},{"location":"guide/usage-patterns/#studio-hierarchy-navigation","title":"Studio Hierarchy Navigation","text":"<pre><code>from stash_graphql_client import StashContext\n\nasync with StashContext(conn={...}) as client:\n    # Get full parent chain from root to target\n    hierarchy = await client.find_studio_hierarchy(\"studio-123\")\n\n    print(\"Studio hierarchy:\")\n    for i, studio in enumerate(hierarchy):\n        indent = \"  \" * i\n        print(f\"{indent}{studio.name}\")\n\n    # Get just the root studio\n    root = await client.find_studio_root(\"studio-123\")\n    print(f\"Root studio: {root.name}\")\n</code></pre>"},{"location":"guide/usage-patterns/#pattern-8-error-handling","title":"Pattern 8: Error Handling","text":""},{"location":"guide/usage-patterns/#handling-graphql-errors","title":"Handling GraphQL Errors","text":"<pre><code>from stash_graphql_client import StashContext\nfrom stash_graphql_client.errors import GraphQLError\nfrom gql.transport.exceptions import TransportQueryError\n\nasync with StashContext(conn={...}) as client:\n    try:\n        scene = await client.find_scene(\"invalid-id\")\n    except TransportQueryError as e:\n        print(f\"GraphQL query error: {e}\")\n        # Handle specific GraphQL errors\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"guide/usage-patterns/#handling-validation-errors","title":"Handling Validation Errors","text":"<pre><code>from stash_graphql_client.types import Scene\nfrom pydantic import ValidationError\n\ntry:\n    scene = Scene(\n        title=\"Test\",\n        rating100=150  # Invalid: must be 0-100\n    )\nexcept ValidationError as e:\n    print(\"Validation errors:\")\n    for error in e.errors():\n        print(f\"  {error['loc']}: {error['msg']}\")\n</code></pre>"},{"location":"guide/usage-patterns/#handling-connection-errors","title":"Handling Connection Errors","text":"<pre><code>from stash_graphql_client import StashContext\nfrom httpx import ConnectError, TimeoutException\n\ntry:\n    async with StashContext(conn={...}) as client:\n        scenes = await client.find_scenes()\nexcept ConnectError:\n    print(\"Cannot connect to Stash server\")\nexcept TimeoutException:\n    print(\"Request timed out\")\n</code></pre>"},{"location":"guide/usage-patterns/#next-steps","title":"Next Steps","text":"<ul> <li>Overview Guide - Architecture and core concepts</li> <li>UNSET Pattern Guide - Deep dive on partial updates</li> <li>API Reference - Complete method documentation</li> <li>Architecture Details - Implementation deep dives</li> </ul>"},{"location":"reference/quick-reference/","title":"Quick Reference: UNSET &amp; UUID4 Patterns","text":"<p>One-page reference for developers using the UNSET sentinel and UUID4 auto-generation patterns.</p>"},{"location":"reference/quick-reference/#unset-sentinel","title":"UNSET Sentinel","text":""},{"location":"reference/quick-reference/#import","title":"Import","text":"<pre><code>from stash_graphql_client.types import UNSET, UnsetType\n</code></pre>"},{"location":"reference/quick-reference/#three-field-states","title":"Three Field States","text":"<pre><code>scene.title = \"Test\"   # Level 1: Set to value\nscene.title = None     # Level 2: Set to null\nscene.title = UNSET    # Level 3: Never touched\n</code></pre>"},{"location":"reference/quick-reference/#checking-field-state","title":"Checking Field State","text":"<pre><code># \u2705 CORRECT - Use identity comparison (is)\nif scene.title is UNSET:\n    print(\"Never touched\")\nelif scene.title is None:\n    print(\"Explicitly null\")\nelse:\n    print(f\"Value: {scene.title}\")\n\n# \u274c WRONG - Don't use equality or boolean\nif not scene.title:  # Ambiguous! Could be UNSET, None, or empty string\n    pass\n</code></pre>"},{"location":"reference/quick-reference/#field-definitions","title":"Field Definitions","text":"<pre><code>class MyEntity(StashObject):\n    # Required field with UNSET default\n    name: str | UnsetType = UNSET\n\n    # Optional field (can be null)\n    description: str | None | UnsetType = UNSET\n\n    # Required field (no default)\n    id: str\n</code></pre>"},{"location":"reference/quick-reference/#to_input-pattern","title":"to_input() Pattern","text":"<pre><code>async def to_input(self) -&gt; dict[str, Any]:\n    data = {}\n\n    # Only include non-UNSET fields\n    if self.name is not UNSET:\n        data[\"name\"] = self.name\n\n    if self.description is not UNSET:\n        data[\"description\"] = self.description  # Could be None or value\n\n    return data\n</code></pre>"},{"location":"reference/quick-reference/#common-patterns","title":"Common Patterns","text":"<pre><code># Describe field state\ndef describe(value):\n    if value is UNSET:\n        return \"UNSET\"\n    elif value is None:\n        return \"NULL\"\n    else:\n        return f\"VALUE: {value}\"\n\n# Build GraphQL input excluding UNSET\ndef build_input(**fields):\n    return {k: v for k, v in fields.items() if v is not UNSET}\n\n# Set field conditionally\nif some_condition:\n    scene.rating = 85\nelse:\n    scene.rating = UNSET  # Don't touch this field\n</code></pre>"},{"location":"reference/quick-reference/#uuid4-auto-generation","title":"UUID4 Auto-Generation","text":""},{"location":"reference/quick-reference/#creating-new-objects","title":"Creating New Objects","text":"<pre><code># UUID4 is auto-generated\nscene = Scene(title=\"Test\")\nprint(scene.id)        # \"a1b2c3d4e5f6789012345678901234ab\"\nprint(scene.is_new())  # True\n\n# Explicit ID (no UUID generated)\nscene = Scene(id=\"123\", title=\"Test\")\nprint(scene.is_new())  # False\n</code></pre>"},{"location":"reference/quick-reference/#checking-if-new","title":"Checking if New","text":"<pre><code>if scene.is_new():\n    print(\"This is a new object with temporary UUID\")\nelse:\n    print(\"This is an existing object with server ID\")\n</code></pre>"},{"location":"reference/quick-reference/#save-workflow","title":"Save Workflow","text":"<pre><code># Create new object\nscene = Scene(title=\"Test\")\ntemp_id = scene.id  # UUID4\n\n# Save to server\nawait scene.save(client)\n\n# ID is now server-assigned\nprint(scene.id)        # \"456\" (server ID)\nprint(scene.is_new())  # False\nprint(temp_id != scene.id)  # True\n</code></pre>"},{"location":"reference/quick-reference/#manual-id-update","title":"Manual ID Update","text":"<pre><code># Normally done automatically by save()\nscene = Scene(title=\"Test\")\nscene.update_id(\"789\")  # Replace UUID with server ID\n</code></pre>"},{"location":"reference/quick-reference/#detection-logic","title":"Detection Logic","text":"<pre><code># is_new() returns True if:\n# - ID is 32 hex characters (UUID4)\n# - ID is legacy \"new\" marker\n# - ID is empty/None\n\n# Examples:\nScene(title=\"Test\").is_new()     # True (UUID4)\nScene(id=\"new\", ...).is_new()    # True (legacy marker)\nScene(id=\"123\", ...).is_new()    # False (server ID)\nScene(id=\"\", ...).is_new()       # True (empty)\n</code></pre>"},{"location":"reference/quick-reference/#combined-usage","title":"Combined Usage","text":""},{"location":"reference/quick-reference/#creating-and-saving-new-object","title":"Creating and Saving New Object","text":"<pre><code>from stash_graphql_client.types import Scene, UNSET\n\n# Create new scene with partial data\nscene = Scene(\n    title=\"My Scene\",       # Set\n    rating100=None,         # Explicitly null\n    # details = UNSET      # Never touched (implicit)\n)\n\nprint(scene.is_new())      # True\nprint(scene.id[:8])        # \"a1b2c3d4\" (UUID4 prefix)\n\n# to_input() includes only set fields\ninput_dict = await scene.to_input()\n# {\"title\": \"My Scene\", \"rating100\": null}\n# \"details\" excluded because UNSET\n\n# Save to server\nawait scene.save(client)\n\nprint(scene.is_new())      # False\nprint(scene.id)            # \"123\" (server ID)\n</code></pre>"},{"location":"reference/quick-reference/#partial-update","title":"Partial Update","text":"<pre><code># Fetch existing object\nscene = await client.find_scene(\"123\")\n\n# Update only one field\nscene.title = \"Updated Title\"\n# Other fields remain unchanged (not marked dirty)\n\n# to_input() only includes changed fields + ID\ninput_dict = await scene.to_input()\n# {\"id\": \"123\", \"title\": \"Updated Title\"}\n\n# Save sends minimal update\nawait scene.save(client)\n</code></pre>"},{"location":"reference/quick-reference/#explicit-null-vs-unset","title":"Explicit Null vs UNSET","text":"<pre><code>scene = await client.find_scene(\"123\")\n\n# Set to null (clear server value)\nscene.rating100 = None\nawait scene.save(client)\n# Server: rating100 = null\n\n# Leave UNSET (don't touch server value)\nscene.details = UNSET\nawait scene.save(client)\n# Server: details unchanged\n</code></pre>"},{"location":"reference/quick-reference/#testing-patterns","title":"Testing Patterns","text":""},{"location":"reference/quick-reference/#test-unset","title":"Test UNSET","text":"<pre><code>def test_unset_excluded():\n    scene = Scene(id=\"123\", title=\"Test\")\n    scene.rating = UNSET\n\n    input_dict = await scene.to_input()\n\n    assert \"title\" in input_dict\n    assert \"rating\" not in input_dict  # UNSET excluded\n</code></pre>"},{"location":"reference/quick-reference/#test-uuid4","title":"Test UUID4","text":"<pre><code>def test_new_object_gets_uuid():\n    scene = Scene(title=\"Test\")\n\n    assert scene.id is not None\n    assert len(scene.id) == 32\n    assert scene.is_new() is True\n\ndef test_save_updates_id(respx_mock, client):\n    scene = Scene(title=\"Test\")\n    original_id = scene.id\n\n    # Mock response\n    respx.post(\"http://localhost:9999/graphql\").mock(\n        return_value=httpx.Response(200, json={\"data\": {\"sceneCreate\": {\"id\": \"456\"}}})\n    )\n\n    await scene.save(client)\n\n    assert scene.id == \"456\"\n    assert scene.id != original_id\n    assert scene.is_new() is False\n</code></pre>"},{"location":"reference/quick-reference/#common-mistakes","title":"Common Mistakes","text":""},{"location":"reference/quick-reference/#wrong-using-with-unset","title":"\u274c Wrong: Using == with UNSET","text":"<pre><code># Don't do this\nif field == UNSET:  # Works but 'is' is better for singletons\n    pass\n</code></pre>"},{"location":"reference/quick-reference/#right-using-is-with-unset","title":"\u2705 Right: Using is with UNSET","text":"<pre><code># Do this\nif field is UNSET:\n    pass\n</code></pre>"},{"location":"reference/quick-reference/#wrong-boolean-check-for-unset","title":"\u274c Wrong: Boolean check for UNSET","text":"<pre><code># Don't do this - ambiguous!\nif not field:  # Could be UNSET, None, 0, empty string, etc.\n    pass\n</code></pre>"},{"location":"reference/quick-reference/#right-explicit-unset-check","title":"\u2705 Right: Explicit UNSET check","text":"<pre><code># Do this\nif field is UNSET:\n    pass\nelif field is None:\n    pass\nelse:\n    pass\n</code></pre>"},{"location":"reference/quick-reference/#wrong-manually-setting-uuid","title":"\u274c Wrong: Manually setting UUID","text":"<pre><code># Don't do this\nscene = Scene(id=uuid.uuid4().hex, title=\"Test\")\n</code></pre>"},{"location":"reference/quick-reference/#right-let-it-auto-generate","title":"\u2705 Right: Let it auto-generate","text":"<pre><code># Do this\nscene = Scene(title=\"Test\")  # UUID auto-generated\n</code></pre>"},{"location":"reference/quick-reference/#type-annotations","title":"Type Annotations","text":""},{"location":"reference/quick-reference/#for-fields","title":"For Fields","text":"<pre><code>from stash_graphql_client.types.unset import UnsetType\n\n# Required field with UNSET default\ntitle: str | UnsetType = UNSET\n\n# Optional field (nullable)\ndescription: str | None | UnsetType = UNSET\n\n# Required field (no UNSET)\nid: str\n</code></pre>"},{"location":"reference/quick-reference/#for-functions","title":"For Functions","text":"<pre><code>from typing import Any\n\ndef process_field(value: str | None | UnsetType) -&gt; Any:\n    if value is UNSET:\n        return None\n    elif value is None:\n        return \"NULL\"\n    else:\n        return value.upper()  # mypy knows it's str here\n</code></pre>"},{"location":"reference/quick-reference/#performance-notes","title":"Performance Notes","text":"<ul> <li>UUID4 generation: ~0.1\u03bcs per object</li> <li>UNSET check: O(1) identity comparison</li> <li>Memory: UNSET is a singleton (minimal overhead)</li> </ul>"},{"location":"reference/quick-reference/#summary","title":"Summary","text":"Pattern Use When Example Set to value Field has a value <code>scene.title = \"Test\"</code> Set to null Want to clear server value <code>scene.rating = None</code> UNSET Don't touch server value <code>scene.details = UNSET</code> Auto UUID Creating new object <code>scene = Scene(title=\"Test\")</code> is_new() Check if saved <code>if scene.is_new(): ...</code> update_id() After create (auto in save) <code>scene.update_id(\"123\")</code>"},{"location":"reference/quick-reference/#convenience-helper-methods","title":"Convenience Helper Methods","text":"<p>Some entity types provide convenience methods for relationship management.</p>"},{"location":"reference/quick-reference/#scene-helpers-7-methods","title":"Scene Helpers (7 methods)","text":"<pre><code># Add/remove entities from scene\nscene.add_to_gallery(gallery)        # Add scene to gallery\nscene.remove_from_gallery(gallery)   # Remove scene from gallery\nscene.add_performer(performer)       # Add performer to scene\nscene.remove_performer(performer)    # Remove performer from scene\nscene.add_tag(tag)                   # Add tag to scene\nscene.remove_tag(tag)                # Remove tag from scene\nscene.set_studio(studio)             # Set scene's studio\n</code></pre>"},{"location":"reference/quick-reference/#tag-helpers-6-methods","title":"Tag Helpers (6 methods)","text":"<pre><code># Parent/child relationships (bidirectional)\ntag.add_parent(parent_tag)           # Add parent tag (syncs both sides)\ntag.remove_parent(parent_tag)        # Remove parent tag (syncs both sides)\ntag.add_child(child_tag)             # Add child tag (syncs both sides)\ntag.remove_child(child_tag)          # Remove child tag (syncs both sides)\n\n# Recursive hierarchy traversal\ndescendants = tag.get_all_descendants()  # Get all descendant tags\nancestors = tag.get_all_ancestors()      # Get all ancestor tags\n</code></pre>"},{"location":"reference/quick-reference/#entity-mapping-helpers","title":"Entity Mapping Helpers","text":"<p>Convert entity names to IDs with auto-creation support:</p> <pre><code># Map tag names to IDs\ntag_ids = await client.map_tag_ids(\n    [\"Action\", \"Drama\", \"NewTag\"],\n    create=True  # Auto-create missing tags\n)\n\n# Map studio names to IDs\nstudio_ids = await client.map_studio_ids(\n    [\"Studio A\", \"Studio B\"],\n    create=True\n)\n\n# Map performer names to IDs (includes alias search)\nperformer_ids = await client.map_performer_ids(\n    [\"Jane Doe\", \"John Smith\"],\n    create=True,\n    on_multiple=OnMultipleMatch.RETURN_FIRST  # Handle duplicates\n)\n</code></pre>"},{"location":"reference/quick-reference/#studio-hierarchy-helpers","title":"Studio Hierarchy Helpers","text":"<pre><code># Get full parent chain from root to studio\nhierarchy = await client.find_studio_hierarchy(studio_id)\n# Returns: [&lt;Root Studio&gt;, &lt;Parent Studio&gt;, &lt;Child Studio&gt;]\n\n# Find the top-level parent studio\nroot = await client.find_studio_root(studio_id)\n</code></pre>"},{"location":"reference/quick-reference/#notes","title":"Notes","text":"<ul> <li>Group convenience helpers are documented in Bidirectional Relationships but not yet implemented. Currently, manage group relationships using direct field assignment with <code>containing_groups</code> and <code>sub_groups</code> fields.</li> <li>Other entity types (Performer, Gallery, Image, etc.) do not have convenience helpers - use direct field assignment instead.</li> </ul>"},{"location":"reference/quick-reference/#additional-resources","title":"Additional Resources","text":"<ul> <li>Full Guide: UNSET &amp; UUID4 Patterns - Comprehensive guide with examples</li> <li>Usage Examples: Convenience Methods - ID mapping, hierarchy navigation</li> <li>Architecture: Bidirectional Relationships - Entity relationship patterns</li> <li>API Reference: StashEntityStore - Identity map and caching</li> </ul>"}]}